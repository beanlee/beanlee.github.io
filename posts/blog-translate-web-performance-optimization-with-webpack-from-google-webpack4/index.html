
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="BeanLee Blog">
    <title>【译】Google 出品 - 利用 webpack 做 web 性能优化 - BeanLee Blog</title>
    <meta name="author" content="Bean Lee">
    
    
        <link rel="icon" href="https://beanlee.github.io/favicon.png">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Bean Lee","sameAs":["https://github.com/beanlee","https://twitter.com/MrBean_Lee","https://www.linkedin.com/in/beanlee-75309387","https://instagram.com/beanlee2020"],"image":"https://beanlee.github.io/favicon.png"},"articleBody":"作者 Addy Osmani，Ivan Akulov\n原文 https://developers.google.com/web/fundamentals/performance/webpack/\n\nPS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpack 4 内容，同时对原译文进行了校对和一些细节措辞的修改。\n\n\n\n\nInstroduction 介绍\nDecrease Front-end Size 减少前端体积\nUse the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）\nEnable minification 开启最小化\nSpecify NODE_ENV=production 明确生产环境信息\nUse ES Modules 使用 ES 模块\nOptimize images 优化图片\nOptimize dependencies 优化依赖\nEnable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接\nUse externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals\nSumming up 总结\n\n\nMake use of long-term caching 利用好长时缓存\nUse bundle versioning and cache headers 使用 bundle 版本和缓存头信息\nExtract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件\nInline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求\nLazy-load code that you don’t need right now 懒加载\nSplit the code into routes and pages 拆分代码到路由和页面中\nMake module ids more stable 使用稳定的 module ids\nSumming up\n\n\nMonitor and analyze the app 监控并分析\nKeep track of the bundle size 跟踪打包的体积\nAnalyze why the bundle is so large 分析 bundle 为什么这么大\nSumming up 小结\n\n\nConclusion\n\n\nInstroduction 介绍作者 Addy Osmani\n现代 Web 应用经常用到 bunding tool 来创建生产环境的打包文件（例如脚本、样式等等），打包文件是需要优化并压缩最小化，同时能够被用户更快地加载。在这篇文章中，我们将会利用 webpack 来贯穿说明如何进行高效地优化网站资源。这能帮助用户更快地加载你的应用同时获得更好的体验。\n\nwebpack 是当今最流行的打包工具之一，深入地利用它的特点去优化代码，将脚本拆分成不同的部分，同时剔除无用代码将能够保证你的应用维持最小的带宽和进程消耗。\n\n\nNote: 我们创建了一个练习的应用来演示下面这些优化的描述。尽力抽更多的时间来练习这些 tips webpack-training-project\n\n让我们从现代 web 应用中最耗费资源之一的 Javascript 开始。\n\n减小前端体积\n利用长时缓存\n监控并分析应用\n总结\n\n\nDecrease Front-end Size 减少前端体积作者 Ivan Akulov\n当你正在优化一个应用时，首要事情就是尽可能地将它体积的减小。下面我们就来看看通过 webpack 如何做到减小前端体积。\nUse the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）Webpack 4 介绍了一种新的模式，你可以将其设置成 development 和 production 用于告诉 Webpack 你正在为不同的环境打包：\n1234// webpack.config.jsmodule.exports = &#123;  mode: 'production',&#125;;\n当你正在为你的应用用于生产环境编译打包时要确定开启了 production 模式。这样就帮助 webpack 开启类似压缩最小化代码、去除依赖库中开发环境代码等其他的优化项。\nFurther reading 扩展阅读\nWhat specific things the mode flag configures\n\n\nNote: 笔者也翻译了另外一篇介绍新增 mode 的文章，感兴趣可以点击链接\n\nEnable minification 开启最小化\nNote: 大部分只针对 webpack 3 如果你正在使用 webpack 4 生产模式打包，bundle 级别的最小化功能已经开启 - 你只需要配置对应 loader 选项即可\n\n最小化就是通过去除多余空格、缩短变量名等方式压缩代码。例如：\n1234567891011// Original codefunction map(array, iteratee) &#123;  let index = -1;  const length = array == null ? 0 : array.length;  const result = new Array(length);  while (++index &lt; length) &#123;    result[index] = iteratee(array[index], index, array);  &#125;  return result;&#125;\n↓\n12// Minified codefunction map(n,r)&#123;let t=-1;for(const a=null==n?0:n.length,l=Array(a);++t&lt;a;)l[t]=r(n[t],t,n);return l&#125;\nWebpack 支持两种方式最小化代码：bundle-level 最小化 和 loader-specific options。他们可以同时使用。\nBundle-level minification bundle 级别的最小化Bundle-level 最小化功能可以在编译完成后压缩整个 bundle。下面来看下它是如何工作的：\n1.原始代码如下：\n12345// comments.jsimport './comments.css';export function render(data, target) &#123;  console.log('Rendered!');&#125;\n2.Webpack 编译后的内容大概是下面这个样子：\n1234567891011// bundle.js (part of)\"use strict\";Object.defineProperty(__webpack_exports__, \"__esModule\", &#123; value: true &#125;);/* harmony export (immutable) */ __webpack_exports__[\"render\"] = render;/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(1);/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);function render(data, target) &#123;  console.log('Rendered!');&#125;\n3.最小化之后的代码大概是下面这个样子：\n123// minified bundle.js (part of)\"use strict\";function t(e,n)&#123;console.log(\"Rendered!\")&#125;Object.defineProperty(n,\"__esModule\",&#123;value:!0&#125;),n.render=t;var o=r(1);r.n(o)\n在 Webpack 4 中，bundle 级别的的最小化是自动开启的 - 同时在生产模式下、没有启用 bundle-level 都会开启。它是利用 UglifyJS 引擎来进行最小化的。（如果你需要禁用最小化，仅仅设置开发模式或者设置 optimization.minimize 为 false。）\n在 Webpack 3 中，你需要直接使用 UglifyJS 插件。该插件是 webpack 提供的；开启并设置插件选项即可：\n12345678// webpack.config.jsconst webpack = require('webpack');module.exports = &#123;  plugins: [    new webpack.optimize.UglifyJsPlugin(),  ],&#125;;\n\nNote: 在 webpack 3 中，UglifyJS 插件不能编译 ES2015+(ES6) 的代码，这就意味着你在代码中使用 classes, arrow function 或者其他新特性时，不能将他们编译成 ES5的代码，插件会抛错。如果你需要编译这些新语法，就要用到 uglifyjs-webpack-plugin package，他也是在 webpack 中捆绑一起的，但是版本更新，并且可以编译 ES2015+ 的代码。\n\nLoader-specific options 特定的 Loader 配置最小化代码的第二步就是利用特定的 loader 配置。配置这些 loader，你可以压缩那些不能被最小化的部分。举个例子，当你使用 css-loader 引入一个 css 文件时，文件会被编译成一个字符串：\n1234/* comments.css */.comment &#123;  color: black;&#125;\n↓\n123// minified bundle.js (part of)exports=module.exports=__webpack_require__(1)(),exports.push([module.i,\".comment &#123;\\r\\n  color: black;\\r\\n&#125;\",\"\"]);\n这部分内容由于是字符串并没有被最小化。于是我们需要配置对应的 loader 选项来达到最小化的目的：\n1234567891011121314// webpack.config.jsmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.css$/,        use: [          'style-loader',          &#123; loader: 'css-loader', options: &#123; minimize: true &#125; &#125;,        ],      &#125;,    ],  &#125;,&#125;;\nFurther reading\nThe UglifyJsPlugin docs UglifyJs 插件文档\nOther popular minifiers: Babel Minify, Google Closure Compiler 其他流行的最小化工具\n\nSpecify NODE_ENV=production 明确生产环境信息\nNote: 仅在 webpack 3 中生效，如果使用生产模式 webpack 4 打包，NODE_ENV=production 优化项已经开启，就可以直接跳过此小结\n\n减小前端体积的另外一个方法就是在代码中将 NODE_ENV 环境变量设置为 production 。\nLibraries 会读取 NODE_ENV 变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当NODE_ENV没有设置成production，Vue.js 会做额外的检查并且输出一些警告：\n123456// vue/dist/vue.runtime.esm.js// …if (process.env.NODE_ENV !== 'production') &#123;  warn('props must be strings when using array syntax.');&#125;// …\nReact 也是类似 - 开发模式下 build 带有一些警告：\n123456789101112131415// react/index.jsif (process.env.NODE_ENV === 'production') &#123;  module.exports = require('./cjs/react.production.min.js');&#125; else &#123;  module.exports = require('./cjs/react.development.js');&#125;// react/cjs/react.development.js// …warning$3(  componentClass.getDefaultProps.isReactClassApproved,  'getDefaultProps is only used on classic React.createClass ' +  'definitions. Use a static property named `defaultProps` instead.');// …\n这些检查和警告通常在生产环境下是不必要的，但是他们仍然保留在代码中并且会增加库的体积。\n在 Webpack 4 中增加 optimization.nodeEnv: &#39;production&#39; 选项即可剔除掉它们：\n1234567// webpack.config.js (for webpack 4)module.exports = &#123;  optimization: &#123;    nodeEnv: 'production',    minimize: true,  &#125;,&#125;;\n在 Webpack 3 中则使用 DefinePlugin ：\n1234567891011 // webpack.config.js (for webpack 3)const webpack = require('webpack');module.exports = &#123;  plugins: [    new webpack.DefinePlugin(&#123;      'process.env.NODE_ENV': '\"production\"',    &#125;),    new webpack.optimize.UglifyJsPlugin(),  ],&#125;;\noptimization.nodeEnv: &#39;production&#39; 选项和 DefinePlugin 插件采用相同的方式来解决这个问题 - 这个方式就是他们将 process.env.NODE_ENV 替换成特定的值，下面的配置可以说明：\n1.Webpack 会将所有 process.env.NODE_ENV 替换成 &quot;production&quot;：\n1234567// vue/dist/vue.runtime.esm.jsif (typeof val === 'string') &#123;  name = camelize(val);  res[name] = &#123; type: null &#125;;&#125; else if (process.env.NODE_ENV !== 'production') &#123;  warn('props must be strings when using array syntax.');&#125;\n↓\n1234567// vue/dist/vue.runtime.esm.jsif (typeof val === 'string') &#123;  name = camelize(val);  res[name] = &#123; type: null &#125;;&#125; else if (\"production\" !== 'production') &#123;  warn('props must be strings when using array syntax.');&#125;\n2.与此同时最小化工具会移除掉所有 if 的条件分支 - 由于 &quot;production&quot; !== &#39;production&#39; 永远会返回 false，这样分支内的代码就永远不会执行：\n1234567// vue/dist/vue.runtime.esm.jsif (typeof val === 'string') &#123;  name = camelize(val);  res[name] = &#123; type: null &#125;;&#125; else if (\"production\" !== 'production') &#123;  warn('props must be strings when using array syntax.');&#125;\n↓\n12345// vue/dist/vue.runtime.esm.js (without minification)if (typeof val === 'string') &#123;  name = camelize(val);  res[name] = &#123; type: null &#125;;&#125;\nFurther Reading 扩展阅读\nWhat “environment variables” are 解释什么是环境变量\nWebpack docs about: DefinePlugin, EnvironmentPlugin Define 插件和 Environment 插件文档\n\nUse ES Modules 使用 ES 模块下面这个方式利用 ES modules 减小前端体积。\n当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿了整个依赖树，检查哪些依赖被使用，同时移除掉无用依赖。因此，如果你使用 ES module 方式的时候，webpack 帮你可以排除掉无用代码：\n1.一个有多个 export 的文件，但是 app 只需要其中一个：\n1234567// comments.jsexport const render = () =&gt; &#123; return 'Rendered!'; &#125;;export const commentRestEndpoint = '/rest/comments';// index.jsimport &#123; render &#125; from './comments.js';render();\n2.Webpack 分析 commentRestEndPoint 没有被用到，就不会在一个 bundle 中生成单独的 export：\n123456789// bundle.js (part that corresponds to comments.js)(function(module, __webpack_exports__, __webpack_require__) &#123;  \"use strict\";  const render = () =&gt; &#123; return 'Rendered!'; &#125;;  /* harmony export (immutable) */ __webpack_exports__[\"a\"] = render;  const commentRestEndpoint = '/rest/comments';  /* unused harmony export commentRestEndpoint */&#125;)\n3.最小化工具就会移除掉无用变量：\n12// bundle.js (part that corresponds to comments.js)(function(n,e)&#123;\"use strict\";var r=function()&#123;return\"Rendered!\"&#125;;e.b=r&#125;)\n如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。\n\nNote: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；UglifyJSPlugin才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：Babel Minify plugin or Google Closure Compiler plugin）\n\n\nWarning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel babel-preset-env or babel-preset-es2015，检查一下当前的配置。默认情况下， ES import and export to CommonJS require and module.exports。通过设置 option 来禁止掉Pass the { modules: false } option。\n\nFuther reading 扩展阅读\n“ES6 Modules in depth” 深入理解 ES6 Modules\nWebpack docs about tree shaking Webpack tree shaking 文档\n\nOptimize images 优化图片图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。可以利用 url-loader，svg-url-loader 和 image-webpack-loader 来进行优化。\nurl-loader 允许将小的静态文件打包进 app。没有配置的话，他需要通过传递文件，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明 limit 选项，它将会编码成更小的文件 base64 url 并返回这个 url。这样将图片放在 Javascript 代码中，可以节省 HTTP 的请求：\n123456789101112131415// webpack.config.jsmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(jpe?g|png|gif)$/,        loader: 'url-loader',        options: &#123;          // Inline files smaller than 10 kB (10240 bytes)          limit: 10 * 1024,        &#125;,      &#125;,    ],  &#125;&#125;;\n123456// index.jsimport imageUrl from './image.png';// → If image.png is smaller than 10 kB, `imageUrl` will include// the encoded image: 'data:image/png;base64,iVBORw0KGg…'// → If image.png is larger than 10 kB, the loader will create a new file,// and `imageUrl` will include its url: `/2fcd56a1920be.png`\n\nNote: 内联图片减少了独立请求的数量，这是很好的方式（even with HTTP/2），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。\n\nsvg-url-loader与url-loader类似 - 都是将使用 URL encoding  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：\n123456789101112131415161718// webpack.config.jsmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.svg$/,        loader: 'svg-url-loader',        options: &#123;          // Inline files smaller than 10 kB (10240 bytes)          limit: 10 * 1024,          // Remove the quotes from the url          // (they’re unnecessary in most cases)          noquotes: true,        &#125;,      &#125;,    ],  &#125;,&#125;;\n\nNote: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，设置 iesafe: true 选项\n\nimage-webpack-loader压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。\n这个 loader 不会将图片嵌入在应用内，因此它必须与url-loader和svg-url-loader配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用enforce: pre作为单独的一个 rule 涵盖这个 loader：\n12345678910111213// webpack.config.jsmodule.exports = &#123;  module: &#123;    rules: [      &#123;        test: /\\.(jpe?g|png|gif|svg)$/,        loader: 'image-webpack-loader',        // This will apply the loader before the other ones        enforce: 'pre',      &#125;,    ],  &#125;,&#125;;\n默认 loader 设置就已经可以满足需求了 - 但如果你想要深入配置，请查看 the plugin options。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 guide on image optimization\nFurther reading 扩展阅读\n“What is base64 encoding used for?” Base64 编码究竟可以用在何处？\nAddy Osmani’s guide on image optimization Addy Osmani 的图片优化指南\n\nOptimize dependencies 优化依赖平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。\n举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大约 65 KB 代码没有用处。\n另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。\n所有这些依赖都可以被轻易优化。我们在 Github repo 收集了优化的建议，check it out！\nEnable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接\nNote: 如果你在使用生产模式下的 webpack 4，modules concatention 已经开启，可以直接跳过本小节。\n\n当你构建 bundle 时，webpack 将每一个 module 封装进 function 中：\n12345678// index.jsimport &#123;render&#125; from './comments.js';render();// comments.jsexport function render(data, target) &#123;  console.log('Rendered!');&#125;\n↓\n1234567891011121314151617181920// bundle.js (part  of)/* 0 */(function(module, __webpack_exports__, __webpack_require__) &#123;  \"use strict\";  Object.defineProperty(__webpack_exports__, \"__esModule\", &#123; value: true &#125;);  var __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(1);  Object(__WEBPACK_IMPORTED_MODULE_0__comments_js__[\"a\" /* render */])();&#125;),/* 1 */(function(module, __webpack_exports__, __webpack_require__) &#123;  \"use strict\";  __webpack_exports__[\"a\"] = render;  function render(data, target) &#123;    console.log('Rendered!');  &#125;&#125;)\n在以前，这么做是使 CommonJS/AMD modules 互相分离所必须的。但是，这会增加体积并且性能表现堪忧。\nWebpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用ModuleConcatenationPlugin完成这样一个 bundle，下面是例子：\n12345678// index.jsimport &#123;render&#125; from './comments.js';render();// comments.jsexport function render(data, target) &#123;  console.log('Rendered!');&#125;\n↓\n1234567891011121314151617181920// Unlike the previous snippet, this bundle has only one module// which includes the code from both files// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件// bundle.js (part of; compiled with ModuleConcatenationPlugin)/* 0 */(function(module, __webpack_exports__, __webpack_require__) &#123;  \"use strict\";  Object.defineProperty(__webpack_exports__, \"__esModule\", &#123; value: true &#125;);  // CONCATENATED MODULE: ./comments.js  function render(data, target) &#123;    console.log('Rendered!');  &#125;  // CONCATENATED MODULE: ./index.js  render();&#125;)\n看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 ModuleConcatenationPlugin，require被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！\n在 Webpack 4 中开启这个功能，启用 optimization.concatenateModules 选项即可：\n123456// webpack.config.js (for webpack 4)module.exports = &#123;  optimization: &#123;    concatenateModules: true,  &#125;,&#125;;\n在 webpack 3 中，使用 ModuleConcatenationPlugin 插件：\n12345678// webpack.config.js (for webpack 3)const webpack = require('webpack');module.exports = &#123;  plugins: [    new webpack.optimize.ModuleConcatenationPlugin(),  ],&#125;;\n\nNote：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， 但是他会增加编译的时间同时破坏 module 的热更新。这就是为什么只在生产环境中启用的原因了。\n\nFurther reading 扩展阅读\nWebpack docs for the ModuleConcatenationPlugin ModuleConcatenationPlugin 文档\n“Brief introduction to scope hoisting”\nDetailed description of what this plugin does 详述这些插件做了些什么\n\nUse externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：\n\n如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。the webpack’s externals option就干了这件事 - 它用变量或者外部引用来替代 modules。\n如果依赖是挂载到 window 上的情况如果你的非 webpack 代码依靠这些依赖，它们是挂载 window 上的变量，可以将依赖名称 alias 成变量名：\n1234567// webpack.config.jsmodule.exports = &#123;  externals: &#123;    'react': 'React',    'react-dom': 'ReactDOM',  &#125;,&#125;;\n利用这个配置，webpack 将不会打包 react 和 react-dom 包。取而代之，他们会被替换成下面这个样子：\n1234567891011// bundle.js (part of)(function(module, exports) &#123;  // A module that exports `window.React`. Without `externals`,  // this module would include the whole React bundle  module.exports = React;&#125;),(function(module, exports) &#123;  // A module that exports `window.ReactDOM`. Without `externals`,  // this module would include the whole ReactDOM bundle  module.exports = ReactDOM;&#125;)\n如果依赖是当做 AMD 包被加载的情况如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。\n具体如何做呢？将 webpack 代码编译成一个 AMD module 同时别名成一个库的 URLs：\n123456789// webpack.config.jsmodule.exports = &#123;  output: &#123; libraryTarget: 'amd' &#125;,  externals: &#123;    'react': &#123; amd: '/libraries/react.min.js' &#125;,    'react-dom': &#123; amd: '/libraries/react-dom.min.js' &#125;,  &#125;,&#125;;\nWebpack 将会把 bundle 包装进 define()同时让它依赖于这些URLs：\n12// bundle.js (beginning)define([\"/libraries/react.min.js\", \"/libraries/react-dom.min.js\"], function () &#123; … &#125;);\n如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。\n\nNote：webpack 只是替换那些 externals 对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写import React from &#39;react/umd/react.production.min.js&#39;，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 import &#39;react&#39; 和 import &#39;react/umd/react.production.min.js&#39; 是同一个库，这样比较谨慎。\n\nFurther reading 扩展阅读\nWebpack docs on externals externals 文档\n\nSumming up 总结\nEnable the production mode if you use webpack 4 如果使用 webpack 4 开启生产模式\nMinimize your code with the bundle-level minifier and loader options 使用 bundle 级别最小化 和 loader 选项来最小化你的代码\nRemove the development-only code by replacing NODE_ENV with production 通过将 NODE_ENV 替换成 production 来移除开发期间代码\nUse ES modules to enable tree shaking 启用 tree shaking\nCompress images 压缩图片\nApply dependency-specific optimizations 开启依赖优化\nEnable module concatenation 开启 module 连接\nUse externals if this makes sense for you 如果有效果的话可以使用 externals\n\n\nMake use of long-term caching 利用好长时缓存作者 Ivan Akulov\n在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分，这样会在每一次请求中减少重新下载的次数。\nUse bundle versioning and cache headers 使用 bundle 版本和缓存头信息做缓存通用的解决办法：\n1.告诉浏览器缓存一个文件很长时间（比如一年）\n12# Server headerCache-Control: max-age=31536000\nNote：如果你不熟悉 Cache-Control 做了什么，你可以看一下 Jake Archibald 的精彩博文 on caching best practices\n2.当文件改变需要强制重新下载时去重命名这些文件\n12345&lt;!-- Before the change --&gt;&lt;script src=\"./index-v15.js\"&gt;&lt;/script&gt;&lt;!-- After the change --&gt;&lt;script src=\"./index-v16.js\"&gt;&lt;/script&gt;\n这些方法可以告诉浏览器下载这些 JS 文件，将其缓存起来。浏览器将只会在文件名发生改变时才会请求网络（或者缓存失效的情况也会请求）。\n使用 webpack，也可以做同样的事，但可以使用版本号来解决，需要明确这个文件的 hash 值。使用 [chunkhash] 可以将 hash 值包含进文件名中：\n12345678// webpack.config.jsmodule.exports = &#123;  entry: './index.js',  output: &#123;    filename: 'bundle.[chunkhash].js',        // → bundle.8e0d62a03.js  &#125;,&#125;;\n\nNote: webpack 可能会生成不同的 hash 即使 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 This is a bug.如果你需要将文件名发送给客户端，也可以使用 HtmlWebpackPlugin 或者 WebpackManifestPlugin。\n\nHtmlWebpackPlugin 使用起来很简单，但灵活性有一些欠缺。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：\n1234&lt;!-- index.html --&gt;&lt;!doctype html&gt;&lt;!-- ... --&gt;&lt;script src=\"bundle.8e0d62a03.js\"&gt;&lt;/script&gt;\nWebpackManifestPlugin 更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：\n1234// manifest.json&#123;  \"bundle.js\": \"bundle.8e0d62a03.js\"&#125;\nFurther reading 扩展阅读\nJake Archibald about caching best practices cache 的最佳实践\n\nExtract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件Dependencies 依赖App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。\n\nKey Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 chunks。我们后面会用到这个名词。\n\n为了将依赖包提取到单独的 chunk 中，下面分为三步：\n1.使用 [name].[chunkname].js 替换output的文件名：\n123456789// webpack.config.jsmodule.exports = &#123;  output: &#123;    // Before    filename: 'bundle.[chunkhash].js',    // After    filename: '[name].[chunkhash].js',  &#125;,&#125;;\n当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换 [name]。如果没有添加 [name] 部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太困难了！\n2.将 entry 转成一个对象：\n123456789// webpack.config.jsmodule.exports = &#123;  // Before  entry: './index.js',  // After  entry: &#123;    main: './index.js',  &#125;,&#125;;\n在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 [name]代替。\n目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。\n3.在 Webpack 4 中，在配置中增加 optimization.splitChunks.chunks: &#39;all&#39; 即可：\n12345678// webpack.config.js (for webpack 4)module.exports = &#123;  optimization: &#123;    splitChunks: &#123;      chunks: 'all',    &#125;  &#125;,&#125;;\n这个选项会开启智能代码拆分。使用这个功能，webpack 将最小化和 Gzip 前大于 30KB 的代码提取出额外的 vendor 代码。它同时也会提取出 common 代码 - 这些代码在打包多个 bundles 会起到作用。（例如：通过路由拆分应用）。\n在 Webpack 3 中，使用 CommonsChunkPlugin 插件：\n1234567891011121314// webpack.config.js (for webpack 3)module.exports = &#123;  plugins: [    new webpack.optimize.CommonsChunkPlugin(&#123;      // A name of the chunk that will include the dependencies.      // This name is substituted in place of [name] from step 1      name: 'vendor',      // A function that determines which modules to include into this chunk      minChunks: module =&gt; module.context &amp;&amp;        module.context.includes('node_modules'),    &#125;),  ],&#125;;\n插件将包括全部 node_modules 路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 vendor.[chunkhash].js。\n完成了上面的步骤，每一次 build 都会生成两个文件。浏览器会将他们单独缓存 - 以便代码发生改变时重新下载。\n1234567$ webpackHash: ac01483e8fec1fa70676Version: webpack 3.8.1Time: 3816ms                           Asset   Size  Chunks             Chunk Names  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\nWebpack runtime code 运行时代码不幸的是，仅仅抽取 vendor 是不够的。如果你试图在应用代码中修改一些东西：\n123456// index.js……// E.g. add this:console.log('Wat');\n你会注意到 vendor 的也会改变：\n12                           Asset   Size  Chunks             Chunk Names./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor\n↓\n12                            Asset   Size  Chunks             Chunk Names./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor\n这因为 webpack 打包时，一部分 modules 的代码，拥有 a runtime - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：\n1234// vendor.e6ea4504d61a1cc1c60b.jsscript.src = __webpack_require__.p + chunkId + \".\" + &#123;  \"0\": \"2f2269c7f0a55a5c1871\"&#125;[chunkId] + \".js\";\nWebpack 将最新生成的 chunk 包含在这个 runtime 内，这个 chunk 就是我们代码中的 vendor。与此同时每一次任何 chunk 的修改，即使这一小部分代码也改变，也会导致整个 vendor chunk 改变。\n为了解决这个问题，我们将 runtime 转义到一个独立的文件中，在 Webpack 4 中，开启 optimization.runtimeChunk 选项：\n123456// webpack.config.js (for webpack 4)module.exports = &#123;  optimization: &#123;    runtimeChunk: true,  &#125;,&#125;\n在 Webpack 3中，通过 CommonsChunkPlugin 创建一个额外的空的 chunk：\n123456789101112131415161718192021// webpack.config.js (for webpack 3)module.exports = &#123;  plugins: [    new webpack.optimize.CommonsChunkPlugin(&#123;      name: 'vendor',      minChunks: module =&gt; module.context &amp;&amp;        module.context.includes('node_modules'),    &#125;),    // This plugin must come after the vendor one (because webpack    // includes runtime into the last chunk)    new webpack.optimize.CommonsChunkPlugin(&#123;      name: 'runtime',      // minChunks: Infinity means that no app modules      // will be included into this chunk      minChunks: Infinity,    &#125;),  ],&#125;;\n完成这一部分改变，每一次 build 都将生成三个文件：\n12345678$ webpackHash: ac01483e8fec1fa70676Version: webpack 3.8.1Time: 3816ms                            Asset     Size  Chunks             Chunk Names   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n将他们反过来顺序添加到 index.html 中，你就搞定了：\n1234&lt;!-- index.html --&gt;&lt;script src=\"./runtime.79f17c27b335abc7aaf4.js\"&gt;&lt;/script&gt;&lt;script src=\"./vendor.26886caf15818fa82dfa.js\"&gt;&lt;/script&gt;&lt;script src=\"./main.00bab6fd3100008a42b0.js\"&gt;&lt;/script&gt;\nFurther reading 扩展阅读\nWebpack guide on long term caching webpack 关于 cache 指南\nWebpack docs about webpack runtime and manifest webpack 关于 runtime and manifest 文档\n“Getting the most out of the CommonsChunkPlugin” 使用 CommonsChunkPlugin 的最佳实践\n\nInline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求为了做的更好，我们可以尽力把 webpack runtime 内联在 HTML 请求里。下面举例：\n12&lt;!-- index.html --&gt;&lt;script src=\"./runtime.79f17c27b335abc7aaf4.js\"&gt;&lt;/script&gt;\n这样做：\n1234&lt;!-- index.html --&gt;&lt;script&gt;!function(e)&#123;function n(r)&#123;if(t[r])return t[r].exports;…&#125;&#125; ([]);&lt;/script&gt;\n这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。\n下面就来看看如何做。\n如果使用 HtmlWebpackPlugin 来生成 HTML如果使用 HtmlWebpackPlugin 来生成 HTML 文件，InlineChunkWebpackPlugin 就足够了。\n如果使用自己的定制服务逻辑来生成 HTMLWebpack 41.增加 WebpackManifestPlugin 插件已知运行时 chunk:\n12345678// webpack.config.js (for webpack 4)const ManifestPlugin = require('webpack-manifest-plugin');module.exports = &#123;  plugins: [    new ManifestPlugin(),  ],&#125;;\n插件就会生成一个下面这样的文件：\n1234// manifest.json&#123;  \"runtime~main.js\": \"runtime~main.8e0d62a03.js\"&#125;\n2.将这些内容嵌入到 runtime chunk 中。例如：使用 Node.js 和 Express：\n12345678910111213// server.jsconst fs = require('fs');const manifest = require('./manifest.json');const runtimeContent = fs.readFileSync(manifest['runtime~main.js'], 'utf-8');app.get('/', (req, res) =&gt; &#123;  res.send(`    …    &lt;script&gt;$&#123;runtimeContent&#125;&lt;/script&gt;    …  `);&#125;);\nWebpack 31.将 runtime 名称改成静态的明确的文件名：\n123456789101112// webpack.config.js (for webpack 3)module.exports = &#123;  plugins: [    new webpack.optimize.CommonsChunkPlugin(&#123;      name: 'runtime',      minChunks: Infinity,      filename: 'runtime.js',        // → Now the runtime file will be called        // “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”    &#125;),  ],&#125;;\n2.嵌入到 runtime.js 内容。比如：Node.js 和 Express\n1234567891011// server.jsconst fs = require('fs');const runtimeContent = fs.readFileSync('./runtime.js', 'utf-8');app.get('/', (req, res) =&gt; &#123;  res.send(`    …    &lt;script&gt;$&#123;runtimeContent&#125;&lt;/script&gt;    …  `);&#125;);\nLazy-load code that you don’t need right now 懒加载通常情况下，一个页面有或多或少的重要部分：\n\n如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。\n如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。\n\n在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 the import() function 和 code-splitting 解决这个问题：\n12345678910111213141516// videoPlayer.jsexport function renderVideoPlayer() &#123; … &#125;// comments.jsexport function renderComments() &#123; … &#125;// index.jsimport &#123;renderVideoPlayer&#125; from './videoPlayer';renderVideoPlayer();// …Custom event listeneronShowCommentsClick(() =&gt; &#123;  import('./comments').then((comments) =&gt; &#123;    comments.renderComments();  &#125;);&#125;);\nimport()明确表示你期望动态地加载独立的 module。当 webpack 看到 import(&#39;./module.js&#39;)时，他就会将这个 module 移到独立的 chunk 中：\n123456789$ webpackHash: 39b2a53cb4e73f0dc5b2Version: webpack 3.8.1Time: 4273ms                            Asset     Size  Chunks             Chunk Names      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n并且只在代码执行到 import() 才会下载。\n这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。\n\nNote: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 import() 而遇到语法错误抛出来。可以使用 syntax-dynamic-import 解决这个错误。\n\nFurther reading 扩展阅读\nWebpack docs for the import() function  webpack 中 import() 文档\nThe JavaScript proposal for implementing the import() syntax\n\nSplit the code into routes and pages 拆分代码到路由和页面中如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：\n\n他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。\n如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会只下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。\nFor single-page apps 对于单页面应用通过路由拆分带页面引用，使用 import()（看看 “Lazy-load code that you don’t need right now”这部分）。如果你在使用一个框架，现在已经有成熟的方案：\n\n“Code Splitting” in react-router‘s docs (for React)\n“Lazy Loading Routes” in vue-router‘s docs (for Vue.js)\n\nFor traditional multi-page apps 对于传统的多页面应用通过页面拆分传统多页面应用，可以使用 webpack 的 entry points 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：\n12345678// webpack.config.jsmodule.exports = &#123;  entry: &#123;    home: './src/Home/index.js',    article: './src/Article/index.js',    profile: './src/Profile/index.js'  &#125;,&#125;;\n对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：\n1234567891011$ webpackHash: 318d7b8490a7382bf23bVersion: webpack 3.8.1Time: 4273ms                            Asset     Size  Chunks             Chunk Names      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime\n因此，如果仅仅是文章页使用 Lodash ，home 和 profile 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。\n拆分依赖树也有缺点。如果两个 entry points 都用到了 loadash ，同时你没有在 vendor 移除掉依赖，两个 entry points 将包括两个重复的 lodash 。在 Webpack 4 中我们可以设置 optimization.splitChunks.chunks: &#39;all&#39; 解决该问题：\n12345678// webpack.config.js (for webpack 4)module.exports = &#123;  optimization: &#123;    splitChunks: &#123;      chunks: 'all',    &#125;  &#125;,&#125;;\n这个选项可以开启智能拆分代码，webpack 将自动寻找 common code 并将其提取到一个单独的文件中。\n在 Webpack 3 可以使用CommonsChunkPlugin来解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：\n1234567891011121314// webpack.config.js (for webpack 3)module.exports = &#123;  plugins: [    new webpack.optimize.CommonsChunkPlugin(&#123;      // A name of the chunk that will include the common dependencies      name: 'common',      // The plugin will move a module into a common file      // only if it’s included into `minChunks` chunks      // (Note that the plugin analyzes all chunks, not only entries)      minChunks: 2,    // 2 is the default value    &#125;),  ],&#125;;\n随意使用minChunks的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，minChunks 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。\nFurther reading 扩展阅读\nWebpack docs about the concept of entry points webpack 关于入口概念的文档\nWebpack docs about the CommonsChunkPlugin webpack 关于 CommonChunkPlugin 插件的文档\n“Getting the most out of the CommonsChunkPlugin”\n\nMake module ids more stable 使用稳定的 module ids当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被 require() 引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：\n123456789$ webpackHash: df3474e4f76528e3bbc9Version: webpack 3.8.1Time: 2150ms                           Asset      Size  Chunks             Chunk Names      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime\n↓\n123456[0] ./index.js 29 kB &#123;1&#125; [built][2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built][3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built][4] ./comments.js 58 kB &#123;0&#125; [built][5] ./ads.js 74 kB &#123;1&#125; [built] + 1 hidden module\n默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：\n123456789101112$ webpackHash: df3474e4f76528e3bbc9Version: webpack 3.8.1Time: 2150ms                           Asset      Size  Chunks             Chunk Names      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime   [0] ./index.js 29 kB &#123;1&#125; [built]   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]\n↓ 我们增加一个新 module\n1[4] ./webPlayer.js 24 kB &#123;1&#125; [built]\n↓ 现在看这里做了什么！ comments.js 现在的 ID 由 4 变成了 5\n1[5] ./comments.js 58 kB &#123;0&#125; [built]\n↓ ads.js 的 ID 由 5 变成 6\n12[6] ./ads.js 74 kB &#123;1&#125; [built]       + 1 hidden module\n这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_ 这个 chunk 和 main chunk 都会失效 - 只有 main 才应该失效。\n使用HashedModuleIdsPlugin插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：\n123456789$ webpackHash: df3474e4f76528e3bbc9Version: webpack 3.8.1Time: 2150ms                           Asset      Size  Chunks             Chunk Names      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime\n↓\n1234567[3IRH] ./index.js 29 kB &#123;1&#125; [built][DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built][JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built][LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built][lebJ] ./comments.js 58 kB &#123;0&#125; [built][02Tr] ./ads.js 74 kB &#123;1&#125; [built]    + 1 hidden module\n有了这个方法，只有你重命名或者删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。\n启用这个插件，在配置中增加 plugins：\n123456// webpack.config.jsmodule.exports = &#123;  plugins: [    new webpack.HashedModuleIdsPlugin(),  ],&#125;;\nFurther reading 扩展阅读\nWebpack docs about the HashedModuleIdsPlugin HashModuleIdsPlugin 插件文档\n\nSumming up\nCache the bundle and differentiate between versions by changing the bundle name 缓存 bundle 包并通过修改 bundle 名称来做版本差异\nSplit the bundle into app code, vendor code and runtime 将 bundle 拆分成 app 业务代码、vendor 代码、runtime 代码\nInline the runtime to save an HTTP request 将 runtime 代码内联节省 HTTP 请求\nLazy-load non-critical code with import 通过 import 懒加载非必要代码\nSplit code by routes/pages to avoid loading unnecessary stuff 通过路由或页面拆分阻止加载不必要代码\n\n\nMonitor and analyze the app 监控并分析作者 Ivan Akulov\n即使当你配置好你的 webpack 让你的应用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！\n这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。\nKeep track of the bundle size 跟踪打包的体积在开发时可以使用webpack-dashboard和命令行bundlesize 来监控 app 的体积。\nwebpack-dashboardwebpack-dashboard可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。\n\n这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！\n启用这个功能，需要安装 webpack-dashboard 包：\n1npm install webpack-dashboard --save-dev\n同时在配置的 plugins 增加：\n12345678// webpack.config.jsconst DashboardPlugin = require('webpack-dashboard/plugin');module.exports = &#123;  plugins: [    new DashboardPlugin(),  ],&#125;;\n或者如果正在使用基于 Express dev server 可以使用 compiler.apply()：\n1compiler.apply(new DashboardPlugin());\n多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。\nbundlesizebundlesize 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：\n\n配置如下：\nFind out the maximum sizes 找出最大体积1.分析 app 尽可能减小体积，执行生产环境的 build。2.在package.json中增加bundlesize部分：\n12345678// package.json&#123;  \"bundlesize\": [    &#123;      \"path\": \"./dist/*\"    &#125;  ]&#125;\n3.使用npx执行bundlesize：\n1npx bundlesize\n它就会将每一个文件的 gzip 压缩后的体积打印出来：\n1PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB\n4.每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。\nEnable bundlesize 启用 bundlesize5.安装bundlesize开发依赖\n1npm install bundlesize --save-dev\n6.在package.json中的bundlesize部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：\n1234567891011121314151617// package.json&#123;  \"bundlesize\": [    &#123;      \"path\": \"./dist/*.png\",      \"maxSize\": \"16 kB\",    &#125;,    &#123;      \"path\": \"./dist/main.*.js\",      \"maxSize\": \"20 kB\",    &#125;,    &#123;      \"path\": \"./dist/vendor.*.js\",      \"maxSize\": \"35 kB\",    &#125;  ]&#125;\n7.增加一个 npm 脚本来执行检查：\n123456// package.json&#123;  \"scripts\": &#123;    \"check-size\": \"bundlesize\"  &#125;&#125;\n8.配置自动化 CI 来在每一次 push 时执行npm run check-size做检查。（如果你在 Github 上开发项目，直接可以使用integrate bundlesize with GitHub。）\n这就全部了！现在如果你运行npm run check-size或者 push 代码，你就会看到输出的文件是否足够小：\n\n或者下面失败的情况\n\nFurther reading 扩展阅读\nAlex Russell about the real-world loading time we should target\n\nAnalyze why the bundle is so large 分析 bundle 为什么这么大你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。webpack-bundle-analyzer\n\n译者注：此处有视频，需要科学上网，请自行观看\n\n(Screen recording from github.com/webpack-contrib/webpack -bundle-analyzer)\nwebpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。\n使用这个分析器，需要安装webpack-bundle-analyzer包：\n1npm install webpack-bundle-analyzer --save-dev\n在 config 中增加插件：\n12345678// webpack.config.jsconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;module.exports = &#123;  plugins: [    new BundleAnalyzerPlugin(),  ],&#125;;\n运行生产环境的 build 这个插件就会在浏览器中打开一个显示状态的页面。\n默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。\n\nNote: 如果你使用 ModuleConcatenationPlugin，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。\n\n下面是报告中需要看什么：\n\nLarge dependencies 大型依赖 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 that are often not used and could be dropped）？\nDuplicated dependencies 重复依赖 是否在不同文件中看到过相同的库？（在 Webpack 4 中配置 optimization.splitChunks.chunks，或者在 Webpack 3中 使用 CommonsChunkPlugin 将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？\nSimilar dependencies 相似依赖 是否存在有相似功能的相似库存在？（比如moment和date-fns 或者 lodash 和 lodash-es）尽力汇总成一个。\n\n同样的，也可以看看 Sean Larkin 的文章 great analysis of webpack bundles。\nSumming up 小结\nUse webpack-dashboard and bundlesize to stay tuned of how large your app is\nDig into what builds up the size with webpack-bundle-analyzer\n\n\nConclusion总结：\n\n剔除不必要的体积 把所有的代码都压缩最小化，剔除无用代码，增加依赖时保持谨慎小心。\n通过路由拆分代码 只在真正需要的时候才加载，其余部分做懒加载。\n缓存代码 应用程序某些部分代码更新频率低于其他部分代码，可以将这些部分拆分成文件，以便在必要时仅重新下载。\n跟踪体积大小 使用  webpack-dashboard 和 webpack-bundle-analyzer 监控你的 app。每隔几个月重新检查一下你的应用的性能。\n\nWebpack 不仅仅是一个帮助你更快创建 app 的工具。它还帮助使你的 app 成为 a Progressive Web App ，你的应用拥有更好的体验以及自动化的填充工具就像Lighthouse根据环境给出建议。\n不要忘记阅读 webpack docs - 里面提供了大量的优化相关的信息。\n多多练习 with the training app！\n","dateCreated":"2018-05-02T14:35:33+08:00","dateModified":"2018-06-20T09:31:47+08:00","datePublished":"2018-05-02T14:35:33+08:00","description":"作者 Addy Osmani，Ivan Akulov\n原文 https://developers.google.com/web/fundamentals/performance/webpack/\n\nPS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpack 4 内容，同时对原译文进行了校对和一些细节措辞的修改。\n","headline":"【译】Google 出品 - 利用 webpack 做 web 性能优化","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/"},"publisher":{"@type":"Organization","name":"Bean Lee","sameAs":["https://github.com/beanlee","https://twitter.com/MrBean_Lee","https://www.linkedin.com/in/beanlee-75309387","https://instagram.com/beanlee2020"],"image":"https://beanlee.github.io/favicon.png","logo":{"@type":"ImageObject","url":"https://beanlee.github.io/favicon.png"}},"url":"https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/","keywords":"翻译, Webpack"}</script>
    <meta name="description" content="作者 Addy Osmani，Ivan Akulov 原文 https://developers.google.com/web/fundamentals/performance/webpack/  PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpa">
<meta name="keywords" content="翻译,Webpack">
<meta property="og:type" content="blog">
<meta property="og:title" content="【译】Google 出品 - 利用 webpack 做 web 性能优化">
<meta property="og:url" content="https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/index.html">
<meta property="og:site_name" content="BeanLee Blog">
<meta property="og:description" content="作者 Addy Osmani，Ivan Akulov 原文 https://developers.google.com/web/fundamentals/performance/webpack/  PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpa">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png">
<meta property="og:image" content="https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png">
<meta property="og:image" content="https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png">
<meta property="og:image" content="https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png">
<meta property="og:image" content="http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png">
<meta property="og:image" content="https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg">
<meta property="og:image" content="https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png">
<meta property="og:image" content="https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png">
<meta property="og:updated_time" content="2018-06-20T01:31:47.238Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】Google 出品 - 利用 webpack 做 web 性能优化">
<meta name="twitter:description" content="作者 Addy Osmani，Ivan Akulov 原文 https://developers.google.com/web/fundamentals/performance/webpack/  PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpa">
<meta name="twitter:image" content="https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png">
<meta name="twitter:creator" content="@https:&#x2F;&#x2F;twitter.com&#x2F;MrBean_Lee">
    
    
        
    
    
        <meta property="og:image" content="https://www.gravatar.com/avatar/3fe40c6cac2cee1d563a87ada4d02cc5?s=640"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-hmujtphswtnkmxr9nrbolulu5rdtlf5r16obkh0cadm91o9xxruanxhctll8.min.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-46079069-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-46079069-1');
    </script>


    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?db9bb97e9e15133d0f061a19cb4f6093";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">BeanLee Blog</a>
    </div>
    
        
            <a class="header-right-icon open-algolia-search" href="#search">
        
        
            <i class="search fa-lg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/3fe40c6cac2cee1d563a87ada4d02cc5?s=110" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">Bean Lee</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="分类">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="标签">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="搜索">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/links" title="链接">
                    
                        <i class="sidebar-button-icon fa fa-link" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">链接</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/beanlib" title="实验室">
                    
                        <i class="sidebar-button-icon fa fa-flask" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">实验室</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/beanlee" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://twitter.com/MrBean_Lee" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.linkedin.com/in/beanlee-75309387" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://instagram.com/beanlee2020" target="_blank" rel="noopener" title="Instagram">
                    
                        <i class="sidebar-button-icon fab fa-instagram" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Instagram</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            【译】Google 出品 - 利用 webpack 做 web 性能优化
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-05-02T14:35:33+08:00">
	
		    5月 02, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/前端技术/">前端技术</a>


    
    <span class="post-count">&nbsp;&nbsp;11,179 words, about  50 min read </span>
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a>，<a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p>
<p>原文 <a href="https://developers.google.com/web/fundamentals/performance/webpack/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/webpack/</a></p>
<blockquote>
<p>PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpack 4 内容，同时对原译文进行了校对和一些细节措辞的修改。</p>
</blockquote>
<a id="more"></a>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Instroduction-介绍"><span class="toc-text">Instroduction 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decrease-Front-end-Size-减少前端体积"><span class="toc-text">Decrease Front-end Size 减少前端体积</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-the-production-mode-webpack-4-only-使用生产模式（仅用于-webpack-4）"><span class="toc-text">Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enable-minification-开启最小化"><span class="toc-text">Enable minification 开启最小化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle-level-minification-bundle-级别的最小化"><span class="toc-text">Bundle-level minification bundle 级别的最小化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loader-specific-options-特定的-Loader-配置"><span class="toc-text">Loader-specific options 特定的 Loader 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading"><span class="toc-text">Further reading</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Specify-NODE-ENV-production-明确生产环境信息"><span class="toc-text">Specify NODE_ENV=production 明确生产环境信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-Reading-扩展阅读"><span class="toc-text">Further Reading 扩展阅读</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-ES-Modules-使用-ES-模块"><span class="toc-text">Use ES Modules 使用 ES 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Futher-reading-扩展阅读"><span class="toc-text">Futher reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimize-images-优化图片"><span class="toc-text">Optimize images 优化图片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-1"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimize-dependencies-优化依赖"><span class="toc-text">Optimize dependencies 优化依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting-为-ES-modles-开启模块连接"><span class="toc-text">Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Further-reading-扩展阅读-2"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals"><span class="toc-text">Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如果依赖是挂载到-window-上的情况"><span class="toc-text">如果依赖是挂载到 window 上的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果依赖是当做-AMD-包被加载的情况"><span class="toc-text">如果依赖是当做 AMD 包被加载的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-3"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summing-up-总结"><span class="toc-text">Summing up 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Make-use-of-long-term-caching-利用好长时缓存"><span class="toc-text">Make use of long-term caching 利用好长时缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息"><span class="toc-text">Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-4"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件"><span class="toc-text">Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dependencies-依赖"><span class="toc-text">Dependencies 依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Webpack-runtime-code-运行时代码"><span class="toc-text">Webpack runtime code 运行时代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-5"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求"><span class="toc-text">Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如果使用-HtmlWebpackPlugin-来生成-HTML"><span class="toc-text">如果使用 HtmlWebpackPlugin 来生成 HTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果使用自己的定制服务逻辑来生成-HTML"><span class="toc-text">如果使用自己的定制服务逻辑来生成 HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Webpack-4"><span class="toc-text">Webpack 4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Webpack-3"><span class="toc-text">Webpack 3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lazy-load-code-that-you-don’t-need-right-now-懒加载"><span class="toc-text">Lazy-load code that you don’t need right now 懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-6"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中"><span class="toc-text">Split the code into routes and pages 拆分代码到路由和页面中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#For-single-page-apps-对于单页面应用"><span class="toc-text">For single-page apps 对于单页面应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#For-traditional-multi-page-apps-对于传统的多页面应用"><span class="toc-text">For traditional multi-page apps 对于传统的多页面应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Further-reading-扩展阅读-7"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Make-module-ids-more-stable-使用稳定的-module-ids"><span class="toc-text">Make module ids more stable 使用稳定的 module ids</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Further-reading-扩展阅读-8"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summing-up"><span class="toc-text">Summing up</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor-and-analyze-the-app-监控并分析"><span class="toc-text">Monitor and analyze the app 监控并分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Keep-track-of-the-bundle-size-跟踪打包的体积"><span class="toc-text">Keep track of the bundle size 跟踪打包的体积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webpack-dashboard"><span class="toc-text">webpack-dashboard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bundlesize"><span class="toc-text">bundlesize</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Find-out-the-maximum-sizes-找出最大体积"><span class="toc-text">Find out the maximum sizes 找出最大体积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Enable-bundlesize-启用-bundlesize"><span class="toc-text">Enable bundlesize 启用 bundlesize</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Further-reading-扩展阅读-9"><span class="toc-text">Further reading 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大"><span class="toc-text">Analyze why the bundle is so large 分析 bundle 为什么这么大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summing-up-小结"><span class="toc-text">Summing up 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li>
<ul>
<li><a href="#instroduction-介绍">Instroduction 介绍</a></li>
<li><a href="#decrease-front-end-size-减少前端体积">Decrease Front-end Size 减少前端体积</a><ul>
<li><a href="#use-the-production-mode-webpack-4-only-使用生产模式仅用于-webpack-4">Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）</a></li>
<li><a href="#enable-minification-开启最小化">Enable minification 开启最小化</a></li>
<li><a href="#specify-node_envproduction-明确生产环境信息">Specify <code>NODE_ENV=production</code> 明确生产环境信息</a></li>
<li><a href="#use-es-modules-使用-es-模块">Use ES Modules 使用 ES 模块</a></li>
<li><a href="#optimize-images-优化图片">Optimize images 优化图片</a></li>
<li><a href="#optimize-dependencies-优化依赖">Optimize dependencies 优化依赖</a></li>
<li><a href="#enable-module-concatenation-for-es-modules-aka-scope-hoisting-为-es-modles-开启模块连接">Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接</a></li>
<li><a href="#use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals">Use <strong>externals</strong> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</a></li>
<li><a href="#summing-up-总结">Summing up 总结</a></li>
</ul>
</li>
<li><a href="#make-use-of-long-term-caching-利用好长时缓存">Make use of long-term caching 利用好长时缓存</a><ul>
<li><a href="#use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息">Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</a></li>
<li><a href="#extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件">Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件</a></li>
<li><a href="#inline-webpack-runtime-to-save-an-extra-http-request-内联-webpack-runtime-节省额外的-http-请求">Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求</a></li>
<li><a href="#lazy-load-code-that-you-dont-need-right-now-懒加载">Lazy-load code that you don’t need right now 懒加载</a></li>
<li><a href="#split-the-code-into-routes-and-pages-拆分代码到路由和页面中">Split the code into routes and pages 拆分代码到路由和页面中</a></li>
<li><a href="#make-module-ids-more-stable-使用稳定的-module-ids">Make module ids more stable 使用稳定的 module ids</a></li>
<li><a href="#summing-up">Summing up</a></li>
</ul>
</li>
<li><a href="#monitor-and-analyze-the-app-监控并分析">Monitor and analyze the app 监控并分析</a><ul>
<li><a href="#keep-track-of-the-bundle-size-跟踪打包的体积">Keep track of the bundle size 跟踪打包的体积</a></li>
<li><a href="#analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大">Analyze why the bundle is so large 分析 bundle 为什么这么大</a></li>
<li><a href="#summing-up-小结">Summing up 小结</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<!-- /TOC -->
<h2 id="Instroduction-介绍"><a href="#Instroduction-介绍" class="headerlink" title="Instroduction 介绍"></a>Instroduction 介绍</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a></p>
<p>现代 Web 应用经常用到 <code>bunding tool</code> 来创建生产环境的打包文件（例如脚本、样式等等），打包文件是需要<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization" target="_blank" rel="noopener">优化</a>并<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener">压缩最小化</a>，同时能够被用户更快地加载。在这篇文章中，我们将会利用 <a href="https://webpack.js.org/" target="_blank" rel="noopener"><code>webpack</code></a> 来贯穿说明如何进行高效地优化网站资源。这能帮助用户更快地加载你的应用同时获得更好的体验。</p>
<p><img src="https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png" alt="webpack-logo"></p>
<p>webpack 是当今最流行的打包工具之一，深入地利用它的特点去优化代码，将脚本<a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading" target="_blank" rel="noopener">拆分</a>成不同的部分，同时剔除无用代码将能够保证你的应用维持最小的带宽和进程消耗。</p>
<p><img src="https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png" alt="code-splitting"></p>
<blockquote>
<p>Note: 我们创建了一个练习的应用来演示下面这些优化的描述。尽力抽更多的时间来练习这些 tips <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener"><code>webpack-training-project</code></a></p>
</blockquote>
<p>让我们从现代 web 应用中最耗费资源之一的 <code>Javascript</code> 开始。</p>
<ul>
<li><a href="#Decrease Front-end Size 减少前端体积">减小前端体积</a></li>
<li><a href="#Make use of long-term caching 利用好长时缓存">利用长时缓存</a></li>
<li><a href="#Monitor and analyze the app 监控并分析">监控并分析应用</a></li>
<li><a href="#Conclusion">总结</a></li>
</ul>
<hr>
<h2 id="Decrease-Front-end-Size-减少前端体积"><a href="#Decrease-Front-end-Size-减少前端体积" class="headerlink" title="Decrease Front-end Size 减少前端体积"></a>Decrease Front-end Size 减少前端体积</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p>
<p>当你正在优化一个应用时，首要事情就是尽可能地将它体积的减小。下面我们就来看看通过 <code>webpack</code> 如何做到减小前端体积。</p>
<h3 id="Use-the-production-mode-webpack-4-only-使用生产模式（仅用于-webpack-4）"><a href="#Use-the-production-mode-webpack-4-only-使用生产模式（仅用于-webpack-4）" class="headerlink" title="Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）"></a>Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）</h3><p>Webpack 4 介绍了一种新的<a href="https://webpack.js.org/concepts/mode/" target="_blank" rel="noopener">模式</a>，你可以将其设置成 <code>development</code> 和 <code>production</code> 用于告诉 Webpack 你正在为不同的环境打包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你正在为你的应用用于生产环境编译打包时要确定开启了 <code>production</code> 模式。这样就帮助 webpack 开启类似压缩最小化代码、去除依赖库中开发环境代码等<a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">其他</a>的优化项。</p>
<h5 id="Further-reading-扩展阅读"><a href="#Further-reading-扩展阅读" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li><a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">What specific things the mode flag configures</a></li>
</ul>
<blockquote>
<p>Note: 笔者也翻译了另外一篇介绍新增 mode 的文章，感兴趣可以<a href="https://beanlee.github.io/2018/04/18/blog-translate-webpack-4-mode-and-optimization/">点击链接</a></p>
</blockquote>
<h3 id="Enable-minification-开启最小化"><a href="#Enable-minification-开启最小化" class="headerlink" title="Enable minification 开启最小化"></a>Enable minification 开启最小化</h3><blockquote>
<p>Note: 大部分只针对 webpack 3 如果你正在使用 webpack 4 生产模式打包，bundle 级别的最小化功能已经开启 - 你只需要配置<a href="#Loader-specific options 特定的 Loader 配置">对应 loader 选项</a>即可</p>
</blockquote>
<p>最小化就是通过去除多余空格、缩短变量名等方式压缩代码。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Original code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">const</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    result[index] = iteratee(array[index], index, array);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Minified code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">n,r</span>)</span>&#123;<span class="keyword">let</span> t=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="keyword">const</span> a=<span class="literal">null</span>==n?<span class="number">0</span>:n.length,l=<span class="built_in">Array</span>(a);++t&lt;a;)l[t]=r(n[t],t,n);<span class="keyword">return</span> l&#125;</span><br></pre></td></tr></table></figure>
<p>Webpack 支持两种方式最小化代码：<em>bundle-level</em> 最小化 和 <em>loader-specific options</em>。他们可以同时使用。</p>
<h4 id="Bundle-level-minification-bundle-级别的最小化"><a href="#Bundle-level-minification-bundle-级别的最小化" class="headerlink" title="Bundle-level minification bundle 级别的最小化"></a>Bundle-level minification bundle 级别的最小化</h4><p><code>Bundle-level</code> 最小化功能可以在编译完成后压缩整个 <code>bundle</code>。下面来看下它是如何工作的：</p>
<p>1.原始代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./comments.css'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Webpack 编译后的内容大概是下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"render"</span>] = render;</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =</span><br><span class="line">__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.最小化之后的代码大概是下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">e,n</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"Rendered!"</span>)&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(n,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;),n.render=t;<span class="keyword">var</span> o=r(<span class="number">1</span>);r.n(o)</span><br></pre></td></tr></table></figure>
<p>在 <strong>Webpack 4</strong> 中，bundle 级别的的最小化是自动开启的 - 同时在生产模式下、没有启用 bundle-level 都会开启。它是利用 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">UglifyJS</a> 引擎来进行最小化的。（如果你需要禁用最小化，仅仅设置开发模式或者设置 <code>optimization.minimize</code> 为 <code>false</code>。）</p>
<p>在 <strong>Webpack 3</strong> 中，你需要直接使用 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">UglifyJS</a> 插件。该插件是 webpack 提供的；开启并设置插件选项即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 webpack 3 中，UglifyJS 插件不能编译 ES2015+(ES6) 的代码，这就意味着你在代码中使用 <strong>classes</strong>, <strong>arrow function</strong> 或者其他新特性时，不能将他们编译成 ES5的代码，插件会抛错。<br>如果你需要编译这些新语法，就要用到 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> package，他也是在 webpack 中捆绑一起的，但是版本更新，并且可以编译 ES2015+ 的代码。</p>
</blockquote>
<h4 id="Loader-specific-options-特定的-Loader-配置"><a href="#Loader-specific-options-特定的-Loader-配置" class="headerlink" title="Loader-specific options 特定的 Loader 配置"></a>Loader-specific options 特定的 Loader 配置</h4><p>最小化代码的第二步就是利用特定的 <a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="noopener">loader</a> 配置。配置这些 loader，你可以压缩那些不能被最小化的部分。举个例子，当你使用 <code>css-loader</code> 引入一个 css 文件时，文件会被编译成一个字符串：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* comments.css */</span></span><br><span class="line"><span class="selector-class">.comment</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line">exports=<span class="built_in">module</span>.exports=__webpack_require__(<span class="number">1</span>)(),</span><br><span class="line">exports.push([<span class="built_in">module</span>.i,<span class="string">".comment &#123;\r\n  color: black;\r\n&#125;"</span>,<span class="string">""</span>]);</span><br></pre></td></tr></table></figure>
<p>这部分内容由于是字符串并没有被最小化。于是我们需要配置对应的 loader 选项来达到最小化的目的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">minimize</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h5><ul>
<li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">The UglifyJsPlugin docs</a> UglifyJs 插件文档</li>
<li>Other popular minifiers: <a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify</a>, <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler</a> 其他流行的最小化工具</li>
</ul>
<h3 id="Specify-NODE-ENV-production-明确生产环境信息"><a href="#Specify-NODE-ENV-production-明确生产环境信息" class="headerlink" title="Specify NODE_ENV=production 明确生产环境信息"></a>Specify <code>NODE_ENV=production</code> 明确生产环境信息</h3><blockquote>
<p>Note: 仅在 webpack 3 中生效，如果使用生产模式 webpack 4 打包，<strong>NODE_ENV=production</strong> 优化项已经开启，就可以直接跳过此小结</p>
</blockquote>
<p>减小前端体积的另外一个方法就是在代码中将 <code>NODE_ENV</code> <a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">环境变量</a>设置为 <code>production</code> 。</p>
<p>Libraries 会读取 <code>NODE_ENV</code> 变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当<code>NODE_ENV</code>没有设置成<code>production</code>，Vue.js 会做额外的检查并且输出一些警告：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure>
<p>React 也是类似 - 开发模式下 build 带有一些警告：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react/index.js</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.production.min.js'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.development.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react/cjs/react.development.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">warning$<span class="number">3</span>(</span><br><span class="line">  componentClass.getDefaultProps.isReactClassApproved,</span><br><span class="line">  <span class="string">'getDefaultProps is only used on classic React.createClass '</span> +</span><br><span class="line">  <span class="string">'definitions. Use a static property named `defaultProps` instead.'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure>
<p>这些检查和警告通常在生产环境下是不必要的，但是他们仍然保留在代码中并且会增加库的体积。</p>
<p>在 <strong>Webpack 4</strong> 中增加 <code>optimization.nodeEnv: &#39;production&#39;</code> 选项即可剔除掉它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    nodeEnv: <span class="string">'production'</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <strong>Webpack 3</strong> 中则使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="string">'"production"'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>optimization.nodeEnv: &#39;production&#39;</code> 选项和 <code>DefinePlugin</code> 插件采用相同的方式来解决这个问题 - 这个方式就是他们将 <code>process.env.NODE_ENV</code> 替换成特定的值，下面的配置可以说明：</p>
<p>1.Webpack 会将所有 <code>process.env.NODE_ENV</code> 替换成 <code>&quot;production&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.与此同时最小化工具会移除掉所有 <code>if</code> 的条件分支 - 由于 <code>&quot;production&quot; !== &#39;production&#39;</code> 永远会返回 <code>false</code>，这样分支内的代码就永远不会执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js (without minification)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Further-Reading-扩展阅读"><a href="#Further-Reading-扩展阅读" class="headerlink" title="Further Reading 扩展阅读"></a>Further Reading 扩展阅读</h5><ul>
<li><a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">What “environment variables” are</a> 解释什么是环境变量</li>
<li>Webpack docs about: <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a>, <a href="https://webpack.js.org/plugins/environment-plugin/" target="_blank" rel="noopener"><code>EnvironmentPlugin</code></a> Define 插件和 Environment 插件文档</li>
</ul>
<h3 id="Use-ES-Modules-使用-ES-模块"><a href="#Use-ES-Modules-使用-ES-模块" class="headerlink" title="Use ES Modules 使用 ES 模块"></a>Use ES Modules 使用 ES 模块</h3><p>下面这个方式利用 <a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">ES modules</a> 减小前端体积。</p>
<p>当你使用 ES module，webpack 有能力去做 <code>tree-shaking</code>。Tree-shaking 贯穿了整个依赖树，检查哪些依赖被使用，同时移除掉无用依赖。因此，如果你使用 ES module 方式的时候，webpack 帮你可以排除掉无用代码：</p>
<p>1.一个有多个 export 的文件，但是 app 只需要其中一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>
<p>2.Webpack 分析 <code>commentRestEndPoint</code> 没有被用到，就不会在一个 bundle 中生成单独的 export：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line">  <span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line">  <span class="comment">/* unused harmony export commentRestEndpoint */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3.<a href="Enable minification 开启最小化">最小化工具</a>就会移除掉无用变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">n,e</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="keyword">var</span> r=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"Rendered!"</span>&#125;;e.b=r&#125;)</span><br></pre></td></tr></table></figure>
<p>如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。</p>
<blockquote>
<p>Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；<code>UglifyJSPlugin</code>才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：<a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify plugin</a> or <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler plugin</a>）</p>
</blockquote>
<blockquote>
<p>Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel <code>babel-preset-env</code> or <code>babel-preset-es2015</code>，检查一下当前的配置。默认情况下， ES <code>import</code> and <code>export</code> to CommonJS <code>require</code> and <code>module.exports</code>。通过设置 option 来禁止掉<a href="https://github.com/babel/babel/tree/master/experimental/babel-preset-env" target="_blank" rel="noopener">Pass the <code>{ modules: false }</code> option</a>。</p>
</blockquote>
<h5 id="Futher-reading-扩展阅读"><a href="#Futher-reading-扩展阅读" class="headerlink" title="Futher reading 扩展阅读"></a>Futher reading 扩展阅读</h5><ul>
<li><a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">“ES6 Modules in depth”</a> 深入理解 ES6 Modules</li>
<li>Webpack docs <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">about tree shaking</a> Webpack tree shaking 文档</li>
</ul>
<h3 id="Optimize-images-优化图片"><a href="#Optimize-images-优化图片" class="headerlink" title="Optimize images 优化图片"></a>Optimize images 优化图片</h3><p>图片基本会占局页面<a href="https://httparchive.org/reports/state-of-the-web?start=latest" target="_blank" rel="noopener">一半以上</a>体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。可以利用 <code>url-loader</code>，<code>svg-url-loader</code> 和 <code>image-webpack-loader</code> 来进行优化。</p>
<p><code>url-loader</code> 允许将小的静态文件打包进 app。没有配置的话，他需要通过传递文件，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明 <code>limit</code> 选项，它将会编码成更小的文件 base64 url 并返回这个 url。这样将图片放在 Javascript 代码中，可以节省 HTTP 的请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> imageUrl <span class="keyword">from</span> <span class="string">'./image.png'</span>;</span><br><span class="line"><span class="comment">// → If image.png is smaller than 10 kB, `imageUrl` will include</span></span><br><span class="line"><span class="comment">// the encoded image: 'data:image/png;base64,iVBORw0KGg…'</span></span><br><span class="line"><span class="comment">// → If image.png is larger than 10 kB, the loader will create a new file,</span></span><br><span class="line"><span class="comment">// and `imageUrl` will include its url: `/2fcd56a1920be.png`</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 内联图片减少了独立请求的数量，这是很好的方式（<a href="https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/" target="_blank" rel="noopener">even with HTTP/2</a>），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。</p>
</blockquote>
<p><code>svg-url-loader</code>与<code>url-loader</code>类似 - 都是将使用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding" target="_blank" rel="noopener">URL encoding</a>  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">        loader: <span class="string">'svg-url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// Remove the quotes from the url</span></span><br><span class="line">          <span class="comment">// (they’re unnecessary in most cases)</span></span><br><span class="line">          noquotes: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，<a href="https://github.com/bhovhannes/svg-url-loader#iesafe" target="_blank" rel="noopener">设置 iesafe: true 选项</a></p>
</blockquote>
<p><code>image-webpack-loader</code>压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。</p>
<p>这个 loader 不会将图片嵌入在应用内，因此它必须与<code>url-loader</code>和<code>svg-url-loader</code>配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用<code>enforce: pre</code>作为单独的一个 rule 涵盖这个 loader：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">        <span class="comment">// This will apply the loader before the other ones</span></span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认 loader 设置就已经可以满足需求了 - 但如果你想要深入配置，请查看 <a href="https://github.com/tcoopman/image-webpack-loader#options" target="_blank" rel="noopener">the plugin options</a>。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a></p>
<h5 id="Further-reading-扩展阅读-1"><a href="#Further-reading-扩展阅读-1" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li><a href="https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for" target="_blank" rel="noopener">“What is base64 encoding used for?”</a> Base64 编码究竟可以用在何处？</li>
<li>Addy Osmani’s <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a> Addy Osmani 的图片优化指南</li>
</ul>
<h3 id="Optimize-dependencies-优化依赖"><a href="#Optimize-dependencies-优化依赖" class="headerlink" title="Optimize dependencies 优化依赖"></a>Optimize dependencies 优化依赖</h3><p>平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。</p>
<p>举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大约 65 KB 代码没有用处。</p>
<p>另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。</p>
<p>所有这些依赖都可以被轻易优化。我们在 Github repo 收集了优化的建议，<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="noopener">check it out</a>！</p>
<h3 id="Enable-module-concatenation-for-ES-modules-aka-scope-hoisting-为-ES-modles-开启模块连接"><a href="#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting-为-ES-modles-开启模块连接" class="headerlink" title="Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接"></a>Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接</h3><blockquote>
<p>Note: 如果你在使用生产模式下的 webpack 4，modules concatention 已经开启，可以直接跳过本小节。</p>
</blockquote>
<p>当你构建 bundle 时，webpack 将每一个 module 封装进 function 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part  of)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_0__comments_js__[<span class="string">"a"</span> <span class="comment">/* render */</span>])();</span><br><span class="line"></span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在以前，这么做是使 CommonJS/AMD modules 互相分离所必须的。但是，这会增加体积并且性能表现堪忧。</p>
<p>Webpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用<a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener"><code>ModuleConcatenationPlugin</code></a>完成这样一个 bundle，下面是例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike the previous snippet, this bundle has only one module</span></span><br><span class="line"><span class="comment">// which includes the code from both files</span></span><br><span class="line"><span class="comment">// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bundle.js (part of; compiled with ModuleConcatenationPlugin)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./comments.js</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./index.js</span></span><br><span class="line">  render();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 <code>ModuleConcatenationPlugin</code>，<code>require</code>被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！</p>
<p>在 <strong>Webpack 4</strong> 中开启这个功能，启用 <code>optimization.concatenateModules</code> 选项即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <strong>webpack 3</strong> 中，使用 <code>ModuleConcatenationPlugin</code> 插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， <a href="https://twitter.com/TheLarkInn/status/925800563144454144" target="_blank" rel="noopener">但是他会增加编译的时间同时破坏 module 的热更新</a>。这就是为什么只在生产环境中启用的原因了。</p>
</blockquote>
<h4 id="Further-reading-扩展阅读-2"><a href="#Further-reading-扩展阅读-2" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul>
<li>Webpack docs <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">for the ModuleConcatenationPlugin</a> ModuleConcatenationPlugin 文档</li>
<li><a href="https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f" target="_blank" rel="noopener">“Brief introduction to scope hoisting”</a></li>
<li>Detailed description of <a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="noopener">what this plugin does</a> 详述这些插件做了些什么</li>
</ul>
<h3 id="Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals"><a href="#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals" class="headerlink" title="Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals"></a>Use <strong>externals</strong> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</h3><p>你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：</p>
<p><img src="https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png" alt="video-hosting"></p>
<p>如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。<a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">the webpack’s <code>externals</code> option</a>就干了这件事 - 它用变量或者外部引用来替代 modules。</p>
<h4 id="如果依赖是挂载到-window-上的情况"><a href="#如果依赖是挂载到-window-上的情况" class="headerlink" title="如果依赖是挂载到 window 上的情况"></a>如果依赖是挂载到 window 上的情况</h4><p>如果你的非 webpack 代码依靠这些依赖，它们是挂载 window 上的变量，可以将依赖名称 alias 成变量名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: <span class="string">'React'</span>,</span><br><span class="line">    <span class="string">'react-dom'</span>: <span class="string">'ReactDOM'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用这个配置，webpack 将不会打包 <code>react</code> 和 <code>react-dom</code> 包。取而代之，他们会被替换成下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.React`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole React bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = React;</span><br><span class="line">&#125;),</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.ReactDOM`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole ReactDOM bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = ReactDOM;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="如果依赖是当做-AMD-包被加载的情况"><a href="#如果依赖是当做-AMD-包被加载的情况" class="headerlink" title="如果依赖是当做 AMD 包被加载的情况"></a>如果依赖是当做 AMD 包被加载的情况</h4><p>如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。</p>
<p>具体如何做呢？将 webpack 代码编译成一个 AMD module 同时别名成一个库的 URLs：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123; <span class="attr">libraryTarget</span>: <span class="string">'amd'</span> &#125;,</span><br><span class="line"></span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react.min.js'</span> &#125;,</span><br><span class="line">    <span class="string">'react-dom'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react-dom.min.js'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Webpack 将会把 bundle 包装进 <code>define()</code>同时让它依赖于这些URLs：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (beginning)</span></span><br><span class="line">define([<span class="string">"/libraries/react.min.js"</span>, <span class="string">"/libraries/react-dom.min.js"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; … &#125;);</span><br></pre></td></tr></table></figure>
<p>如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。</p>
<blockquote>
<p>Note：webpack 只是替换那些 <code>externals</code> 对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写<code>import React from &#39;react/umd/react.production.min.js&#39;</code>，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 <code>import &#39;react&#39;</code> 和 <code>import &#39;react/umd/react.production.min.js&#39;</code> 是同一个库，这样比较谨慎。</p>
</blockquote>
<h5 id="Further-reading-扩展阅读-3"><a href="#Further-reading-扩展阅读-3" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li>Webpack docs <a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">on <code>externals</code></a> externals 文档</li>
</ul>
<h3 id="Summing-up-总结"><a href="#Summing-up-总结" class="headerlink" title="Summing up 总结"></a>Summing up 总结</h3><ul>
<li>Enable the production mode if you use webpack 4 如果使用 webpack 4 开启生产模式</li>
<li>Minimize your code with the bundle-level minifier and loader options 使用 bundle 级别最小化 和 loader 选项来最小化你的代码</li>
<li>Remove the development-only code by replacing <code>NODE_ENV</code> with <code>production</code> 通过将 <code>NODE_ENV</code> 替换成 <code>production</code> 来移除开发期间代码</li>
<li>Use ES modules to enable tree shaking 启用 tree shaking</li>
<li>Compress images 压缩图片</li>
<li>Apply dependency-specific optimizations 开启依赖优化</li>
<li>Enable module concatenation 开启 module 连接</li>
<li>Use <code>externals</code> if this makes sense for you 如果有效果的话可以使用 <code>externals</code></li>
</ul>
<hr>
<h2 id="Make-use-of-long-term-caching-利用好长时缓存"><a href="#Make-use-of-long-term-caching-利用好长时缓存" class="headerlink" title="Make use of long-term caching 利用好长时缓存"></a>Make use of long-term caching 利用好长时缓存</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p>
<p>在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分，这样会在每一次请求中减少重新下载的次数。</p>
<h3 id="Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息"><a href="#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息" class="headerlink" title="Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息"></a>Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</h3><p>做缓存通用的解决办法：</p>
<p>1.告诉浏览器缓存一个文件很长时间（比如一年）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Server header</span><br><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>
<p>Note：如果你不熟悉 <code>Cache-Control</code> 做了什么，你可以看一下 Jake Archibald 的精彩博文 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">on caching best practices</a></p>
<p>2.当文件改变需要强制重新下载时去重命名这些文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Before the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v15.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- After the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v16.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些方法可以告诉浏览器下载这些 JS 文件，将其缓存起来。浏览器将只会在文件名发生改变时才会请求网络（或者缓存失效的情况也会请求）。</p>
<p>使用 webpack，也可以做同样的事，但可以使用版本号来解决，需要明确这个文件的 hash 值。使用 <a href="https://webpack.js.org/configuration/output/#output-filename" target="_blank" rel="noopener"><code>[chunkhash]</code></a> 可以将 <code>hash</code> 值包含进文件名中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">        <span class="comment">// → bundle.8e0d62a03.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: webpack 可能会生成不同的 hash 即使 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 <a href="https://github.com/webpack/webpack/issues/1479" target="_blank" rel="noopener">This is a bug.</a><br>如果你需要将文件名发送给客户端，也可以使用 <code>HtmlWebpackPlugin</code> 或者 <code>WebpackManifestPlugin</code>。</p>
</blockquote>
<p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 使用起来很简单，但灵活性有一些欠缺。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.8e0d62a03.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>WebpackManifestPlugin</code> 更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundle.js"</span>: <span class="string">"bundle.8e0d62a03.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Further-reading-扩展阅读-4"><a href="#Further-reading-扩展阅读-4" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li>Jake Archibald <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">about caching best practices</a> cache 的最佳实践</li>
</ul>
<h3 id="Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件"><a href="#Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件" class="headerlink" title="Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件"></a>Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件</h3><h4 id="Dependencies-依赖"><a href="#Dependencies-依赖" class="headerlink" title="Dependencies 依赖"></a>Dependencies 依赖</h4><p>App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。</p>
<blockquote>
<p>Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 <code>chunks</code>。我们后面会用到这个名词。</p>
</blockquote>
<p>为了将依赖包提取到单独的 chunk 中，下面分为三步：</p>
<p>1.使用 <code>[name].[chunkname].js</code> 替换<code>output</code>的文件名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// Before</span></span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">    <span class="comment">// After</span></span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换 <code>[name]</code>。如果没有添加 <code>[name]</code> 部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太困难了！</p>
<p>2.将 <code>entry</code> 转成一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// Before</span></span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  <span class="comment">// After</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 <code>[name]</code>代替。</p>
<p>目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。</p>
<p>3.在 <strong>Webpack 4</strong> 中，在配置中增加 <code>optimization.splitChunks.chunks: &#39;all&#39;</code> 即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个选项会开启智能代码拆分。使用这个功能，webpack 将最小化和 Gzip 前大于 30KB 的代码提取出额外的 <code>vendor</code> 代码。它同时也会提取出 common 代码 - 这些代码在打包多个 bundles 会起到作用。（例如：<a href="#Split the code into routes and pages 拆分代码到路由和页面中">通过路由拆分应用</a>）。</p>
<p>在 <strong>Webpack 3</strong> 中，使用 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a> 插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the dependencies.</span></span><br><span class="line">      <span class="comment">// This name is substituted in place of [name] from step 1</span></span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A function that determines which modules to include into this chunk</span></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插件将包括全部 <code>node_modules</code> 路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 <code>vendor.[chunkhash].js</code>。</p>
<p>完成了上面的步骤，每一次 build 都会生成两个文件。浏览器会将他们单独缓存 - 以便代码发生改变时重新下载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>
<h4 id="Webpack-runtime-code-运行时代码"><a href="#Webpack-runtime-code-运行时代码" class="headerlink" title="Webpack runtime code 运行时代码"></a>Webpack runtime code 运行时代码</h4><p>不幸的是，仅仅抽取 <code>vendor</code> 是不够的。如果你试图在应用代码中修改一些东西：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. add this:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Wat'</span>);</span><br></pre></td></tr></table></figure>
<p>你会注意到 <code>vendor</code> 的也会改变：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                            Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure>
<p>这因为 webpack 打包时，一部分 modules 的代码，拥有 <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener"><em>a runtime</em></a> - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor.e6ea4504d61a1cc1c60b.js</span></span><br><span class="line">script.src = __webpack_require__.p + chunkId + <span class="string">"."</span> + &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"2f2269c7f0a55a5c1871"</span></span><br><span class="line">&#125;[chunkId] + <span class="string">".js"</span>;</span><br></pre></td></tr></table></figure>
<p>Webpack 将最新生成的 chunk 包含在这个 runtime 内，这个 chunk 就是我们代码中的 <code>vendor</code>。与此同时每一次任何 <code>chunk</code> 的修改，即使这一小部分代码也改变，也会导致整个 <code>vendor</code> <code>chunk</code> 改变。</p>
<p>为了解决这个问题，我们将 runtime 转义到一个独立的文件中，在 <strong>Webpack 4</strong> 中，开启 <code>optimization.runtimeChunk</code> 选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <strong>Webpack 3</strong>中，通过 <code>CommonsChunkPlugin</code> 创建一个额外的空的 chunk：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This plugin must come after the vendor one (because webpack</span></span><br><span class="line">    <span class="comment">// includes runtime into the last chunk)</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// minChunks: Infinity means that no app modules</span></span><br><span class="line">      <span class="comment">// will be included into this chunk</span></span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成这一部分改变，每一次 build 都将生成三个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>
<p>将他们反过来顺序添加到 index.html 中，你就搞定了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vendor.26886caf15818fa82dfa.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.00bab6fd3100008a42b0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Further-reading-扩展阅读-5"><a href="#Further-reading-扩展阅读-5" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li>Webpack guide <a href="https://webpack.js.org/guides/caching/" target="_blank" rel="noopener">on long term caching</a> webpack 关于 cache 指南</li>
<li>Webpack docs <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener">about webpack runtime and manifest</a> webpack 关于 runtime and manifest 文档</li>
<li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a> 使用 CommonsChunkPlugin 的最佳实践</li>
</ul>
<h3 id="Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求"><a href="#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求" class="headerlink" title="Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求"></a>Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求</h3><p>为了做的更好，我们可以尽力把 webpack runtime 内联在 HTML 请求里。下面举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样做：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">if</span>(t[r])<span class="keyword">return</span> t[r].exports;…&#125;&#125; ([]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。</p>
<p>下面就来看看如何做。</p>
<h4 id="如果使用-HtmlWebpackPlugin-来生成-HTML"><a href="#如果使用-HtmlWebpackPlugin-来生成-HTML" class="headerlink" title="如果使用 HtmlWebpackPlugin 来生成 HTML"></a>如果使用 HtmlWebpackPlugin 来生成 HTML</h4><p>如果使用 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 来生成 HTML 文件，<a href="https://github.com/rohitlodha/html-webpack-inline-chunk-plugin" target="_blank" rel="noopener"><code>InlineChunkWebpackPlugin</code></a> 就足够了。</p>
<h4 id="如果使用自己的定制服务逻辑来生成-HTML"><a href="#如果使用自己的定制服务逻辑来生成-HTML" class="headerlink" title="如果使用自己的定制服务逻辑来生成 HTML"></a>如果使用自己的定制服务逻辑来生成 HTML</h4><h5 id="Webpack-4"><a href="#Webpack-4" class="headerlink" title="Webpack 4"></a><strong>Webpack 4</strong></h5><p>1.增加 <a href="https://github.com/danethurber/webpack-manifest-plugin" target="_blank" rel="noopener">WebpackManifestPlugin</a> 插件已知运行时 chunk:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="keyword">const</span> ManifestPlugin = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ManifestPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>插件就会生成一个下面这样的文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"runtime~main.js"</span>: <span class="string">"runtime~main.8e0d62a03.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.将这些内容嵌入到 runtime chunk 中。例如：使用 Node.js 和 Express：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> manifest = <span class="built_in">require</span>(<span class="string">'./manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runtimeContent = fs.readFileSync(manifest[<span class="string">'runtime~main.js'</span>], <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="Webpack-3"><a href="#Webpack-3" class="headerlink" title="Webpack 3"></a><strong>Webpack 3</strong></h5><p>1.将 <code>runtime</code> 名称改成静态的明确的文件名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">      filename: <span class="string">'runtime.js'</span>,</span><br><span class="line">        <span class="comment">// → Now the runtime file will be called</span></span><br><span class="line">        <span class="comment">// “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.嵌入到 runtime.js 内容。比如：Node.js 和 Express</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> runtimeContent = fs.readFileSync(<span class="string">'./runtime.js'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Lazy-load-code-that-you-don’t-need-right-now-懒加载"><a href="#Lazy-load-code-that-you-don’t-need-right-now-懒加载" class="headerlink" title="Lazy-load code that you don’t need right now 懒加载"></a>Lazy-load code that you don’t need right now 懒加载</h3><p>通常情况下，一个页面有或多或少的重要部分：</p>
<ul>
<li>如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。</li>
<li>如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。</li>
</ul>
<p>在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">the <code>import()</code> function</a> 和 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code-splitting</a> 解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// videoPlayer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderVideoPlayer</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderComments</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderVideoPlayer&#125; <span class="keyword">from</span> <span class="string">'./videoPlayer'</span>;</span><br><span class="line">renderVideoPlayer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// …Custom event listener</span></span><br><span class="line">onShowCommentsClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./comments'</span>).then(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">    comments.renderComments();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>import()</code>明确表示你期望动态地加载独立的 module。当 webpack 看到 <code>import(&#39;./module.js&#39;)</code>时，他就会将这个 module 移到独立的 chunk 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 39b2a53cb4e73f0dc5b2</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>
<p>并且只在代码执行到 <code>import()</code> 才会下载。</p>
<p>这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。</p>
<blockquote>
<p>Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 <em>import()</em> 而遇到语法错误抛出来。可以使用 <a href="https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener"><code>syntax-dynamic-import</code></a> 解决这个错误。</p>
</blockquote>
<h5 id="Further-reading-扩展阅读-6"><a href="#Further-reading-扩展阅读-6" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li>Webpack docs <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">for the <code>import()</code> function</a>  webpack 中 import() 文档</li>
<li>The JavaScript proposal <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">for implementing the <code>import()</code> syntax</a></li>
</ul>
<h3 id="Split-the-code-into-routes-and-pages-拆分代码到路由和页面中"><a href="#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中" class="headerlink" title="Split the code into routes and pages 拆分代码到路由和页面中"></a>Split the code into routes and pages 拆分代码到路由和页面中</h3><p>如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：</p>
<p><img src="https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png" alt="site-home-page"></p>
<p>他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。</p>
<p>如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会只下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。</p>
<h4 id="For-single-page-apps-对于单页面应用"><a href="#For-single-page-apps-对于单页面应用" class="headerlink" title="For single-page apps 对于单页面应用"></a>For single-page apps 对于单页面应用</h4><p>通过路由拆分带页面引用，使用 <code>import()</code>（看看 <a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading" target="_blank" rel="noopener">“Lazy-load code that you don’t need right now”</a>这部分）。如果你在使用一个框架，现在已经有成熟的方案：</p>
<ul>
<li><a href="https://reacttraining.com/react-router/web/guides/code-splitting" target="_blank" rel="noopener">“Code Splitting”</a> in <code>react-router</code>‘s docs (for React)</li>
<li><a href="https://router.vuejs.org/en/advanced/lazy-loading.html" target="_blank" rel="noopener">“Lazy Loading Routes”</a> in <code>vue-router</code>‘s docs (for Vue.js)</li>
</ul>
<h4 id="For-traditional-multi-page-apps-对于传统的多页面应用"><a href="#For-traditional-multi-page-apps-对于传统的多页面应用" class="headerlink" title="For traditional multi-page apps 对于传统的多页面应用"></a>For traditional multi-page apps 对于传统的多页面应用</h4><p>通过页面拆分传统多页面应用，可以使用 webpack 的 <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener"><em>entry points</em></a> 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/Home/index.js'</span>,</span><br><span class="line">    article: <span class="string">'./src/Article/index.js'</span>,</span><br><span class="line">    profile: <span class="string">'./src/Profile/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 318d7b8490a7382bf23b</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home</span><br><span class="line">./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article</span><br><span class="line">./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor</span><br><span class="line">./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime</span><br></pre></td></tr></table></figure>
<p>因此，如果仅仅是文章页使用 <em>Lodash</em> ，<em>home</em> 和 <em>profile</em> 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。</p>
<p>拆分依赖树也有缺点。如果两个 entry points 都用到了 <em>loadash</em> ，同时你没有在 <em>vendor</em> 移除掉依赖，两个 entry points 将包括两个重复的 <em>lodash</em> 。在 <strong>Webpack 4</strong> 中我们可以设置 <code>optimization.splitChunks.chunks: &#39;all&#39;</code> 解决该问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个选项可以开启智能拆分代码，webpack 将自动寻找 common code 并将其提取到一个单独的文件中。</p>
<p>在 <strong>Webpack 3</strong> 可以使用<a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a>来解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the common dependencies</span></span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The plugin will move a module into a common file</span></span><br><span class="line">      <span class="comment">// only if it’s included into `minChunks` chunks</span></span><br><span class="line">      <span class="comment">// (Note that the plugin analyzes all chunks, not only entries)</span></span><br><span class="line">      minChunks: <span class="number">2</span>,    <span class="comment">// 2 is the default value</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>随意使用<code>minChunks</code>的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，<code>minChunks</code> 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。</p>
<h4 id="Further-reading-扩展阅读-7"><a href="#Further-reading-扩展阅读-7" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul>
<li>Webpack docs <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">about the concept of entry points</a> webpack 关于入口概念的文档</li>
<li>Webpack docs <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">about the CommonsChunkPlugin</a> webpack 关于 CommonChunkPlugin 插件的文档</li>
<li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a></li>
</ul>
<h3 id="Make-module-ids-more-stable-使用稳定的-module-ids"><a href="#Make-module-ids-more-stable-使用稳定的-module-ids" class="headerlink" title="Make module ids more stable 使用稳定的 module ids"></a>Make module ids more stable 使用稳定的 module ids</h3><p>当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被 <code>require()</code> 引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[4] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[5] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line"> + 1 hidden module</span><br></pre></td></tr></table></figure>
<p>默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]</span><br><span class="line">   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br><span class="line">   [0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br></pre></td></tr></table></figure>
<p>↓ 我们增加一个新 module</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br></pre></td></tr></table></figure>
<p>↓ 现在看这里做了什么！ <code>comments.js</code> 现在的 ID 由 4 变成了 5</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5] ./comments.js 58 kB &#123;0&#125; [built]</span><br></pre></td></tr></table></figure>
<p>↓ <code>ads.js</code> 的 ID 由 5 变成 6</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[6] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">       + 1 hidden module</span><br></pre></td></tr></table></figure>
<p>这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_ 这个 chunk 和 <em>main</em> chunk 都会失效 - 只有 <em>main</em> 才应该失效。</p>
<p>使用<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener"><code>HashedModuleIdsPlugin</code></a>插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure>
<p>↓</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[3IRH] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br><span class="line">[lebJ] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[02Tr] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">    + 1 hidden module</span><br></pre></td></tr></table></figure>
<p>有了这个方法，只有你重命名或者删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。</p>
<p>启用这个插件，在配置中增加 <em>plugins</em>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="Further-reading-扩展阅读-8"><a href="#Further-reading-扩展阅读-8" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul>
<li>Webpack docs <a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener">about the HashedModuleIdsPlugin</a> HashModuleIdsPlugin 插件文档</li>
</ul>
<h3 id="Summing-up"><a href="#Summing-up" class="headerlink" title="Summing up"></a>Summing up</h3><ul>
<li>Cache the bundle and differentiate between versions by changing the bundle name 缓存 bundle 包并通过修改 bundle 名称来做版本差异</li>
<li>Split the bundle into app code, vendor code and runtime 将 bundle 拆分成 app 业务代码、vendor 代码、runtime 代码</li>
<li>Inline the runtime to save an HTTP request 将 runtime 代码内联节省 HTTP 请求</li>
<li>Lazy-load non-critical code with <code>import</code> 通过 import 懒加载非必要代码</li>
<li>Split code by routes/pages to avoid loading unnecessary stuff 通过路由或页面拆分阻止加载不必要代码</li>
</ul>
<hr>
<h2 id="Monitor-and-analyze-the-app-监控并分析"><a href="#Monitor-and-analyze-the-app-监控并分析" class="headerlink" title="Monitor and analyze the app 监控并分析"></a>Monitor and analyze the app 监控并分析</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p>
<p>即使当你配置好你的 webpack 让你的应用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！</p>
<p>这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。</p>
<h3 id="Keep-track-of-the-bundle-size-跟踪打包的体积"><a href="#Keep-track-of-the-bundle-size-跟踪打包的体积" class="headerlink" title="Keep track of the bundle size 跟踪打包的体积"></a>Keep track of the bundle size 跟踪打包的体积</h3><p>在开发时可以使用<a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>和命令行<a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 来监控 app 的体积。</p>
<h4 id="webpack-dashboard"><a href="#webpack-dashboard" class="headerlink" title="webpack-dashboard"></a>webpack-dashboard</h4><p><a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。</p>
<p><img src="http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png" alt="webpack-dashboard"></p>
<p>这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！</p>
<p>启用这个功能，需要安装 <em>webpack-dashboard</em> 包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dashboard --save-dev</span><br></pre></td></tr></table></figure>
<p>同时在配置的 plugins 增加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> DashboardPlugin = <span class="built_in">require</span>(<span class="string">'webpack-dashboard/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DashboardPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者如果正在使用基于 Express dev server 可以使用 <code>compiler.apply()</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.apply(new DashboardPlugin());</span><br></pre></td></tr></table></figure>
<p>多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。</p>
<h4 id="bundlesize"><a href="#bundlesize" class="headerlink" title="bundlesize"></a>bundlesize</h4><p><a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：</p>
<p><img src="https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg" alt="bundlesize"></p>
<p>配置如下：</p>
<h5 id="Find-out-the-maximum-sizes-找出最大体积"><a href="#Find-out-the-maximum-sizes-找出最大体积" class="headerlink" title="Find out the maximum sizes 找出最大体积"></a><strong>Find out the maximum sizes</strong> 找出最大体积</h5><p>1.分析 app 尽可能减小体积，执行生产环境的 build。<br>2.在<code>package.json</code>中增加<code>bundlesize</code>部分：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用<code>npx</code>执行<code>bundlesize</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx bundlesize</span><br></pre></td></tr></table></figure>
<p>它就会将每一个文件的 gzip 压缩后的体积打印出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB</span><br></pre></td></tr></table></figure>
<p>4.每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。</p>
<h5 id="Enable-bundlesize-启用-bundlesize"><a href="#Enable-bundlesize-启用-bundlesize" class="headerlink" title="Enable bundlesize 启用 bundlesize"></a><strong>Enable <code>bundlesize</code></strong> 启用 bundlesize</h5><p>5.安装<em>bundlesize</em>开发依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bundlesize --save-dev</span><br></pre></td></tr></table></figure>
<p>6.在<code>package.json</code>中的<code>bundlesize</code>部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*.png"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"16 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/main.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"20 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/vendor.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"35 kB"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.增加一个 npm 脚本来执行检查：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"check-size"</span>: <span class="string">"bundlesize"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.配置自动化 CI 来在每一次 push 时执行<code>npm run check-size</code>做检查。（如果你在 Github 上开发项目，直接可以使用<a href="https://github.com/siddharthkp/bundlesize#2-build-status" target="_blank" rel="noopener">integrate <code>bundlesize</code> with GitHub</a>。）</p>
<p>这就全部了！现在如果你运行<code>npm run check-size</code>或者 push 代码，你就会看到输出的文件是否足够小：</p>
<p><img src="https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png" alt="bundlesize-output-success"></p>
<p>或者下面失败的情况</p>
<p><img src="https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png" alt="bundlesize-output-failure"></p>
<h4 id="Further-reading-扩展阅读-9"><a href="#Further-reading-扩展阅读-9" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul>
<li>Alex Russell <a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">about the real-world loading time we should target</a></li>
</ul>
<h3 id="Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大"><a href="#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大" class="headerlink" title="Analyze why the bundle is so large 分析 bundle 为什么这么大"></a>Analyze why the bundle is so large 分析 bundle 为什么这么大</h3><p>你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a></p>
<blockquote>
<p>译者注：此处有<a href="https://developers.google.com/web/fundamentals/performance/webpack/webpack-bundle-analyzer.mp4" target="_blank" rel="noopener">视频</a>，需要科学上网，请自行观看</p>
</blockquote>
<p>(Screen recording from <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">github.com/webpack-contrib/webpack -bundle-analyzer</a>)</p>
<p>webpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。</p>
<p>使用这个分析器，需要安装<code>webpack-bundle-analyzer</code>包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure>
<p>在 config 中增加插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行生产环境的 build 这个插件就会在浏览器中打开一个显示状态的页面。</p>
<p>默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。</p>
<blockquote>
<p>Note: 如果你使用 <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">ModuleConcatenationPlugin</a>，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。</p>
</blockquote>
<p>下面是报告中需要看什么：</p>
<ul>
<li><strong>Large dependencies 大型依赖</strong> 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 <a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment" target="_blank" rel="noopener">that are often not used and could be dropped</a>）？</li>
<li><strong>Duplicated dependencies 重复依赖</strong> 是否在不同文件中看到过相同的库？（在 <strong>Webpack 4</strong> 中配置 <code>optimization.splitChunks.chunks</code>，或者在 <strong>Webpack 3</strong>中 使用 <em>CommonsChunkPlugin</em> 将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？</li>
<li><strong>Similar dependencies 相似依赖</strong> 是否存在有相似功能的相似库存在？（比如<em>moment</em>和<em>date-fns</em> 或者 <em>lodash</em> 和 <em>lodash-es</em>）尽力汇总成一个。</li>
</ul>
<p>同样的，也可以看看 Sean Larkin 的文章 <a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">great analysis of webpack bundles</a>。</p>
<h3 id="Summing-up-小结"><a href="#Summing-up-小结" class="headerlink" title="Summing up 小结"></a>Summing up 小结</h3><ul>
<li>Use <code>webpack-dashboard</code> and <code>bundlesize</code> to stay tuned of how large your app is</li>
<li>Dig into what builds up the size with <code>webpack-bundle-analyzer</code></li>
</ul>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总结：</p>
<ul>
<li><strong>剔除不必要的体积</strong> 把所有的代码都压缩最小化，剔除无用代码，增加依赖时保持谨慎小心。</li>
<li><strong>通过路由拆分代码</strong> 只在真正需要的时候才加载，其余部分做懒加载。</li>
<li><strong>缓存代码</strong> 应用程序某些部分代码更新频率低于其他部分代码，可以将这些部分拆分成文件，以便在必要时仅重新下载。</li>
<li><strong>跟踪体积大小</strong> 使用  <a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a> 和 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> 监控你的 app。每隔几个月重新检查一下你的应用的性能。</li>
</ul>
<p>Webpack 不仅仅是一个帮助你更快创建 app 的工具。它还帮助使你的 app 成为 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">a Progressive Web App</a> ，你的应用拥有更好的体验以及自动化的填充工具就像<a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="noopener">Lighthouse</a>根据环境给出建议。</p>
<p>不要忘记阅读 <a href="https://webpack.js.org/guides/" target="_blank" rel="noopener">webpack docs</a> - 里面提供了大量的优化相关的信息。</p>
<p>多多练习 <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener">with the training app</a>！</p>

            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div style="text-align: center;">
  <p>如果你觉得这篇文章对你有所帮助，可以微信扫码请作者吃个甜甜圈哦~</p>
  <img src="https://beanlee.github.io/img/wechat_donate.JPG" width="300" height="300" alt>
</div>
        
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Webpack/">Webpack</a> <a class="tag tag--primary tag--small t-link" href="/tags/翻译/">翻译</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/something-about-webpack-4/" data-tooltip="Webpack 4 实战 React 和 Vue 项目" aria-label="上一篇: Webpack 4 实战 React 和 Vue 项目">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/blog-translate-webpack-4-mode-and-optimization/" data-tooltip="【译】Webpack 4 mode and optimization" aria-label="下一篇: 【译】Webpack 4 mode and optimization">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Bean Lee. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/something-about-webpack-4/" data-tooltip="Webpack 4 实战 React 和 Vue 项目" aria-label="上一篇: Webpack 4 实战 React 和 Vue 项目">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/posts/blog-translate-webpack-4-mode-and-optimization/" data-tooltip="【译】Webpack 4 mode and optimization" aria-label="下一篇: 【译】Webpack 4 mode and optimization">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/" title="分享到 Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/" title="分享到 Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>分享到 Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/3fe40c6cac2cee1d563a87ada4d02cc5?s=110" alt="作者的图片">
        
            <h4 id="about-card-name">Bean Lee</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                Beijing
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://img11.360buyimg.com/imagetools/jfs/t29587/1/1553336624/17034/4000fd99/5ce4bf63N116f7972.png">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search" class="form-control input--large search-input" placeholder="Search ">
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/First-Blog/">
                            <h3 class="media-heading">开篇</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年11月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Finished-the-book/">
                            <h3 class="media-heading">英雄再见</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年12月4日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><h1 id="《獵命師傳奇》最终章完结"><a href="#《獵命師傳奇》最终章完结" class="headerlink" title="《獵命師傳奇》最终章完结"></a>《獵命師傳奇》最终章完结</h1><p>断断续续地在地铁上读完了这本九把刀的长篇《獵命師傳奇》，说来初识九把刀还是在看过《那些年，我们一起追的女孩儿》这部电影来的，当时只是觉得这些年台湾电影成长的很快，这位有趣自大的导演第一部电影长篇就拍的如此热血，导演本人也一定非常有趣，带着疑问和好奇，我开始在网上查阅九把刀。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Eassy-Programmer/">
                            <h3 class="media-heading">程序员都是理想主义者</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2013年12月5日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/The-Summary-of-At/">
                            <h3 class="media-heading">微博等SNS@功能探索技术验证总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年1月10日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Read-The-Book-Of-Zhihu/">
                            <h3 class="media-heading">书摘随笔</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年3月20日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>读《创业时，我们在知乎聊什么》书摘随笔一</p>
<blockquote>
<p>最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。</p>
</blockquote></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Misfit-Shine/">
                            <h3 class="media-heading">有设计感的数码产品才能打动人心</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年4月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Java-Collection-Review/">
                            <h3 class="media-heading">Java基础集合类复习</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年6月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Java基础集合类的问题简单整理</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Study-Swift-1/">
                            <h3 class="media-heading">Swift Study 1</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年6月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/Mac-Tool-Series-1/">
                            <h3 class="media-heading">Mac Tool</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年6月19日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。<br>Dash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://beanlee.github.io/posts/How-To-Connect-Internet-With-VPN/">
                            <h3 class="media-heading">科学上网之VPN推荐系列</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2014年6月28日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium" data-message-zero="没有找到文章" data-message-one="找到 1 篇文章" data-message-other="找到 {n} 篇文章">
                找到 29 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://img10.360buyimg.com/uba/jfs/t19666/213/522537036/248594/9d238021/5a936b81Nf7ab67ea.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-snykejswjcxqfzqhk8erauq9xu9tds7bleedq61lkpgsla0zkuddqzjkbdhm.min.js"></script>
<!--SCRIPTS END-->

    
        <script>
             var disqus_config = function () {
                 this.page.url = 'https://beanlee.github.io/posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/';
                 
                    this.page.identifier = 'posts/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/';
                 
             };
            (function() {
                var d = document, s = d.createElement('script');
                var disqus_shortname = 'beanleeblog';
                s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
    


    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('X2N6X5DWEF', '8bc642e4dde7df5b407196d03ca96747');
        var algoliaIndex = algoliaClient.initIndex('blog_index');
    </script>


<!-- Hotjar Tracking Code for https://beanlee.github.io -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:1333288,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>

    </body>
</html>
