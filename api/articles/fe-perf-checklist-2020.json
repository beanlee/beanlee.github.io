{"title":"【译】前端性能优化检查表 2020","slug":"fe-perf-checklist-2020","date":"2021-01-11T07:17:46.000Z","updated":"2021-01-12T07:51:56.389Z","comments":true,"path":"api/articles/fe-perf-checklist-2020.json","excerpt":"原文地址 https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages简单对一篇完整的检查表目录做一个翻译，极力推荐阅读原文，文中也提到了大量的有关性能优化策略和方法的关键字和链接，方便查询。","covers":null,"content":"<p>原文地址 <a href=\"https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages\" target=\"_blank\" rel=\"noopener\">https://www.smashingmagazine.com/2020/01/front-end-performance-checklist-2020-pdf-pages</a></p>\n<p>简单对一篇完整的检查表目录做一个翻译，极力推荐阅读原文，文中也提到了大量的有关性能优化策略和方法的关键字和链接，方便查询。</p>\n<a id=\"more\"></a>\n<h3 id=\"准备计划和指标\"><a href=\"#准备计划和指标\" class=\"headerlink\" title=\"准备计划和指标\"></a>准备计划和指标</h3><ul>\n<li>建立性能文化氛围（让更多人意识到性能的重要性）</li>\n<li>目标：比最快的竞争对手至少快 20%</li>\n<li>选择正确的指标（选择正确的指标，不是所有指标都重要）</li>\n<li>在能代表大多数用户群体的设备上收集数据（保证准确地数据收集）</li>\n<li>为测试环境准备“干净的”和“符合真实用户的”相关的配置</li>\n<li>与身边人分享性能指标（确保团队每个人都认可）</li>\n</ul>\n<h3 id=\"设定实际目标\"><a href=\"#设定实际目标\" class=\"headerlink\" title=\"设定实际目标\"></a>设定实际目标</h3><ul>\n<li>响应时间在 100ms，60fps</li>\n<li>3G 网络下的 FID&lt;100ms，TTI&lt;5​​s，速度索引&lt;3s，关键文件大小预算&lt;170KB（已压缩）</li>\n</ul>\n<h3 id=\"定义环境\"><a href=\"#定义环境\" class=\"headerlink\" title=\"定义环境\"></a>定义环境</h3><ul>\n<li>选择并配置好项目中的构建工具</li>\n<li>默认使用渐进增强</li>\n<li>选择良好的性能基准</li>\n<li>仔细评估框架和依赖（不是每个项目或者页面都需要笨重的框架和大量的依赖库）</li>\n<li>考虑使用 PRPL 模式和应用程序外壳体系的结构</li>\n<li>检查 API 是否存在优化空间（比如 GraghQL）</li>\n<li>框架选择，Google AMP 还是 Facebook 的 Instant Articles？</li>\n<li>合理运用 CDN</li>\n</ul>\n<h3 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h3><ul>\n<li>利用 Brotli 进行纯文本压缩（你可能总听到 gzip，brotli 是 2015 年 Google 提出的无损压缩的格式）</li>\n<li>使用响应式图片以及 webp</li>\n<li>图片是否可以再进一步优化？</li>\n<li>视频是否可以进行适当优化？</li>\n<li>网络字体是否经过优化？（适当删除和裁切可以减小加载体积）</li>\n</ul>\n<h3 id=\"构建优化\"><a href=\"#构建优化\" class=\"headerlink\" title=\"构建优化\"></a>构建优化</h3><ul>\n<li>设置优先事项</li>\n<li>在生产环境中使用原生 JavaScript 模块</li>\n<li>合理使用 tree-shaking, scope hoisting, code-splitting</li>\n<li>考虑将一些复杂繁重的 js 放在 Web Worker （预加载数据以及 PWA）</li>\n<li>考虑将一些复杂的计算逻辑放在 WebAssembly 中</li>\n<li>是否正在使用提前编译器？</li>\n<li>对于旧版浏览器仅提供旧版代码</li>\n<li>对于 JavaScript 使用模块还是非模块模式？</li>\n<li>通过增量解耦识别并重写旧代码</li>\n<li>识别并且删除没有用到的代码（代码覆盖率，Chrome 工具）</li>\n<li>缩减 JavaScript Bundle 大小</li>\n<li>对于 JavaScript Chunks 是否使用预测性的预读取（prefetch）</li>\n<li>针对 JavaScript 引擎有针对性的优化</li>\n<li>CSR 还是 SSR？都要！</li>\n<li>使用依靠自建的 lib 资源库（安全、可控）</li>\n<li>限制第三方脚本影响</li>\n<li>设置正确的 HTTP 缓存头（检查 expires，max-age，cache-control）</li>\n</ul>\n<h3 id=\"Delivery-Optimizations\"><a href=\"#Delivery-Optimizations\" class=\"headerlink\" title=\"Delivery Optimizations\"></a>Delivery Optimizations</h3><ul>\n<li>是否异步加载了所有的异步库？</li>\n<li>使用 IntersectionObserver 和优先级提示来延迟加载体积大的组件模块</li>\n<li>逐步加载图像（渐进式图像加载，由模糊到清晰）</li>\n<li>优先加载基础且重要的 CSS 资源</li>\n<li>尝试重新组合 CSS 规则</li>\n<li>是否对信息流有响应？</li>\n<li>考虑使你的组件具有连接意识（公用和复用数据）</li>\n<li>考虑使你的组件设备了解内存占用</li>\n<li>利用 dns-prefetch 加快交付速度</li>\n<li>善用 service workers 来缓存和网络容灾</li>\n<li>是否正在 CDN/Edge 上使用 service worker，比如 A/B Test？</li>\n<li>优化渲染性能</li>\n<li>是否优化了渲染体验</li>\n<li>是否有效阻止了重排和重绘？</li>\n</ul>\n<h3 id=\"网络和-HTTP-2\"><a href=\"#网络和-HTTP-2\" class=\"headerlink\" title=\"网络和 HTTP/2\"></a>网络和 HTTP/2</h3><ul>\n<li>是否开启 OCSP stapling</li>\n<li>是否已采用 IPV6</li>\n<li>确保所有资源请求都是经过 HTTP/2</li>\n<li>正确部署 HTTP/2</li>\n<li>确保服务器和 CDN 都已支持 HTTP/2</li>\n<li>支持 QUIC 的 HTTP（HTTP/3）</li>\n<li>是否采用 HPACK 压缩？</li>\n<li>确保服务器安全性（HTTPS 等）</li>\n</ul>\n<h3 id=\"测试与监控\"><a href=\"#测试与监控\" class=\"headerlink\" title=\"测试与监控\"></a>测试与监控</h3><ul>\n<li>是否有话了审计工作流程（加强 CI 自动化）</li>\n<li>是否在代理浏览器和旧版浏览器上进行测试？</li>\n<li>是否测试了对可访问性的影响？</li>\n<li>是否设置了持续监控</li>\n</ul>\n","more":"<h3 id=\"准备计划和指标\"><a href=\"#准备计划和指标\" class=\"headerlink\" title=\"准备计划和指标\"></a>准备计划和指标</h3><ul>\n<li>建立性能文化氛围（让更多人意识到性能的重要性）</li>\n<li>目标：比最快的竞争对手至少快 20%</li>\n<li>选择正确的指标（选择正确的指标，不是所有指标都重要）</li>\n<li>在能代表大多数用户群体的设备上收集数据（保证准确地数据收集）</li>\n<li>为测试环境准备“干净的”和“符合真实用户的”相关的配置</li>\n<li>与身边人分享性能指标（确保团队每个人都认可）</li>\n</ul>\n<h3 id=\"设定实际目标\"><a href=\"#设定实际目标\" class=\"headerlink\" title=\"设定实际目标\"></a>设定实际目标</h3><ul>\n<li>响应时间在 100ms，60fps</li>\n<li>3G 网络下的 FID&lt;100ms，TTI&lt;5​​s，速度索引&lt;3s，关键文件大小预算&lt;170KB（已压缩）</li>\n</ul>\n<h3 id=\"定义环境\"><a href=\"#定义环境\" class=\"headerlink\" title=\"定义环境\"></a>定义环境</h3><ul>\n<li>选择并配置好项目中的构建工具</li>\n<li>默认使用渐进增强</li>\n<li>选择良好的性能基准</li>\n<li>仔细评估框架和依赖（不是每个项目或者页面都需要笨重的框架和大量的依赖库）</li>\n<li>考虑使用 PRPL 模式和应用程序外壳体系的结构</li>\n<li>检查 API 是否存在优化空间（比如 GraghQL）</li>\n<li>框架选择，Google AMP 还是 Facebook 的 Instant Articles？</li>\n<li>合理运用 CDN</li>\n</ul>\n<h3 id=\"资源优化\"><a href=\"#资源优化\" class=\"headerlink\" title=\"资源优化\"></a>资源优化</h3><ul>\n<li>利用 Brotli 进行纯文本压缩（你可能总听到 gzip，brotli 是 2015 年 Google 提出的无损压缩的格式）</li>\n<li>使用响应式图片以及 webp</li>\n<li>图片是否可以再进一步优化？</li>\n<li>视频是否可以进行适当优化？</li>\n<li>网络字体是否经过优化？（适当删除和裁切可以减小加载体积）</li>\n</ul>\n<h3 id=\"构建优化\"><a href=\"#构建优化\" class=\"headerlink\" title=\"构建优化\"></a>构建优化</h3><ul>\n<li>设置优先事项</li>\n<li>在生产环境中使用原生 JavaScript 模块</li>\n<li>合理使用 tree-shaking, scope hoisting, code-splitting</li>\n<li>考虑将一些复杂繁重的 js 放在 Web Worker （预加载数据以及 PWA）</li>\n<li>考虑将一些复杂的计算逻辑放在 WebAssembly 中</li>\n<li>是否正在使用提前编译器？</li>\n<li>对于旧版浏览器仅提供旧版代码</li>\n<li>对于 JavaScript 使用模块还是非模块模式？</li>\n<li>通过增量解耦识别并重写旧代码</li>\n<li>识别并且删除没有用到的代码（代码覆盖率，Chrome 工具）</li>\n<li>缩减 JavaScript Bundle 大小</li>\n<li>对于 JavaScript Chunks 是否使用预测性的预读取（prefetch）</li>\n<li>针对 JavaScript 引擎有针对性的优化</li>\n<li>CSR 还是 SSR？都要！</li>\n<li>使用依靠自建的 lib 资源库（安全、可控）</li>\n<li>限制第三方脚本影响</li>\n<li>设置正确的 HTTP 缓存头（检查 expires，max-age，cache-control）</li>\n</ul>\n<h3 id=\"Delivery-Optimizations\"><a href=\"#Delivery-Optimizations\" class=\"headerlink\" title=\"Delivery Optimizations\"></a>Delivery Optimizations</h3><ul>\n<li>是否异步加载了所有的异步库？</li>\n<li>使用 IntersectionObserver 和优先级提示来延迟加载体积大的组件模块</li>\n<li>逐步加载图像（渐进式图像加载，由模糊到清晰）</li>\n<li>优先加载基础且重要的 CSS 资源</li>\n<li>尝试重新组合 CSS 规则</li>\n<li>是否对信息流有响应？</li>\n<li>考虑使你的组件具有连接意识（公用和复用数据）</li>\n<li>考虑使你的组件设备了解内存占用</li>\n<li>利用 dns-prefetch 加快交付速度</li>\n<li>善用 service workers 来缓存和网络容灾</li>\n<li>是否正在 CDN/Edge 上使用 service worker，比如 A/B Test？</li>\n<li>优化渲染性能</li>\n<li>是否优化了渲染体验</li>\n<li>是否有效阻止了重排和重绘？</li>\n</ul>\n<h3 id=\"网络和-HTTP-2\"><a href=\"#网络和-HTTP-2\" class=\"headerlink\" title=\"网络和 HTTP/2\"></a>网络和 HTTP/2</h3><ul>\n<li>是否开启 OCSP stapling</li>\n<li>是否已采用 IPV6</li>\n<li>确保所有资源请求都是经过 HTTP/2</li>\n<li>正确部署 HTTP/2</li>\n<li>确保服务器和 CDN 都已支持 HTTP/2</li>\n<li>支持 QUIC 的 HTTP（HTTP/3）</li>\n<li>是否采用 HPACK 压缩？</li>\n<li>确保服务器安全性（HTTPS 等）</li>\n</ul>\n<h3 id=\"测试与监控\"><a href=\"#测试与监控\" class=\"headerlink\" title=\"测试与监控\"></a>测试与监控</h3><ul>\n<li>是否有话了审计工作流程（加强 CI 自动化）</li>\n<li>是否在代理浏览器和旧版浏览器上进行测试？</li>\n<li>是否测试了对可访问性的影响？</li>\n<li>是否设置了持续监控</li>\n</ul>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"前端","path":"api/tags/前端.json"},{"name":"性能","path":"api/tags/性能.json"}]}