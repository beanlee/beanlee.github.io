{"title":"【译】React 中 State, Store, Static, This 的几个问题","slug":"react-state-this-static-store","date":"2018-10-31T14:40:13.000Z","updated":"2019-04-23T15:49:06.000Z","comments":true,"path":"api/articles/react-state-this-static-store.json","excerpt":"笔者最近在整理前段时间接手的其他团队的 RN 项目代码，在梳理项目中旧代码过程中，对 React 中 State Store Static This 产生疑惑，借此翻译这篇文章解惑，也分享给各位。原文 https://medium.freecodecamp.org/where-do-i-belong-a-guide-to-saving-react-component-data-in-state-store-static-and-this-c49b335e2a00发表时间 2016-08作者 Sam Corcos","covers":null,"content":"<blockquote>\n<p>笔者最近在整理前段时间接手的其他团队的 RN 项目代码，在梳理项目中旧代码过程中，对 React 中 State Store Static This 产生疑惑，借此翻译这篇文章解惑，也分享给各位。</p>\n</blockquote>\n<p>原文 <a href=\"https://medium.freecodecamp.org/where-do-i-belong-a-guide-to-saving-react-component-data-in-state-store-static-and-this-c49b335e2a00\" target=\"_blank\" rel=\"noopener\">https://medium.freecodecamp.org/where-do-i-belong-a-guide-to-saving-react-component-data-in-state-store-static-and-this-c49b335e2a00</a></p>\n<p>发表时间 2016-08</p>\n<p>作者 <a href=\"https://medium.freecodecamp.org/@SamCorcos\" target=\"_blank\" rel=\"noopener\">Sam Corcos</a></p>\n<a id=\"more\"></a>\n<h3 id=\"Where-to-Hold-React-Component-Data-state-store-static-and-this\"><a href=\"#Where-to-Hold-React-Component-Data-state-store-static-and-this\" class=\"headerlink\" title=\"Where to Hold React Component Data: state, store, static, and this\"></a>Where to Hold React Component Data: state, store, static, and this</h3><blockquote>\n<p>With the advent of React and Redux, a common question has emerged:</p>\n<blockquote>\n<p>What should I hold in the Redux store, and what should I save in local state?</p>\n</blockquote>\n</blockquote>\n<p>在开发 React 和 Redux 项目时，经常会被问到一个问题？</p>\n<blockquote>\n<p>我应该把什么维护在 Redux Store 中？我该在 Local state 中保存什么？</p>\n</blockquote>\n<blockquote>\n<p>But this question is actually too simplistic, because there are also two other ways you can store data for use in a component: static and this.<br>Let’s go over what each of these, and when you should use them.</p>\n</blockquote>\n<p>然而问题非常简单，因为在 component 中你可以使用两种其他的方式储存数据：static 和 this。</p>\n<p>让我们一起来详细了解下如何使用。</p>\n<h3 id=\"Local-state-组件的本地状态\"><a href=\"#Local-state-组件的本地状态\" class=\"headerlink\" title=\"Local state 组件的本地状态\"></a>Local state 组件的本地状态</h3><blockquote>\n<p>When React was first introduced, we were presented with local <strong>state</strong>. The important thing to know about local <strong>state</strong> is that when a <strong>state</strong> value changes, it triggers a re-render.<br>This state can be passed down to children as <strong>props</strong>, which allows you to separate your components between smart data-components and dumb presentational-components if you chose.</p>\n</blockquote>\n<p>React 刚刚面世之初，我们就注意到 local <strong>state</strong>。每当 <strong>state</strong> 值发生变化，都会触发组件重新 render，因此了解 <strong>state</strong> 是非常重要的。</p>\n<p>当前组件的 state 会被当做 <strong>props</strong> 传递到子组件中，这个 props 允许你在数据组件和描绘型组件之间做出区分。</p>\n<p>下面一个简单的使用 local state 计数 App 例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      counter: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      counter: <span class=\"keyword\">this</span>.state.counter + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.state.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Your data (the value of the counter) is stored within the App component, and can be passed down its children.</p>\n</blockquote>\n<p>App 组件中数据被储存其中，并可以向子组件进行传递。</p>\n<h4 id=\"Use-cases\"><a href=\"#Use-cases\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>Assuming your counter is important to your app, and is storing data that would be useful to other components, you would not want to use local state to keep this value.<br>The current best practice is to use local state to handle the state of your user interface (UI) state rather than data. For example, using a <a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">controlled component</a> to fill out a form is a perfectly valid use of local state.<br>Another example of UI data that you could store in local state would be the currently selected tab from a list of options.</p>\n</blockquote>\n<p>假设计数器 Couter 对于 App 很重要，并且它正在存储其他组件的重要数据，你不会希望使用 local state 来保存数据的。</p>\n<p>目前最佳实践是使用 local state 来处理 UI 的状态，不是使用数据。比如，使用 <a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">Controlled Components</a>  去实现一个 form 表单时使用 local state 是非常合理的。</p>\n<p>UI 数据的另外一个例子，可以在 local state 中存储备选 options 列表中已选中的选项。</p>\n<blockquote>\n<p>A good way to think about when to use local state is to consider whether the value you’re storing will be used by another component. If a value is specific to only a single component (or perhaps a single child of that component), then it’s safe to keep that value in local state.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: keep UI state and transitory data (such as form inputs) in local state.</p>\n</blockquote>\n<p>思考何时使用 local state 一个好方法，是考虑兼顾你正在存储的值是否会被另外一个组件使用到。如果这个值非常明确地只在单一组件（或单一子组件）中出现，那么将它保存在 local state 中就是非常安全的做法。</p>\n<p><strong>Takeaway</strong>：可以将 UI 状态和临时数据（form 表单输入数据）保存在 local state。</p>\n<h3 id=\"Redux-store\"><a href=\"#Redux-store\" class=\"headerlink\" title=\"Redux store\"></a>Redux store</h3><blockquote>\n<p>Then after some time had elapsed and everyone started getting comfortable with the idea of unidirectional data flow, we got Redux.</p>\n</blockquote>\n<blockquote>\n<p>With Redux, we get a global store. This store lives at the highest level of your app and passes data down to all children. You connect to the global store with the connect wrapper and a mapStateToProps function.</p>\n</blockquote>\n<p>随着时间流逝，大家都在习惯这种单向数据流的思想，随着出现了 Redux。</p>\n<p>在 Redux 中，我们有一个全局的 store，它在 App 中处于最高层级，可以将数据传递到所有子组件中。你可以使用 connect 和 mapStateToProps 方法将全局 store 和你的组件链接起来已获取数据。</p>\n<blockquote>\n<p>At first, people put everything in the Redux store. Users, modals, forms, sockets… you name it.</p>\n</blockquote>\n<blockquote>\n<p>Below is the same counter app, but using Redux. The important thing to note is that counter now comes from <strong>this.props.counter</strong> after being mapped from <strong>mapStateToProps</strong> in the <strong>connect</strong> function, which takes the counter value from the global store and maps it to the current component’s props.</p>\n</blockquote>\n<p>期初，人们把所有的东西都塞进 Redux store 中。</p>\n<p>下面是刚刚那个计数器，区别是使用了 Redux。要点是计数器在通过 <strong>connect</strong> 方法 <strong>mapStateToProps</strong> 映射之后获取 <strong>this.props.counter</strong>，这个值是从全局 store 中获取到并映射到当前组件的 props 中的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Actions <span class=\"keyword\">from</span> <span class=\"string\">'./Actions.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.dispatch(Actions.addOne())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.props.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: store.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(App)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Now when you click on the button, an action is dispatched and the global <strong>store</strong> is updated. The data is handled outside of our local component and is passed down.</p>\n</blockquote>\n<blockquote>\n<p>It’s worth noting that when <strong>props</strong> are updated, it also triggers a re-render—just like when you update <strong>state</strong>.</p>\n</blockquote>\n<p>当你点击按钮，与此链接的 action 就会被触发，同时全局的 <strong>store</strong> 就会更新。这样我们本地组件外层的数据就被操作并传递下去。</p>\n<p><strong>props</strong> 更新是没有副作用的，只有当你更新 <strong>state</strong> 时才会触发重新渲染。</p>\n<h4 id=\"Use-cases-1\"><a href=\"#Use-cases-1\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>The Redux <strong>store</strong> is great for keeping application state rather than UI state. A perfect example is a user’s login status. Many of your components will need access to this information, and as soon as the login status changes, all of those components (the ones that are rendered, at least) will need to be re-rendered with the updated information.</p>\n</blockquote>\n<blockquote>\n<p>Redux is also useful for triggering events for which you need access on multiple components or across multiple routes. An example of this would be a login modal, which can be triggered by a multitude of buttons all across your app. Rather than conditionally rendering a modal in a dozen places, you can conditionally render it at the top-level of your app and use a Redux action to trigger it by changing a value in the <strong>store</strong>.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: keep data that you intend to share across components in <strong>store</strong>.</p>\n</blockquote>\n<p>Redux 中 <strong>store</strong> 应该维护应用的数据状态而不是 UI 的状态。用户登录数据状态就是另外一个例子。只要登录状态改变，项目中多数组件将需要访问这个登录信息，随着信息的更新，这些获取到信息更新的组件就都会重新 render。</p>\n<p>Redux 通常也用于事件的触发，这些事件可能是横跨多个组件或者横跨多个路由。再以登录模块举例，可以在整个应用中来触发多个事件。你可以在应用的顶层，通过使用 Redux 对 <strong>store</strong> 进行修改，并使用 action 来触发条件渲染，而不是去不同地方去单独条件渲染。</p>\n<p><strong>Takeaway</strong>: 可以尝试在跨组件共享数据时，将数据保存进 <strong>store</strong> 。</p>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><blockquote>\n<p>One of the least utilized features when working with React is <strong>this</strong>. People often forget that React is just JavaScript with ES2015 syntax. Anything you can do in JavaScript, you can also do in React.</p>\n</blockquote>\n<blockquote>\n<p>The example below is a functional counter app, similar to the two examples above.</p>\n</blockquote>\n<p>在 React 众多特性中 <strong>this</strong> 就是其中之一。大家通常忘记一件事，就是 React 恰恰是使用 ES2015 语法的 Javascript 实现的。任何在 Javascript 可以完成的事情，同样可以放在 React 中完成。</p>\n<p>下面就是一个函数型计数应用，与上面两个例子相似。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forceUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>We’re storing the <strong>counter</strong> value in the component and using <a href=\"https://facebook.github.io/react/docs/component-api.html#forceupdate\" target=\"_blank\" rel=\"noopener\">forceUpdate()</a> to re-render when the value changes. This is because changes to anything other than <strong>state</strong> and <strong>props</strong> does not trigger a re-render.</p>\n</blockquote>\n<blockquote>\n<p>This is actually an example of how you should not use <strong>this</strong>. If you find yourself using <strong>forceUpdate()</strong>, you’re probably doing something wrong. For values for which a change should trigger a re-render, you should use local <strong>state</strong> or <strong>props</strong>/Redux <strong>store</strong>.</p>\n</blockquote>\n<p>我们在组件中存储 <strong>counter</strong> 的值，并且在这个值发生变化的时候使用 <a href=\"https://facebook.github.io/react/docs/component-api.html#forceupdate\" target=\"_blank\" rel=\"noopener\">forceUpdate()</a> 去重新渲染。这是由于没有 <strong>state</strong> 和 <strong>props</strong> 发生变化，是不会触发组件的重新渲染。</p>\n<p>这也是一个实际的非常糟糕地不使用 <strong>this</strong> 的例子。如果你发现你自己正在使用 <strong>forceUpdate()</strong> 你就有可能犯了一个错误。期望做到值改变而触发重新 render，就应该使用 local <strong>state</strong> 或者 <strong>props</strong> 或者是 Redux <strong>store</strong>。</p>\n<h4 id=\"Use-cases-2\"><a href=\"#Use-cases-2\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>The use case for <strong>this</strong> is to store values for which a change should not trigger a re-render. For example, sockets are a perfect thing to store on <strong>this</strong>.</p>\n</blockquote>\n<p>举个例子，<strong>this</strong> 所存储的变量发生改变，但并不希望触发重新 render。比如，sockets 就和适合存储在 <strong>this</strong> 上。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Socket &#125; <span class=\"keyword\">from</span> <span class=\"string\">'phoenix'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket = <span class=\"keyword\">new</span> Socket(<span class=\"string\">'http://localhost:4000/socket'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket.connect()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.configureChannel(<span class=\"string\">\"lobby\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket.leave()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  configureChannel(room) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel = <span class=\"keyword\">this</span>.socket.channel(<span class=\"string\">`rooms:<span class=\"subst\">$&#123;room&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel.join()</span><br><span class=\"line\">      .receive(<span class=\"string\">\"ok\"</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Succesfully joined the <span class=\"subst\">$&#123;room&#125;</span> chat room.`</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .receive(<span class=\"string\">\"error\"</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Unable to join the <span class=\"subst\">$&#123;room&#125;</span> chat room.`</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        My App</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Also, many people don’t realize they’re already using <strong>this</strong> all the time in their function definitions. When you define <strong>render()</strong>, you’re really defining <strong>this.prototype.render = function()</strong>, but it’s hidden behind ES2015 class syntax.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: use <strong>this</strong> to store things that shouldn’t trigger a re-render.</p>\n</blockquote>\n<p>同时，很多人并没有意识到在定义 function 时已经一直在使用 <strong>this</strong>。当你定义 <strong>render()</strong> 时，实际上是在定义 <strong>this.prototype.render = function()</strong> ，但是它是 ES2015 类定义语法的隐藏式的写法。</p>\n<p><strong>Takeaway</strong>: 使用 <strong>this</strong> 存储变量不应该触发重新 render。</p>\n<h3 id=\"Static\"><a href=\"#Static\" class=\"headerlink\" title=\"Static\"></a>Static</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static\" target=\"_blank\" rel=\"noopener\"><strong>Static</strong> methods</a> and properties are perhaps the least known aspect of ES2015 classes (calm down, yes, I know they aren’t really classes under the hood), mostly because they aren’t used all that frequently. But they actually aren’t especially complicated. If you’ve used <a href=\"https://facebook.github.io/react/docs/reusable-components.html#prop-validation\" target=\"_blank\" rel=\"noopener\">PropTypes</a>, you’ve already defined a <strong>static</strong> property.</p>\n</blockquote>\n<blockquote>\n<p>The following two code blocks are identical. The first is how most people define PropTypes. The second is how you can define them with <strong>static</strong>.</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static\" target=\"_blank\" rel=\"noopener\"><strong>Static</strong> methods</a> 和 properties 可能是在 ES2015 类中最不为人知的一部分，主要是因为他们不太常用。然而他们并不难懂复杂。如果你已经用过 <a href=\"https://facebook.github.io/react/docs/reusable-components.html#prop-validation\" target=\"_blank\" rel=\"noopener\">PropTypes</a>, 那么你已经定义过 <strong>static</strong> 属性了。</p>\n<p>下面这两段代码片段相同。第一段是大多数人如何定义 Proptypes。第二段是你可以使用 <strong>static</strong> 定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123; this.props.title &#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.string.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> propTypes &#123;</span><br><span class=\"line\">    title: React.PropTypes.string.isRequired</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123; this.props.title &#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>As you can see, <strong>static</strong> is not all that complicated. It’s just another way to assign a value to a class. The main difference between <strong>static</strong> and <strong>this</strong> is that you do not need to instantiate the class to access the value.</p>\n</blockquote>\n<p>你可以看到，<strong>static</strong> 并不复杂。他仅仅是给类增加值的另外一种方式。在 <strong>static</strong> 和 <strong>this</strong> 之间主要的差异主要是不需要实例化来访问这个值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.prototypeProperty = &#123;</span><br><span class=\"line\">      baz: <span class=\"string\">\"qux\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> staticProperty = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>My App<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proto = <span class=\"keyword\">new</span> App();</span><br><span class=\"line\"><span class=\"keyword\">const</span> proto2 = proto.prototypeProperty <span class=\"comment\">// =&gt; &#123; baz: \"qux\" &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stat = App.staticProperty <span class=\"comment\">// =&gt; &#123; foo: \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>In the example above, you can see that to get the <strong>staticProperty</strong> value, we could just call it straight from the class without instantiating it, but to get prototypeProperty, we had to instantiate it with <strong>new App()</strong>.</p>\n</blockquote>\n<p>在上面的例子中，你可以看到获取 <strong>staticProperty</strong> 静态属性的值，我们仅仅调用 class 中的静态方法即可，并不需要实例化，但是如果想要获取 prototypeProperty 属性，我们就不得不使用 <strong>new App()</strong> 实例化以后才可以访问到。</p>\n<h4 id=\"Use-cases-3\"><a href=\"#Use-cases-3\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>Static methods and properties are rarely used, and should be used for utility functions that all components of a particular type would need.</p>\n</blockquote>\n<blockquote>\n<p><strong>PropTypes</strong> are an example of a utility function where you would attach to something like a Button component, since every button you render will need those same values.</p>\n</blockquote>\n<blockquote>\n<p>Another use case is if you’re concerned about over-fetching data. If you’re using GraphQL or Falcor, you can specify which data you want back from your server. This way you don’t end up receiving a lot more data than you actually need for your component.</p>\n</blockquote>\n<p>静态方法和属性很少使用，应作为组件中的工具函数来使用。</p>\n<p><strong>PropTypes</strong> 就是工具函数的例子，当创建按钮组件等其他类似组件时，尽管渲染出来的每一个按钮仍然需要相同的值。</p>\n<p>另一个应用例子就是，如果你考虑从远端 fetch 数据。如果你正使用 GraphQL 或者 Falcor，那么你可以从服务端区分想要的数据。这种方式你不需要在获取组件多余的数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> requiredData = [</span><br><span class=\"line\">    <span class=\"string\">\"username\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"email\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"thumbnail_url\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>So in the example component above, before requesting the data for a particular component, you could quickly get an array of required values for your query with <strong>App.requiredData</strong>. This allows you to make a request without over-fetching.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: you’re probably never going to use <strong>static</strong>.</p>\n</blockquote>\n<p>在上面实例组件中，在具体得组件获取数据之前，你可以快速地通过 <strong>App.requiredData</strong> 来获取这个数据的数组。这允许你不用 over-fetching 就可以完成请求。</p>\n<p><strong>Takeaway</strong>: 你可能永远不会用到 <strong>static</strong>。</p>\n<h3 id=\"That-other-option…\"><a href=\"#That-other-option…\" class=\"headerlink\" title=\"That other option…\"></a>That other option…</h3><blockquote>\n<p>There is actually another option, which I intentionally left out of the title because you should use it sparingly: you can store things in a module-scoped <strong>variable</strong>.</p>\n</blockquote>\n<blockquote>\n<p>There are specific situations in which it makes sense, but for the most part you just shouldn’t do it.</p>\n</blockquote>\n<p>还有另外一个选择，我故意省略了标题，因为你应该谨慎使用它：你可以储存在模块作用域变量中。</p>\n<p>这是一种行之有效的特殊方法，但是最好不要使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    counter += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forceUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can see this is almost the same as using <strong>this</strong>, except that we’re storing the value outside of our component, which could cause problems if you have more than one component per file. You might want to use this for setting default values if the values are not tied to your <strong>store</strong>, otherwise using a <strong>static</strong> for default props would be better.</p>\n</blockquote>\n<blockquote>\n<p>If you need to share data across components and want to keep data available to everything the module, it’s almost always better to use your Redux <strong>store</strong>.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: don’t use module-scoped variables if you can avoid it.</p>\n</blockquote>\n<p>从上面的代码你可以看到与使用 <strong>this</strong> 很相似，尤其是我们将值存储在了组件之外，如果每个文件有多个组件极有可能产生问题。如果你没有将这个值绑定在 <strong>store</strong> 上，那你可能很希望使用 this 去设定初始默认值，否则使用 <strong>static</strong> 来设置默认 props 会更好。</p>\n<p>如果你需要跨组件之间共享数据，并且希望将这些数据维持在每一个模块都有效，那么使用 Redux <strong>store</strong> 会更好。</p>\n<p><strong>Takeaway</strong>: 如果可以避免的话，不要使用模块作用域的变量。</p>\n","more":"<h3 id=\"Where-to-Hold-React-Component-Data-state-store-static-and-this\"><a href=\"#Where-to-Hold-React-Component-Data-state-store-static-and-this\" class=\"headerlink\" title=\"Where to Hold React Component Data: state, store, static, and this\"></a>Where to Hold React Component Data: state, store, static, and this</h3><blockquote>\n<p>With the advent of React and Redux, a common question has emerged:</p>\n<blockquote>\n<p>What should I hold in the Redux store, and what should I save in local state?</p>\n</blockquote>\n</blockquote>\n<p>在开发 React 和 Redux 项目时，经常会被问到一个问题？</p>\n<blockquote>\n<p>我应该把什么维护在 Redux Store 中？我该在 Local state 中保存什么？</p>\n</blockquote>\n<blockquote>\n<p>But this question is actually too simplistic, because there are also two other ways you can store data for use in a component: static and this.<br>Let’s go over what each of these, and when you should use them.</p>\n</blockquote>\n<p>然而问题非常简单，因为在 component 中你可以使用两种其他的方式储存数据：static 和 this。</p>\n<p>让我们一起来详细了解下如何使用。</p>\n<h3 id=\"Local-state-组件的本地状态\"><a href=\"#Local-state-组件的本地状态\" class=\"headerlink\" title=\"Local state 组件的本地状态\"></a>Local state 组件的本地状态</h3><blockquote>\n<p>When React was first introduced, we were presented with local <strong>state</strong>. The important thing to know about local <strong>state</strong> is that when a <strong>state</strong> value changes, it triggers a re-render.<br>This state can be passed down to children as <strong>props</strong>, which allows you to separate your components between smart data-components and dumb presentational-components if you chose.</p>\n</blockquote>\n<p>React 刚刚面世之初，我们就注意到 local <strong>state</strong>。每当 <strong>state</strong> 值发生变化，都会触发组件重新 render，因此了解 <strong>state</strong> 是非常重要的。</p>\n<p>当前组件的 state 会被当做 <strong>props</strong> 传递到子组件中，这个 props 允许你在数据组件和描绘型组件之间做出区分。</p>\n<p>下面一个简单的使用 local state 计数 App 例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      counter: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      counter: <span class=\"keyword\">this</span>.state.counter + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.state.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Your data (the value of the counter) is stored within the App component, and can be passed down its children.</p>\n</blockquote>\n<p>App 组件中数据被储存其中，并可以向子组件进行传递。</p>\n<h4 id=\"Use-cases\"><a href=\"#Use-cases\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>Assuming your counter is important to your app, and is storing data that would be useful to other components, you would not want to use local state to keep this value.<br>The current best practice is to use local state to handle the state of your user interface (UI) state rather than data. For example, using a <a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">controlled component</a> to fill out a form is a perfectly valid use of local state.<br>Another example of UI data that you could store in local state would be the currently selected tab from a list of options.</p>\n</blockquote>\n<p>假设计数器 Couter 对于 App 很重要，并且它正在存储其他组件的重要数据，你不会希望使用 local state 来保存数据的。</p>\n<p>目前最佳实践是使用 local state 来处理 UI 的状态，不是使用数据。比如，使用 <a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">Controlled Components</a>  去实现一个 form 表单时使用 local state 是非常合理的。</p>\n<p>UI 数据的另外一个例子，可以在 local state 中存储备选 options 列表中已选中的选项。</p>\n<blockquote>\n<p>A good way to think about when to use local state is to consider whether the value you’re storing will be used by another component. If a value is specific to only a single component (or perhaps a single child of that component), then it’s safe to keep that value in local state.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: keep UI state and transitory data (such as form inputs) in local state.</p>\n</blockquote>\n<p>思考何时使用 local state 一个好方法，是考虑兼顾你正在存储的值是否会被另外一个组件使用到。如果这个值非常明确地只在单一组件（或单一子组件）中出现，那么将它保存在 local state 中就是非常安全的做法。</p>\n<p><strong>Takeaway</strong>：可以将 UI 状态和临时数据（form 表单输入数据）保存在 local state。</p>\n<h3 id=\"Redux-store\"><a href=\"#Redux-store\" class=\"headerlink\" title=\"Redux store\"></a>Redux store</h3><blockquote>\n<p>Then after some time had elapsed and everyone started getting comfortable with the idea of unidirectional data flow, we got Redux.</p>\n</blockquote>\n<blockquote>\n<p>With Redux, we get a global store. This store lives at the highest level of your app and passes data down to all children. You connect to the global store with the connect wrapper and a mapStateToProps function.</p>\n</blockquote>\n<p>随着时间流逝，大家都在习惯这种单向数据流的思想，随着出现了 Redux。</p>\n<p>在 Redux 中，我们有一个全局的 store，它在 App 中处于最高层级，可以将数据传递到所有子组件中。你可以使用 connect 和 mapStateToProps 方法将全局 store 和你的组件链接起来已获取数据。</p>\n<blockquote>\n<p>At first, people put everything in the Redux store. Users, modals, forms, sockets… you name it.</p>\n</blockquote>\n<blockquote>\n<p>Below is the same counter app, but using Redux. The important thing to note is that counter now comes from <strong>this.props.counter</strong> after being mapped from <strong>mapStateToProps</strong> in the <strong>connect</strong> function, which takes the counter value from the global store and maps it to the current component’s props.</p>\n</blockquote>\n<p>期初，人们把所有的东西都塞进 Redux store 中。</p>\n<p>下面是刚刚那个计数器，区别是使用了 Redux。要点是计数器在通过 <strong>connect</strong> 方法 <strong>mapStateToProps</strong> 映射之后获取 <strong>this.props.counter</strong>，这个值是从全局 store 中获取到并映射到当前组件的 props 中的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Actions <span class=\"keyword\">from</span> <span class=\"string\">'./Actions.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.props.dispatch(Actions.addOne())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.props.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">store</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    counter: store.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(App)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Now when you click on the button, an action is dispatched and the global <strong>store</strong> is updated. The data is handled outside of our local component and is passed down.</p>\n</blockquote>\n<blockquote>\n<p>It’s worth noting that when <strong>props</strong> are updated, it also triggers a re-render—just like when you update <strong>state</strong>.</p>\n</blockquote>\n<p>当你点击按钮，与此链接的 action 就会被触发，同时全局的 <strong>store</strong> 就会更新。这样我们本地组件外层的数据就被操作并传递下去。</p>\n<p><strong>props</strong> 更新是没有副作用的，只有当你更新 <strong>state</strong> 时才会触发重新渲染。</p>\n<h4 id=\"Use-cases-1\"><a href=\"#Use-cases-1\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>The Redux <strong>store</strong> is great for keeping application state rather than UI state. A perfect example is a user’s login status. Many of your components will need access to this information, and as soon as the login status changes, all of those components (the ones that are rendered, at least) will need to be re-rendered with the updated information.</p>\n</blockquote>\n<blockquote>\n<p>Redux is also useful for triggering events for which you need access on multiple components or across multiple routes. An example of this would be a login modal, which can be triggered by a multitude of buttons all across your app. Rather than conditionally rendering a modal in a dozen places, you can conditionally render it at the top-level of your app and use a Redux action to trigger it by changing a value in the <strong>store</strong>.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: keep data that you intend to share across components in <strong>store</strong>.</p>\n</blockquote>\n<p>Redux 中 <strong>store</strong> 应该维护应用的数据状态而不是 UI 的状态。用户登录数据状态就是另外一个例子。只要登录状态改变，项目中多数组件将需要访问这个登录信息，随着信息的更新，这些获取到信息更新的组件就都会重新 render。</p>\n<p>Redux 通常也用于事件的触发，这些事件可能是横跨多个组件或者横跨多个路由。再以登录模块举例，可以在整个应用中来触发多个事件。你可以在应用的顶层，通过使用 Redux 对 <strong>store</strong> 进行修改，并使用 action 来触发条件渲染，而不是去不同地方去单独条件渲染。</p>\n<p><strong>Takeaway</strong>: 可以尝试在跨组件共享数据时，将数据保存进 <strong>store</strong> 。</p>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><blockquote>\n<p>One of the least utilized features when working with React is <strong>this</strong>. People often forget that React is just JavaScript with ES2015 syntax. Anything you can do in JavaScript, you can also do in React.</p>\n</blockquote>\n<blockquote>\n<p>The example below is a functional counter app, similar to the two examples above.</p>\n</blockquote>\n<p>在 React 众多特性中 <strong>this</strong> 就是其中之一。大家通常忘记一件事，就是 React 恰恰是使用 ES2015 语法的 Javascript 实现的。任何在 Javascript 可以完成的事情，同样可以放在 React 中完成。</p>\n<p>下面就是一个函数型计数应用，与上面两个例子相似。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forceUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; this.counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>We’re storing the <strong>counter</strong> value in the component and using <a href=\"https://facebook.github.io/react/docs/component-api.html#forceupdate\" target=\"_blank\" rel=\"noopener\">forceUpdate()</a> to re-render when the value changes. This is because changes to anything other than <strong>state</strong> and <strong>props</strong> does not trigger a re-render.</p>\n</blockquote>\n<blockquote>\n<p>This is actually an example of how you should not use <strong>this</strong>. If you find yourself using <strong>forceUpdate()</strong>, you’re probably doing something wrong. For values for which a change should trigger a re-render, you should use local <strong>state</strong> or <strong>props</strong>/Redux <strong>store</strong>.</p>\n</blockquote>\n<p>我们在组件中存储 <strong>counter</strong> 的值，并且在这个值发生变化的时候使用 <a href=\"https://facebook.github.io/react/docs/component-api.html#forceupdate\" target=\"_blank\" rel=\"noopener\">forceUpdate()</a> 去重新渲染。这是由于没有 <strong>state</strong> 和 <strong>props</strong> 发生变化，是不会触发组件的重新渲染。</p>\n<p>这也是一个实际的非常糟糕地不使用 <strong>this</strong> 的例子。如果你发现你自己正在使用 <strong>forceUpdate()</strong> 你就有可能犯了一个错误。期望做到值改变而触发重新 render，就应该使用 local <strong>state</strong> 或者 <strong>props</strong> 或者是 Redux <strong>store</strong>。</p>\n<h4 id=\"Use-cases-2\"><a href=\"#Use-cases-2\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>The use case for <strong>this</strong> is to store values for which a change should not trigger a re-render. For example, sockets are a perfect thing to store on <strong>this</strong>.</p>\n</blockquote>\n<p>举个例子，<strong>this</strong> 所存储的变量发生改变，但并不希望触发重新 render。比如，sockets 就和适合存储在 <strong>this</strong> 上。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Socket &#125; <span class=\"keyword\">from</span> <span class=\"string\">'phoenix'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket = <span class=\"keyword\">new</span> Socket(<span class=\"string\">'http://localhost:4000/socket'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket.connect()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.configureChannel(<span class=\"string\">\"lobby\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentWillUnmount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.socket.leave()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  configureChannel(room) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel = <span class=\"keyword\">this</span>.socket.channel(<span class=\"string\">`rooms:<span class=\"subst\">$&#123;room&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel.join()</span><br><span class=\"line\">      .receive(<span class=\"string\">\"ok\"</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Succesfully joined the <span class=\"subst\">$&#123;room&#125;</span> chat room.`</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .receive(<span class=\"string\">\"error\"</span>, () =&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Unable to join the <span class=\"subst\">$&#123;room&#125;</span> chat room.`</span>)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        My App</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">export default App</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Also, many people don’t realize they’re already using <strong>this</strong> all the time in their function definitions. When you define <strong>render()</strong>, you’re really defining <strong>this.prototype.render = function()</strong>, but it’s hidden behind ES2015 class syntax.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: use <strong>this</strong> to store things that shouldn’t trigger a re-render.</p>\n</blockquote>\n<p>同时，很多人并没有意识到在定义 function 时已经一直在使用 <strong>this</strong>。当你定义 <strong>render()</strong> 时，实际上是在定义 <strong>this.prototype.render = function()</strong> ，但是它是 ES2015 类定义语法的隐藏式的写法。</p>\n<p><strong>Takeaway</strong>: 使用 <strong>this</strong> 存储变量不应该触发重新 render。</p>\n<h3 id=\"Static\"><a href=\"#Static\" class=\"headerlink\" title=\"Static\"></a>Static</h3><blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static\" target=\"_blank\" rel=\"noopener\"><strong>Static</strong> methods</a> and properties are perhaps the least known aspect of ES2015 classes (calm down, yes, I know they aren’t really classes under the hood), mostly because they aren’t used all that frequently. But they actually aren’t especially complicated. If you’ve used <a href=\"https://facebook.github.io/react/docs/reusable-components.html#prop-validation\" target=\"_blank\" rel=\"noopener\">PropTypes</a>, you’ve already defined a <strong>static</strong> property.</p>\n</blockquote>\n<blockquote>\n<p>The following two code blocks are identical. The first is how most people define PropTypes. The second is how you can define them with <strong>static</strong>.</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static\" target=\"_blank\" rel=\"noopener\"><strong>Static</strong> methods</a> 和 properties 可能是在 ES2015 类中最不为人知的一部分，主要是因为他们不太常用。然而他们并不难懂复杂。如果你已经用过 <a href=\"https://facebook.github.io/react/docs/reusable-components.html#prop-validation\" target=\"_blank\" rel=\"noopener\">PropTypes</a>, 那么你已经定义过 <strong>static</strong> 属性了。</p>\n<p>下面这两段代码片段相同。第一段是大多数人如何定义 Proptypes。第二段是你可以使用 <strong>static</strong> 定义。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123; this.props.title &#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  title: React.PropTypes.string.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> propTypes &#123;</span><br><span class=\"line\">    title: React.PropTypes.string.isRequired</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123; this.props.title &#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>As you can see, <strong>static</strong> is not all that complicated. It’s just another way to assign a value to a class. The main difference between <strong>static</strong> and <strong>this</strong> is that you do not need to instantiate the class to access the value.</p>\n</blockquote>\n<p>你可以看到，<strong>static</strong> 并不复杂。他仅仅是给类增加值的另外一种方式。在 <strong>static</strong> 和 <strong>this</strong> 之间主要的差异主要是不需要实例化来访问这个值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.prototypeProperty = &#123;</span><br><span class=\"line\">      baz: <span class=\"string\">\"qux\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> staticProperty = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>My App<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proto = <span class=\"keyword\">new</span> App();</span><br><span class=\"line\"><span class=\"keyword\">const</span> proto2 = proto.prototypeProperty <span class=\"comment\">// =&gt; &#123; baz: \"qux\" &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> stat = App.staticProperty <span class=\"comment\">// =&gt; &#123; foo: \"bar\" &#125;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>In the example above, you can see that to get the <strong>staticProperty</strong> value, we could just call it straight from the class without instantiating it, but to get prototypeProperty, we had to instantiate it with <strong>new App()</strong>.</p>\n</blockquote>\n<p>在上面的例子中，你可以看到获取 <strong>staticProperty</strong> 静态属性的值，我们仅仅调用 class 中的静态方法即可，并不需要实例化，但是如果想要获取 prototypeProperty 属性，我们就不得不使用 <strong>new App()</strong> 实例化以后才可以访问到。</p>\n<h4 id=\"Use-cases-3\"><a href=\"#Use-cases-3\" class=\"headerlink\" title=\"Use cases\"></a>Use cases</h4><blockquote>\n<p>Static methods and properties are rarely used, and should be used for utility functions that all components of a particular type would need.</p>\n</blockquote>\n<blockquote>\n<p><strong>PropTypes</strong> are an example of a utility function where you would attach to something like a Button component, since every button you render will need those same values.</p>\n</blockquote>\n<blockquote>\n<p>Another use case is if you’re concerned about over-fetching data. If you’re using GraphQL or Falcor, you can specify which data you want back from your server. This way you don’t end up receiving a lot more data than you actually need for your component.</p>\n</blockquote>\n<p>静态方法和属性很少使用，应作为组件中的工具函数来使用。</p>\n<p><strong>PropTypes</strong> 就是工具函数的例子，当创建按钮组件等其他类似组件时，尽管渲染出来的每一个按钮仍然需要相同的值。</p>\n<p>另一个应用例子就是，如果你考虑从远端 fetch 数据。如果你正使用 GraphQL 或者 Falcor，那么你可以从服务端区分想要的数据。这种方式你不需要在获取组件多余的数据。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> requiredData = [</span><br><span class=\"line\">    <span class=\"string\">\"username\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"email\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"thumbnail_url\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>So in the example component above, before requesting the data for a particular component, you could quickly get an array of required values for your query with <strong>App.requiredData</strong>. This allows you to make a request without over-fetching.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: you’re probably never going to use <strong>static</strong>.</p>\n</blockquote>\n<p>在上面实例组件中，在具体得组件获取数据之前，你可以快速地通过 <strong>App.requiredData</strong> 来获取这个数据的数组。这允许你不用 over-fetching 就可以完成请求。</p>\n<p><strong>Takeaway</strong>: 你可能永远不会用到 <strong>static</strong>。</p>\n<h3 id=\"That-other-option…\"><a href=\"#That-other-option…\" class=\"headerlink\" title=\"That other option…\"></a>That other option…</h3><blockquote>\n<p>There is actually another option, which I intentionally left out of the title because you should use it sparingly: you can store things in a module-scoped <strong>variable</strong>.</p>\n</blockquote>\n<blockquote>\n<p>There are specific situations in which it makes sense, but for the most part you just shouldn’t do it.</p>\n</blockquote>\n<p>还有另外一个选择，我故意省略了标题，因为你应该谨慎使用它：你可以储存在模块作用域变量中。</p>\n<p>这是一种行之有效的特殊方法，但是最好不要使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.addOne = <span class=\"keyword\">this</span>.addOne.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  addOne() &#123;</span><br><span class=\"line\">    counter += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forceUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button</span><br><span class=\"line\">          onClick=&#123; <span class=\"keyword\">this</span>.addOne &#125;&gt;</span><br><span class=\"line\">          Increment</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &#123; counter &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can see this is almost the same as using <strong>this</strong>, except that we’re storing the value outside of our component, which could cause problems if you have more than one component per file. You might want to use this for setting default values if the values are not tied to your <strong>store</strong>, otherwise using a <strong>static</strong> for default props would be better.</p>\n</blockquote>\n<blockquote>\n<p>If you need to share data across components and want to keep data available to everything the module, it’s almost always better to use your Redux <strong>store</strong>.</p>\n</blockquote>\n<blockquote>\n<p><strong>Takeaway</strong>: don’t use module-scoped variables if you can avoid it.</p>\n</blockquote>\n<p>从上面的代码你可以看到与使用 <strong>this</strong> 很相似，尤其是我们将值存储在了组件之外，如果每个文件有多个组件极有可能产生问题。如果你没有将这个值绑定在 <strong>store</strong> 上，那你可能很希望使用 this 去设定初始默认值，否则使用 <strong>static</strong> 来设置默认 props 会更好。</p>\n<p>如果你需要跨组件之间共享数据，并且希望将这些数据维持在每一个模块都有效，那么使用 Redux <strong>store</strong> 会更好。</p>\n<p><strong>Takeaway</strong>: 如果可以避免的话，不要使用模块作用域的变量。</p>","categories":[{"name":"前端技术","path":"api/categories/前端技术.json"}],"tags":[{"name":"Front-End","path":"api/tags/Front-End.json"},{"name":"React","path":"api/tags/React.json"}]}