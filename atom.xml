<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeanLee Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://beanlee.github.io/"/>
  <updated>2018-05-03T01:01:45.076Z</updated>
  <id>https://beanlee.github.io/</id>
  
  <author>
    <name>Bean Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】Google 出品 - 利用 webpack 做 web 性能优化</title>
    <link href="https://beanlee.github.io/2018/05/02/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/"/>
    <id>https://beanlee.github.io/2018/05/02/blog-translate-web-performance-optimization-with-webpack-from-google-webpack4/</id>
    <published>2018-05-02T06:35:33.000Z</published>
    <updated>2018-05-03T01:01:45.076Z</updated>
    
    <content type="html"><![CDATA[<p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a>，<a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>原文 <a href="https://developers.google.com/web/fundamentals/performance/webpack/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/webpack/</a></p><blockquote><p>PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpack 4 内容，同时对原译文进行了校对和一些细节措辞的修改。</p></blockquote><a id="more"></a><h2 id="Instroduction-介绍"><a href="#Instroduction-介绍" class="headerlink" title="Instroduction 介绍"></a>Instroduction 介绍</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a></p><p>现代 Web 应用经常用到 <code>bunding tool</code> 来创建生产环境的打包文件（例如脚本、样式等等），打包文件是需要<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/javascript-startup-optimization" target="_blank" rel="noopener">优化</a>并<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer" target="_blank" rel="noopener">压缩最小化</a>，同时能够被用户更快地加载。在这篇文章中，我们将会利用 <a href="https://webpack.js.org/" target="_blank" rel="noopener"><code>webpack</code></a> 来贯穿说明如何进行高效地优化网站资源。这能帮助用户更快地加载你的应用同时获得更好的体验。</p><p><img src="https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png" alt="webpack-logo"></p><p>webpack 是当今最流行的打包工具之一，深入地利用它的特点去优化代码，将脚本<a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading" target="_blank" rel="noopener">拆分</a>成不同的部分，同时剔除无用代码将能够保证你的应用维持最小的带宽和进程消耗。</p><p><img src="https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png" alt="code-splitting"></p><blockquote><p>Note: 我们创建了一个练习的应用来演示下面这些优化的描述。尽力抽更多的时间来练习这些 tips <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener"><code>webpack-training-project</code></a></p></blockquote><p>让我们从现代 web 应用中最耗费资源之一的 <code>Javascript</code> 开始。</p><ul><li><a href="#Decrease Front-end Size 减少前端体积">减小前端体积</a></li><li><a href="#Make use of long-term caching 利用好长时缓存">利用长时缓存</a></li><li><a href="#Monitor and analyze the app 监控并分析">监控并分析应用</a></li><li><a href="#Conclusion">总结</a></li></ul><hr><h2 id="Decrease-Front-end-Size-减少前端体积"><a href="#Decrease-Front-end-Size-减少前端体积" class="headerlink" title="Decrease Front-end Size 减少前端体积"></a>Decrease Front-end Size 减少前端体积</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>当你正在优化一个应用时，首要事情就是尽可能地将它体积的减小。下面我们就来看看通过 <code>webpack</code> 如何做到减小前端体积。</p><h3 id="Use-the-production-mode-webpack-4-only-使用生产模式（仅用于-webpack-4）"><a href="#Use-the-production-mode-webpack-4-only-使用生产模式（仅用于-webpack-4）" class="headerlink" title="Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）"></a>Use the production mode (webpack 4 only) 使用生产模式（仅用于 webpack 4）</h3><p>Webpack 4 介绍了一种新的<a href="https://webpack.js.org/concepts/mode/" target="_blank" rel="noopener">模式</a>，你可以将其设置成 <code>development</code> 和 <code>production</code> 用于告诉 Webpack 你正在为不同的环境打包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你正在为你的应用用于生产环境编译打包时要确定开启了 <code>production</code> 模式。这样就帮助 webpack 开启类似压缩最小化代码、去除依赖库中开发环境代码等<a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">其他</a>的优化项。</p><h5 id="Further-reading-扩展阅读"><a href="#Further-reading-扩展阅读" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li><a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">What specific things the mode flag configures</a></li></ul><blockquote><p>Note: 笔者也翻译了另外一篇介绍新增 mode 的文章，感兴趣可以<a href="https://beanlee.github.io/2018/04/18/blog-translate-webpack-4-mode-and-optimization/">点击链接</a></p></blockquote><h3 id="Enable-minification-开启最小化"><a href="#Enable-minification-开启最小化" class="headerlink" title="Enable minification 开启最小化"></a>Enable minification 开启最小化</h3><blockquote><p>Note: 大部分只针对 webpack 3 如果你正在使用 webpack 4 生产模式打包，bundle 级别的最小化功能已经开启 - 你只需要配置<a href="#Loader-specific options 特定的 Loader 配置">对应 loader 选项</a>即可</p></blockquote><p>最小化就是通过去除多余空格、缩短变量名等方式压缩代码。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Original code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">const</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    result[index] = iteratee(array[index], index, array);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Minified code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">n,r</span>)</span>&#123;<span class="keyword">let</span> t=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="keyword">const</span> a=<span class="literal">null</span>==n?<span class="number">0</span>:n.length,l=<span class="built_in">Array</span>(a);++t&lt;a;)l[t]=r(n[t],t,n);<span class="keyword">return</span> l&#125;</span><br></pre></td></tr></table></figure><p>Webpack 支持两种方式最小化代码：<em>bundle-level</em> 最小化 和 <em>loader-specific options</em>。他们可以同时使用。</p><h4 id="Bundle-level-minification-bundle-级别的最小化"><a href="#Bundle-level-minification-bundle-级别的最小化" class="headerlink" title="Bundle-level minification bundle 级别的最小化"></a>Bundle-level minification bundle 级别的最小化</h4><p><code>Bundle-level</code> 最小化功能可以在编译完成后压缩整个 <code>bundle</code>。下面来看下它是如何工作的：</p><p>1.原始代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./comments.css'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Webpack 编译后的内容大概是下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"render"</span>] = render;</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =</span><br><span class="line">__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.最小化之后的代码大概是下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">e,n</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"Rendered!"</span>)&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(n,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;),n.render=t;<span class="keyword">var</span> o=r(<span class="number">1</span>);r.n(o)</span><br></pre></td></tr></table></figure><p>在 <strong>Webpack 4</strong> 中，bundle 级别的的最小化是自动开启的 - 同时在生产模式下、没有启用 bundle-level 都会开启。它是利用 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">UglifyJS</a> 引擎来进行最小化的。（如果你需要禁用最小化，仅仅设置开发模式或者设置 <code>optimization.minimize</code> 为 <code>false</code>。）</p><p>在 <strong>Webpack 3</strong> 中，你需要直接使用 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">UglifyJS</a> 插件。该插件是 webpack 提供的；开启并设置插件选项即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 在 webpack 3 中，UglifyJS 插件不能编译 ES2015+(ES6) 的代码，这就意味着你在代码中使用 <strong>classes</strong>, <strong>arrow function</strong> 或者其他新特性时，不能将他们编译成 ES5的代码，插件会抛错。<br>如果你需要编译这些新语法，就要用到 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> package，他也是在 webpack 中捆绑一起的，但是版本更新，并且可以编译 ES2015+ 的代码。</p></blockquote><h4 id="Loader-specific-options-特定的-Loader-配置"><a href="#Loader-specific-options-特定的-Loader-配置" class="headerlink" title="Loader-specific options 特定的 Loader 配置"></a>Loader-specific options 特定的 Loader 配置</h4><p>最小化代码的第二步就是利用特定的 <a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="noopener">loader</a> 配置。配置这些 loader，你可以压缩那些不能被最小化的部分。举个例子，当你使用 <code>css-loader</code> 引入一个 css 文件时，文件会被编译成一个字符串：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* comments.css */</span></span><br><span class="line"><span class="selector-class">.comment</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line">exports=<span class="built_in">module</span>.exports=__webpack_require__(<span class="number">1</span>)(),</span><br><span class="line">exports.push([<span class="built_in">module</span>.i,<span class="string">".comment &#123;\r\n  color: black;\r\n&#125;"</span>,<span class="string">""</span>]);</span><br></pre></td></tr></table></figure><p>这部分内容由于是字符串并没有被最小化。于是我们需要配置对应的 loader 选项来达到最小化的目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">minimize</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h5><ul><li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">The UglifyJsPlugin docs</a> UglifyJs 插件文档</li><li>Other popular minifiers: <a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify</a>, <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler</a> 其他流行的最小化工具</li></ul><h3 id="Specify-NODE-ENV-production-明确生产环境信息"><a href="#Specify-NODE-ENV-production-明确生产环境信息" class="headerlink" title="Specify NODE_ENV=production 明确生产环境信息"></a>Specify <code>NODE_ENV=production</code> 明确生产环境信息</h3><blockquote><p>Note: 仅在 webpack 3 中生效，如果使用生产模式 webpack 4 打包，<strong>NODE_ENV=production</strong> 优化项已经开启，就可以直接跳过此小结</p></blockquote><p>减小前端体积的另外一个方法就是在代码中将 <code>NODE_ENV</code> <a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">环境变量</a>设置为 <code>production</code> 。</p><p>Libraries 会读取 <code>NODE_ENV</code> 变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当<code>NODE_ENV</code>没有设置成<code>production</code>，Vue.js 会做额外的检查并且输出一些警告：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure><p>React 也是类似 - 开发模式下 build 带有一些警告：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react/index.js</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.production.min.js'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.development.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react/cjs/react.development.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">warning$<span class="number">3</span>(</span><br><span class="line">  componentClass.getDefaultProps.isReactClassApproved,</span><br><span class="line">  <span class="string">'getDefaultProps is only used on classic React.createClass '</span> +</span><br><span class="line">  <span class="string">'definitions. Use a static property named `defaultProps` instead.'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure><p>这些检查和警告通常在生产环境下是不必要的，但是他们仍然保留在代码中并且会增加库的体积。</p><p>在 <strong>Webpack 4</strong> 中增加 <code>optimization.nodeEnv: &#39;production&#39;</code> 选项即可剔除掉它们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    nodeEnv: <span class="string">'production'</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>Webpack 3</strong> 中则使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="string">'"production"'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>optimization.nodeEnv: &#39;production&#39;</code> 选项和 <code>DefinePlugin</code> 插件采用相同的方式来解决这个问题 - 这个方式就是他们将 <code>process.env.NODE_ENV</code> 替换成特定的值，下面的配置可以说明：</p><p>1.Webpack 会将所有 <code>process.env.NODE_ENV</code> 替换成 <code>&quot;production&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.与此同时最小化工具会移除掉所有 <code>if</code> 的条件分支 - 由于 <code>&quot;production&quot; !== &#39;production&#39;</code> 永远会返回 <code>false</code>，这样分支内的代码就永远不会执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js (without minification)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Further-Reading-扩展阅读"><a href="#Further-Reading-扩展阅读" class="headerlink" title="Further Reading 扩展阅读"></a>Further Reading 扩展阅读</h5><ul><li><a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">What “environment variables” are</a> 解释什么是环境变量</li><li>Webpack docs about: <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a>, <a href="https://webpack.js.org/plugins/environment-plugin/" target="_blank" rel="noopener"><code>EnvironmentPlugin</code></a> Define 插件和 Environment 插件文档</li></ul><h3 id="Use-ES-Modules-使用-ES-模块"><a href="#Use-ES-Modules-使用-ES-模块" class="headerlink" title="Use ES Modules 使用 ES 模块"></a>Use ES Modules 使用 ES 模块</h3><p>下面这个方式利用 <a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">ES modules</a> 减小前端体积。</p><p>当你使用 ES module，webpack 有能力去做 <code>tree-shaking</code>。Tree-shaking 贯穿了整个依赖树，检查哪些依赖被使用，同时移除掉无用依赖。因此，如果你使用 ES module 方式的时候，webpack 帮你可以排除掉无用代码：</p><p>1.一个有多个 export 的文件，但是 app 只需要其中一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>2.Webpack 分析 <code>commentRestEndPoint</code> 没有被用到，就不会在一个 bundle 中生成单独的 export：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line">  <span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line">  <span class="comment">/* unused harmony export commentRestEndpoint */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.<a href="Enable minification 开启最小化">最小化工具</a>就会移除掉无用变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">n,e</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="keyword">var</span> r=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"Rendered!"</span>&#125;;e.b=r&#125;)</span><br></pre></td></tr></table></figure><p>如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。</p><blockquote><p>Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；<code>UglifyJSPlugin</code>才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：<a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify plugin</a> or <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler plugin</a>）</p></blockquote><blockquote><p>Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel <code>babel-preset-env</code> or <code>babel-preset-es2015</code>，检查一下当前的配置。默认情况下， ES <code>import</code> and <code>export</code> to CommonJS <code>require</code> and <code>module.exports</code>。通过设置 option 来禁止掉<a href="https://github.com/babel/babel/tree/master/experimental/babel-preset-env" target="_blank" rel="noopener">Pass the <code>{ modules: false }</code> option</a>。</p></blockquote><h5 id="Futher-reading-扩展阅读"><a href="#Futher-reading-扩展阅读" class="headerlink" title="Futher reading 扩展阅读"></a>Futher reading 扩展阅读</h5><ul><li><a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">“ES6 Modules in depth”</a> 深入理解 ES6 Modules</li><li>Webpack docs <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">about tree shaking</a> Webpack tree shaking 文档</li></ul><h3 id="Optimize-images-优化图片"><a href="#Optimize-images-优化图片" class="headerlink" title="Optimize images 优化图片"></a>Optimize images 优化图片</h3><p>图片基本会占局页面<a href="https://httparchive.org/reports/state-of-the-web?start=latest" target="_blank" rel="noopener">一半以上</a>体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。可以利用 <code>url-loader</code>，<code>svg-url-loader</code> 和 <code>image-webpack-loader</code> 来进行优化。</p><p><code>url-loader</code> 允许将小的静态文件打包进 app。没有配置的话，他需要通过传递文件，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明 <code>limit</code> 选项，它将会编码成更小的文件 base64 url 并返回这个 url。这样将图片放在 Javascript 代码中，可以节省 HTTP 的请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> imageUrl <span class="keyword">from</span> <span class="string">'./image.png'</span>;</span><br><span class="line"><span class="comment">// → If image.png is smaller than 10 kB, `imageUrl` will include</span></span><br><span class="line"><span class="comment">// the encoded image: 'data:image/png;base64,iVBORw0KGg…'</span></span><br><span class="line"><span class="comment">// → If image.png is larger than 10 kB, the loader will create a new file,</span></span><br><span class="line"><span class="comment">// and `imageUrl` will include its url: `/2fcd56a1920be.png`</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 内联图片减少了独立请求的数量，这是很好的方式（<a href="https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/" target="_blank" rel="noopener">even with HTTP/2</a>），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。</p></blockquote><p><code>svg-url-loader</code>与<code>url-loader</code>类似 - 都是将使用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding" target="_blank" rel="noopener">URL encoding</a>  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">        loader: <span class="string">'svg-url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// Remove the quotes from the url</span></span><br><span class="line">          <span class="comment">// (they’re unnecessary in most cases)</span></span><br><span class="line">          noquotes: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，<a href="https://github.com/bhovhannes/svg-url-loader#iesafe" target="_blank" rel="noopener">设置 iesafe: true 选项</a></p></blockquote><p><code>image-webpack-loader</code>压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。</p><p>这个 loader 不会将图片嵌入在应用内，因此它必须与<code>url-loader</code>和<code>svg-url-loader</code>配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用<code>enforce: pre</code>作为单独的一个 rule 涵盖这个 loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">        <span class="comment">// This will apply the loader before the other ones</span></span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认 loader 设置就已经可以满足需求了 - 但如果你想要深入配置，请查看 <a href="https://github.com/tcoopman/image-webpack-loader#options" target="_blank" rel="noopener">the plugin options</a>。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a></p><h5 id="Further-reading-扩展阅读-1"><a href="#Further-reading-扩展阅读-1" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li><a href="https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for" target="_blank" rel="noopener">“What is base64 encoding used for?”</a> Base64 编码究竟可以用在何处？</li><li>Addy Osmani’s <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a> Addy Osmani 的图片优化指南</li></ul><h3 id="Optimize-dependencies-优化依赖"><a href="#Optimize-dependencies-优化依赖" class="headerlink" title="Optimize dependencies 优化依赖"></a>Optimize dependencies 优化依赖</h3><p>平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。</p><p>举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大约 65 KB 代码没有用处。</p><p>另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。</p><p>所有这些依赖都可以被轻易优化。我们在 Github repo 收集了优化的建议，<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="noopener">check it out</a>！</p><h3 id="Enable-module-concatenation-for-ES-modules-aka-scope-hoisting-为-ES-modles-开启模块连接"><a href="#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting-为-ES-modles-开启模块连接" class="headerlink" title="Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接"></a>Enable module concatenation for ES modules (aka scope hoisting) 为 ES modles 开启模块连接</h3><blockquote><p>Note: 如果你在使用生产模式下的 webpack 4，modules concatention 已经开启，可以直接跳过本小节。</p></blockquote><p>当你构建 bundle 时，webpack 将每一个 module 封装进 function 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part  of)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_0__comments_js__[<span class="string">"a"</span> <span class="comment">/* render */</span>])();</span><br><span class="line"></span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在以前，这么做是使 CommonJS/AMD modules 互相分离所必须的。但是，这会增加体积并且性能表现堪忧。</p><p>Webpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用<a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener"><code>ModuleConcatenationPlugin</code></a>完成这样一个 bundle，下面是例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike the previous snippet, this bundle has only one module</span></span><br><span class="line"><span class="comment">// which includes the code from both files</span></span><br><span class="line"><span class="comment">// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bundle.js (part of; compiled with ModuleConcatenationPlugin)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./comments.js</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./index.js</span></span><br><span class="line">  render();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 <code>ModuleConcatenationPlugin</code>，<code>require</code>被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！</p><p>在 <strong>Webpack 4</strong> 中开启这个功能，启用 <code>optimization.concatenateModules</code> 选项即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <strong>webpack 3</strong> 中，使用 <code>ModuleConcatenationPlugin</code> 插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， <a href="https://twitter.com/TheLarkInn/status/925800563144454144" target="_blank" rel="noopener">但是他会增加编译的时间同时破坏 module 的热更新</a>。这就是为什么只在生产环境中启用的原因了。</p></blockquote><h4 id="Further-reading-扩展阅读-2"><a href="#Further-reading-扩展阅读-2" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul><li>Webpack docs <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">for the ModuleConcatenationPlugin</a> ModuleConcatenationPlugin 文档</li><li><a href="https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f" target="_blank" rel="noopener">“Brief introduction to scope hoisting”</a></li><li>Detailed description of <a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="noopener">what this plugin does</a> 详述这些插件做了些什么</li></ul><h3 id="Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals"><a href="#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals" class="headerlink" title="Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals"></a>Use <strong>externals</strong> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</h3><p>你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：</p><p><img src="https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png" alt="video-hosting"></p><p>如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。<a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">the webpack’s <code>externals</code> option</a>就干了这件事 - 它用变量或者外部引用来替代 modules。</p><h4 id="如果依赖是挂载到-window-上的情况"><a href="#如果依赖是挂载到-window-上的情况" class="headerlink" title="如果依赖是挂载到 window 上的情况"></a>如果依赖是挂载到 window 上的情况</h4><p>如果你的非 webpack 代码依靠这些依赖，它们是挂载 window 上的变量，可以将依赖名称 alias 成变量名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: <span class="string">'React'</span>,</span><br><span class="line">    <span class="string">'react-dom'</span>: <span class="string">'ReactDOM'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用这个配置，webpack 将不会打包 <code>react</code> 和 <code>react-dom</code> 包。取而代之，他们会被替换成下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.React`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole React bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = React;</span><br><span class="line">&#125;),</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.ReactDOM`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole ReactDOM bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = ReactDOM;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="如果依赖是当做-AMD-包被加载的情况"><a href="#如果依赖是当做-AMD-包被加载的情况" class="headerlink" title="如果依赖是当做 AMD 包被加载的情况"></a>如果依赖是当做 AMD 包被加载的情况</h4><p>如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。</p><p>具体如何做呢？将 webpack 代码编译成一个 AMD module 同时别名成一个库的 URLs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123; <span class="attr">libraryTarget</span>: <span class="string">'amd'</span> &#125;,</span><br><span class="line"></span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react.min.js'</span> &#125;,</span><br><span class="line">    <span class="string">'react-dom'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react-dom.min.js'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 将会把 bundle 包装进 <code>define()</code>同时让它依赖于这些URLs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (beginning)</span></span><br><span class="line">define([<span class="string">"/libraries/react.min.js"</span>, <span class="string">"/libraries/react-dom.min.js"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; … &#125;);</span><br></pre></td></tr></table></figure><p>如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。</p><blockquote><p>Note：webpack 只是替换那些 <code>externals</code> 对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写<code>import React from &#39;react/umd/react.production.min.js&#39;</code>，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 <code>import &#39;react&#39;</code> 和 <code>import &#39;react/umd/react.production.min.js&#39;</code> 是同一个库，这样比较谨慎。</p></blockquote><h5 id="Further-reading-扩展阅读-3"><a href="#Further-reading-扩展阅读-3" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li>Webpack docs <a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">on <code>externals</code></a> externals 文档</li></ul><h3 id="Summing-up-总结"><a href="#Summing-up-总结" class="headerlink" title="Summing up 总结"></a>Summing up 总结</h3><ul><li>Enable the production mode if you use webpack 4 如果使用 webpack 4 开启生产模式</li><li>Minimize your code with the bundle-level minifier and loader options 使用 bundle 级别最小化 和 loader 选项来最小化你的代码</li><li>Remove the development-only code by replacing <code>NODE_ENV</code> with <code>production</code> 通过将 <code>NODE_ENV</code> 替换成 <code>production</code> 来移除开发期间代码</li><li>Use ES modules to enable tree shaking 启用 tree shaking</li><li>Compress images 压缩图片</li><li>Apply dependency-specific optimizations 开启依赖优化</li><li>Enable module concatenation 开启 module 连接</li><li>Use <code>externals</code> if this makes sense for you 如果有效果的话可以使用 <code>externals</code></li></ul><hr><h2 id="Make-use-of-long-term-caching-利用好长时缓存"><a href="#Make-use-of-long-term-caching-利用好长时缓存" class="headerlink" title="Make use of long-term caching 利用好长时缓存"></a>Make use of long-term caching 利用好长时缓存</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分，这样会在每一次请求中减少重新下载的次数。</p><h3 id="Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息"><a href="#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息" class="headerlink" title="Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息"></a>Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</h3><p>做缓存通用的解决办法：</p><p>1.告诉浏览器缓存一个文件很长时间（比如一年）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Server header</span><br><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Note：如果你不熟悉 <code>Cache-Control</code> 做了什么，你可以看一下 Jake Archibald 的精彩博文 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">on caching best practices</a></p><p>2.当文件改变需要强制重新下载时去重命名这些文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Before the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v15.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- After the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v16.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些方法可以告诉浏览器下载这些 JS 文件，将其缓存起来。浏览器将只会在文件名发生改变时才会请求网络（或者缓存失效的情况也会请求）。</p><p>使用 webpack，也可以做同样的事，但可以使用版本号来解决，需要明确这个文件的 hash 值。使用 <a href="https://webpack.js.org/configuration/output/#output-filename" target="_blank" rel="noopener"><code>[chunkhash]</code></a> 可以将 <code>hash</code> 值包含进文件名中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">        <span class="comment">// → bundle.8e0d62a03.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: webpack 可能会生成不同的 hash 即使 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 <a href="https://github.com/webpack/webpack/issues/1479" target="_blank" rel="noopener">This is a bug.</a><br>如果你需要将文件名发送给客户端，也可以使用 <code>HtmlWebpackPlugin</code> 或者 <code>WebpackManifestPlugin</code>。</p></blockquote><p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 使用起来很简单，但灵活性有一些欠缺。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.8e0d62a03.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>WebpackManifestPlugin</code> 更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundle.js"</span>: <span class="string">"bundle.8e0d62a03.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Further-reading-扩展阅读-4"><a href="#Further-reading-扩展阅读-4" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li>Jake Archibald <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">about caching best practices</a> cache 的最佳实践</li></ul><h3 id="Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件"><a href="#Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件" class="headerlink" title="Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件"></a>Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件</h3><h4 id="Dependencies-依赖"><a href="#Dependencies-依赖" class="headerlink" title="Dependencies 依赖"></a>Dependencies 依赖</h4><p>App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。</p><blockquote><p>Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 <code>chunks</code>。我们后面会用到这个名词。</p></blockquote><p>为了将依赖包提取到单独的 chunk 中，下面分为三步：</p><p>1.使用 <code>[name].[chunkname].js</code> 替换<code>output</code>的文件名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// Before</span></span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">    <span class="comment">// After</span></span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换 <code>[name]</code>。如果没有添加 <code>[name]</code> 部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太困难了！</p><p>2.将 <code>entry</code> 转成一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// Before</span></span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  <span class="comment">// After</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 <code>[name]</code>代替。</p><p>目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。</p><p>3.在 <strong>Webpack 4</strong> 中，在配置中增加 <code>optimization.splitChunks.chunks: &#39;all&#39;</code> 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个选项会开启智能代码拆分。使用这个功能，webpack 将最小化和 Gzip 前大于 30KB 的代码提取出额外的 <code>vendor</code> 代码。它同时也会提取出 common 代码 - 这些代码在打包多个 bundles 会起到作用。（例如：<a href="#Split the code into routes and pages 拆分代码到路由和页面中">通过路由拆分应用</a>）。</p><p>在 <strong>Webpack 3</strong> 中，使用 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a> 插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the dependencies.</span></span><br><span class="line">      <span class="comment">// This name is substituted in place of [name] from step 1</span></span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A function that determines which modules to include into this chunk</span></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插件将包括全部 <code>node_modules</code> 路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 <code>vendor.[chunkhash].js</code>。</p><p>完成了上面的步骤，每一次 build 都会生成两个文件。浏览器会将他们单独缓存 - 以便代码发生改变时重新下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><h4 id="Webpack-runtime-code-运行时代码"><a href="#Webpack-runtime-code-运行时代码" class="headerlink" title="Webpack runtime code 运行时代码"></a>Webpack runtime code 运行时代码</h4><p>不幸的是，仅仅抽取 <code>vendor</code> 是不够的。如果你试图在应用代码中修改一些东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. add this:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Wat'</span>);</span><br></pre></td></tr></table></figure><p>你会注意到 <code>vendor</code> 的也会改变：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                            Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><p>这因为 webpack 打包时，一部分 modules 的代码，拥有 <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener"><em>a runtime</em></a> - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor.e6ea4504d61a1cc1c60b.js</span></span><br><span class="line">script.src = __webpack_require__.p + chunkId + <span class="string">"."</span> + &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"2f2269c7f0a55a5c1871"</span></span><br><span class="line">&#125;[chunkId] + <span class="string">".js"</span>;</span><br></pre></td></tr></table></figure><p>Webpack 将最新生成的 chunk 包含在这个 runtime 内，这个 chunk 就是我们代码中的 <code>vendor</code>。与此同时每一次任何 <code>chunk</code> 的修改，即使这一小部分代码也改变，也会导致整个 <code>vendor</code> <code>chunk</code> 改变。</p><p>为了解决这个问题，我们将 runtime 转义到一个独立的文件中，在 <strong>Webpack 4</strong> 中，开启 <code>optimization.runtimeChunk</code> 选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>Webpack 3</strong>中，通过 <code>CommonsChunkPlugin</code> 创建一个额外的空的 chunk：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This plugin must come after the vendor one (because webpack</span></span><br><span class="line">    <span class="comment">// includes runtime into the last chunk)</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// minChunks: Infinity means that no app modules</span></span><br><span class="line">      <span class="comment">// will be included into this chunk</span></span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成这一部分改变，每一次 build 都将生成三个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>将他们反过来顺序添加到 index.html 中，你就搞定了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vendor.26886caf15818fa82dfa.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.00bab6fd3100008a42b0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Further-reading-扩展阅读-5"><a href="#Further-reading-扩展阅读-5" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li>Webpack guide <a href="https://webpack.js.org/guides/caching/" target="_blank" rel="noopener">on long term caching</a> webpack 关于 cache 指南</li><li>Webpack docs <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener">about webpack runtime and manifest</a> webpack 关于 runtime and manifest 文档</li><li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a> 使用 CommonsChunkPlugin 的最佳实践</li></ul><h3 id="Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求"><a href="#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求" class="headerlink" title="Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求"></a>Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP 请求</h3><p>为了做的更好，我们可以尽力把 webpack runtime 内联在 HTML 请求里。下面举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">if</span>(t[r])<span class="keyword">return</span> t[r].exports;…&#125;&#125; ([]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。</p><p>下面就来看看如何做。</p><h4 id="如果使用-HtmlWebpackPlugin-来生成-HTML"><a href="#如果使用-HtmlWebpackPlugin-来生成-HTML" class="headerlink" title="如果使用 HtmlWebpackPlugin 来生成 HTML"></a>如果使用 HtmlWebpackPlugin 来生成 HTML</h4><p>如果使用 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 来生成 HTML 文件，<a href="https://github.com/rohitlodha/html-webpack-inline-chunk-plugin" target="_blank" rel="noopener"><code>InlineChunkWebpackPlugin</code></a> 就足够了。</p><h4 id="如果使用自己的定制服务逻辑来生成-HTML"><a href="#如果使用自己的定制服务逻辑来生成-HTML" class="headerlink" title="如果使用自己的定制服务逻辑来生成 HTML"></a>如果使用自己的定制服务逻辑来生成 HTML</h4><h5 id="Webpack-4"><a href="#Webpack-4" class="headerlink" title="Webpack 4"></a><strong>Webpack 4</strong></h5><p>1.增加 <a href="https://github.com/danethurber/webpack-manifest-plugin" target="_blank" rel="noopener">WebpackManifestPlugin</a> 插件已知运行时 chunk:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="keyword">const</span> ManifestPlugin = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ManifestPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插件就会生成一个下面这样的文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"runtime~main.js"</span>: <span class="string">"runtime~main.8e0d62a03.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.将这些内容嵌入到 runtime chunk 中。例如：使用 Node.js 和 Express：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> manifest = <span class="built_in">require</span>(<span class="string">'./manifest.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> runtimeContent = fs.readFileSync(manifest[<span class="string">'runtime~main.js'</span>], <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Webpack-3"><a href="#Webpack-3" class="headerlink" title="Webpack 3"></a><strong>Webpack 3</strong></h5><p>1.将 <code>runtime</code> 名称改成静态的明确的文件名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">      filename: <span class="string">'runtime.js'</span>,</span><br><span class="line">        <span class="comment">// → Now the runtime file will be called</span></span><br><span class="line">        <span class="comment">// “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.嵌入到 runtime.js 内容。比如：Node.js 和 Express</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> runtimeContent = fs.readFileSync(<span class="string">'./runtime.js'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Lazy-load-code-that-you-don’t-need-right-now-懒加载"><a href="#Lazy-load-code-that-you-don’t-need-right-now-懒加载" class="headerlink" title="Lazy-load code that you don’t need right now 懒加载"></a>Lazy-load code that you don’t need right now 懒加载</h3><p>通常情况下，一个页面有或多或少的重要部分：</p><ul><li>如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。</li><li>如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。</li></ul><p>在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">the <code>import()</code> function</a> 和 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code-splitting</a> 解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// videoPlayer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderVideoPlayer</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderComments</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderVideoPlayer&#125; <span class="keyword">from</span> <span class="string">'./videoPlayer'</span>;</span><br><span class="line">renderVideoPlayer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// …Custom event listener</span></span><br><span class="line">onShowCommentsClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./comments'</span>).then(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">    comments.renderComments();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>明确表示你期望动态地加载独立的 module。当 webpack 看到 <code>import(&#39;./module.js&#39;)</code>时，他就会将这个 module 移到独立的 chunk 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 39b2a53cb4e73f0dc5b2</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>并且只在代码执行到 <code>import()</code> 才会下载。</p><p>这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。</p><blockquote><p>Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 <em>import()</em> 而遇到语法错误抛出来。可以使用 <a href="https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener"><code>syntax-dynamic-import</code></a> 解决这个错误。</p></blockquote><h5 id="Further-reading-扩展阅读-6"><a href="#Further-reading-扩展阅读-6" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li>Webpack docs <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">for the <code>import()</code> function</a>  webpack 中 import() 文档</li><li>The JavaScript proposal <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">for implementing the <code>import()</code> syntax</a></li></ul><h3 id="Split-the-code-into-routes-and-pages-拆分代码到路由和页面中"><a href="#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中" class="headerlink" title="Split the code into routes and pages 拆分代码到路由和页面中"></a>Split the code into routes and pages 拆分代码到路由和页面中</h3><p>如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：</p><p><img src="https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png" alt="site-home-page"></p><p>他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。</p><p>如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会只下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。</p><h4 id="For-single-page-apps-对于单页面应用"><a href="#For-single-page-apps-对于单页面应用" class="headerlink" title="For single-page apps 对于单页面应用"></a>For single-page apps 对于单页面应用</h4><p>通过路由拆分带页面引用，使用 <code>import()</code>（看看 <a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading" target="_blank" rel="noopener">“Lazy-load code that you don’t need right now”</a>这部分）。如果你在使用一个框架，现在已经有成熟的方案：</p><ul><li><a href="https://reacttraining.com/react-router/web/guides/code-splitting" target="_blank" rel="noopener">“Code Splitting”</a> in <code>react-router</code>‘s docs (for React)</li><li><a href="https://router.vuejs.org/en/advanced/lazy-loading.html" target="_blank" rel="noopener">“Lazy Loading Routes”</a> in <code>vue-router</code>‘s docs (for Vue.js)</li></ul><h4 id="For-traditional-multi-page-apps-对于传统的多页面应用"><a href="#For-traditional-multi-page-apps-对于传统的多页面应用" class="headerlink" title="For traditional multi-page apps 对于传统的多页面应用"></a>For traditional multi-page apps 对于传统的多页面应用</h4><p>通过页面拆分传统多页面应用，可以使用 webpack 的 <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener"><em>entry points</em></a> 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/Home/index.js'</span>,</span><br><span class="line">    article: <span class="string">'./src/Article/index.js'</span>,</span><br><span class="line">    profile: <span class="string">'./src/Profile/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 318d7b8490a7382bf23b</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home</span><br><span class="line">./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article</span><br><span class="line">./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor</span><br><span class="line">./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>因此，如果仅仅是文章页使用 <em>Lodash</em> ，<em>home</em> 和 <em>profile</em> 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。</p><p>拆分依赖树也有缺点。如果两个 entry points 都用到了 <em>loadash</em> ，同时你没有在 <em>vendor</em> 移除掉依赖，两个 entry points 将包括两个重复的 <em>lodash</em> 。在 <strong>Webpack 4</strong> 中我们可以设置 <code>optimization.splitChunks.chunks: &#39;all&#39;</code> 解决该问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 4)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个选项可以开启智能拆分代码，webpack 将自动寻找 common code 并将其提取到一个单独的文件中。</p><p>在 <strong>Webpack 3</strong> 可以使用<a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a>来解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js (for webpack 3)</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the common dependencies</span></span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The plugin will move a module into a common file</span></span><br><span class="line">      <span class="comment">// only if it’s included into `minChunks` chunks</span></span><br><span class="line">      <span class="comment">// (Note that the plugin analyzes all chunks, not only entries)</span></span><br><span class="line">      minChunks: <span class="number">2</span>,    <span class="comment">// 2 is the default value</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随意使用<code>minChunks</code>的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，<code>minChunks</code> 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。</p><h4 id="Further-reading-扩展阅读-7"><a href="#Further-reading-扩展阅读-7" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul><li>Webpack docs <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">about the concept of entry points</a> webpack 关于入口概念的文档</li><li>Webpack docs <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">about the CommonsChunkPlugin</a> webpack 关于 CommonChunkPlugin 插件的文档</li><li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a></li></ul><h3 id="Make-module-ids-more-stable-使用稳定的-module-ids"><a href="#Make-module-ids-more-stable-使用稳定的-module-ids" class="headerlink" title="Make module ids more stable 使用稳定的 module ids"></a>Make module ids more stable 使用稳定的 module ids</h3><p>当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被 <code>require()</code> 引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[4] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[5] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line"> + 1 hidden module</span><br></pre></td></tr></table></figure><p>默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]</span><br><span class="line">   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br><span class="line">   [0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ 我们增加一个新 module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ 现在看这里做了什么！ <code>comments.js</code> 现在的 ID 由 4 变成了 5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5] ./comments.js 58 kB &#123;0&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ <code>ads.js</code> 的 ID 由 5 变成 6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[6] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">       + 1 hidden module</span><br></pre></td></tr></table></figure><p>这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_ 这个 chunk 和 <em>main</em> chunk 都会失效 - 只有 <em>main</em> 才应该失效。</p><p>使用<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener"><code>HashedModuleIdsPlugin</code></a>插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[3IRH] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br><span class="line">[lebJ] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[02Tr] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">    + 1 hidden module</span><br></pre></td></tr></table></figure><p>有了这个方法，只有你重命名或者删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。</p><p>启用这个插件，在配置中增加 <em>plugins</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Further-reading-扩展阅读-8"><a href="#Further-reading-扩展阅读-8" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h5><ul><li>Webpack docs <a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener">about the HashedModuleIdsPlugin</a> HashModuleIdsPlugin 插件文档</li></ul><h3 id="Summing-up"><a href="#Summing-up" class="headerlink" title="Summing up"></a>Summing up</h3><ul><li>Cache the bundle and differentiate between versions by changing the bundle name 缓存 bundle 包并通过修改 bundle 名称来做版本差异</li><li>Split the bundle into app code, vendor code and runtime 将 bundle 拆分成 app 业务代码、vendor 代码、runtime 代码</li><li>Inline the runtime to save an HTTP request 将 runtime 代码内联节省 HTTP 请求</li><li>Lazy-load non-critical code with <code>import</code> 通过 import 懒加载非必要代码</li><li>Split code by routes/pages to avoid loading unnecessary stuff 通过路由或页面拆分阻止加载不必要代码</li></ul><hr><h2 id="Monitor-and-analyze-the-app-监控并分析"><a href="#Monitor-and-analyze-the-app-监控并分析" class="headerlink" title="Monitor and analyze the app 监控并分析"></a>Monitor and analyze the app 监控并分析</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>即使当你配置好你的 webpack 让你的应用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！</p><p>这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。</p><h3 id="Keep-track-of-the-bundle-size-跟踪打包的体积"><a href="#Keep-track-of-the-bundle-size-跟踪打包的体积" class="headerlink" title="Keep track of the bundle size 跟踪打包的体积"></a>Keep track of the bundle size 跟踪打包的体积</h3><p>在开发时可以使用<a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>和命令行<a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 来监控 app 的体积。</p><h4 id="webpack-dashboard"><a href="#webpack-dashboard" class="headerlink" title="webpack-dashboard"></a>webpack-dashboard</h4><p><a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。</p><p><img src="http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png" alt="webpack-dashboard"></p><p>这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！</p><p>启用这个功能，需要安装 <em>webpack-dashboard</em> 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dashboard --save-dev</span><br></pre></td></tr></table></figure><p>同时在配置的 plugins 增加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> DashboardPlugin = <span class="built_in">require</span>(<span class="string">'webpack-dashboard/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DashboardPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者如果正在使用基于 Express dev server 可以使用 <code>compiler.apply()</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.apply(new DashboardPlugin());</span><br></pre></td></tr></table></figure><p>多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。</p><h4 id="bundlesize"><a href="#bundlesize" class="headerlink" title="bundlesize"></a>bundlesize</h4><p><a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：</p><p><img src="https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg" alt="bundlesize"></p><p>配置如下：</p><h5 id="Find-out-the-maximum-sizes-找出最大体积"><a href="#Find-out-the-maximum-sizes-找出最大体积" class="headerlink" title="Find out the maximum sizes 找出最大体积"></a><strong>Find out the maximum sizes</strong> 找出最大体积</h5><p>1.分析 app 尽可能减小体积，执行生产环境的 build。<br>2.在<code>package.json</code>中增加<code>bundlesize</code>部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用<code>npx</code>执行<code>bundlesize</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx bundlesize</span><br></pre></td></tr></table></figure><p>它就会将每一个文件的 gzip 压缩后的体积打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB</span><br></pre></td></tr></table></figure><p>4.每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。</p><h5 id="Enable-bundlesize-启用-bundlesize"><a href="#Enable-bundlesize-启用-bundlesize" class="headerlink" title="Enable bundlesize 启用 bundlesize"></a><strong>Enable <code>bundlesize</code></strong> 启用 bundlesize</h5><p>5.安装<em>bundlesize</em>开发依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bundlesize --save-dev</span><br></pre></td></tr></table></figure><p>6.在<code>package.json</code>中的<code>bundlesize</code>部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*.png"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"16 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/main.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"20 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/vendor.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"35 kB"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.增加一个 npm 脚本来执行检查：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"check-size"</span>: <span class="string">"bundlesize"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.配置自动化 CI 来在每一次 push 时执行<code>npm run check-size</code>做检查。（如果你在 Github 上开发项目，直接可以使用<a href="https://github.com/siddharthkp/bundlesize#2-build-status" target="_blank" rel="noopener">integrate <code>bundlesize</code> with GitHub</a>。）</p><p>这就全部了！现在如果你运行<code>npm run check-size</code>或者 push 代码，你就会看到输出的文件是否足够小：</p><p><img src="https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png" alt="bundlesize-output-success"></p><p>或者下面失败的情况</p><p><img src="https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png" alt="bundlesize-output-failure"></p><h4 id="Further-reading-扩展阅读-9"><a href="#Further-reading-扩展阅读-9" class="headerlink" title="Further reading 扩展阅读"></a>Further reading 扩展阅读</h4><ul><li>Alex Russell <a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">about the real-world loading time we should target</a></li></ul><h3 id="Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大"><a href="#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大" class="headerlink" title="Analyze why the bundle is so large 分析 bundle 为什么这么大"></a>Analyze why the bundle is so large 分析 bundle 为什么这么大</h3><p>你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a></p><blockquote><p>译者注：此处有<a href="https://developers.google.com/web/fundamentals/performance/webpack/webpack-bundle-analyzer.mp4" target="_blank" rel="noopener">视频</a>，需要科学上网，请自行观看</p></blockquote><p>(Screen recording from <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">github.com/webpack-contrib/webpack -bundle-analyzer</a>)</p><p>webpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。</p><p>使用这个分析器，需要安装<code>webpack-bundle-analyzer</code>包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure><p>在 config 中增加插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行生产环境的 build 这个插件就会在浏览器中打开一个显示状态的页面。</p><p>默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。</p><blockquote><p>Note: 如果你使用 <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">ModuleConcatenationPlugin</a>，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。</p></blockquote><p>下面是报告中需要看什么：</p><ul><li><strong>Large dependencies 大型依赖</strong> 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 <a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment" target="_blank" rel="noopener">that are often not used and could be dropped</a>）？</li><li><strong>Duplicated dependencies 重复依赖</strong> 是否在不同文件中看到过相同的库？（在 <strong>Webpack 4</strong> 中配置 <code>optimization.splitChunks.chunks</code>，或者在 <strong>Webpack 3</strong>中 使用 <em>CommonsChunkPlugin</em> 将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？</li><li><strong>Similar dependencies 相似依赖</strong> 是否存在有相似功能的相似库存在？（比如<em>moment</em>和<em>date-fns</em> 或者 <em>lodash</em> 和 <em>lodash-es</em>）尽力汇总成一个。</li></ul><p>同样的，也可以看看 Sean Larkin 的文章 <a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">great analysis of webpack bundles</a>。</p><h3 id="Summing-up-小结"><a href="#Summing-up-小结" class="headerlink" title="Summing up 小结"></a>Summing up 小结</h3><ul><li>Use <code>webpack-dashboard</code> and <code>bundlesize</code> to stay tuned of how large your app is</li><li>Dig into what builds up the size with <code>webpack-bundle-analyzer</code></li></ul><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总结：</p><ul><li><strong>剔除不必要的体积</strong> 把所有的代码都压缩最小化，剔除无用代码，增加依赖时保持谨慎小心。</li><li><strong>通过路由拆分代码</strong> 只在真正需要的时候才加载，其余部分做懒加载。</li><li><strong>缓存代码</strong> 应用程序某些部分代码更新频率低于其他部分代码，可以将这些部分拆分成文件，以便在必要时仅重新下载。</li><li><strong>跟踪体积大小</strong> 使用  <a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a> 和 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> 监控你的 app。每隔几个月重新检查一下你的应用的性能。</li></ul><p>Webpack 不仅仅是一个帮助你更快创建 app 的工具。它还帮助使你的 app 成为 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">a Progressive Web App</a> ，你的应用拥有更好的体验以及自动化的填充工具就像<a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="noopener">Lighthouse</a>根据环境给出建议。</p><p>不要忘记阅读 <a href="https://webpack.js.org/guides/" target="_blank" rel="noopener">webpack docs</a> - 里面提供了大量的优化相关的信息。</p><p>多多练习 <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener">with the training app</a>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者 &lt;a href=&quot;https://developers.google.com/web/resources/contributors/addyosmani&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Addy Osmani&lt;/a&gt;，&lt;a href=&quot;https://developers.google.com/web/resources/contributors/iamakulov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ivan Akulov&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/webpack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/web/fundamentals/performance/webpack/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS. 在 20180211 笔者翻译过一次，当时也没有完全理解和使用文中提到的优化项，近期工作中因为用到 Webpack 4.x 对生产环境进行打包，加深了一些理解，本译文对原有译文补充的 Webpack 4 内容，同时对原译文进行了校对和一些细节措辞的修改。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="https://beanlee.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Webpack" scheme="https://beanlee.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>【译】Webpack 4 mode and optimization</title>
    <link href="https://beanlee.github.io/2018/04/18/blog-translate-webpack-4-mode-and-optimization/"/>
    <id>https://beanlee.github.io/2018/04/18/blog-translate-webpack-4-mode-and-optimization/</id>
    <published>2018-04-18T06:26:11.000Z</published>
    <updated>2018-04-18T09:15:50.273Z</updated>
    
    <content type="html"><![CDATA[<p>原文 <a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a</a></p><p>作者 <a href="https://medium.com/@sokra" target="_blank" rel="noopener">Tobias Koppers</a></p><p>webpack 增加了一个模式配置（mode option）。下面来解释一下具体内容。</p><a id="more"></a><p><img src="https://img14.360buyimg.com/uba/s750x500_jfs/t17446/171/1782320374/354853/1568df4e/5ad6eac5Na2c1d8ee.jpg!cc_2x1" alt=""></p><p>webpack 4 增加了一个<code>模式</code>选项（<code>mode</code> option）。<strong>并且这个配置是必须存在的</strong>。（实际上它不是必须的配置项，但如果你省略掉没有配就会有警告。）</p><p>webpack 4 目前有<strong>两个默认配置</strong>，<code>development</code> 和 <code>production</code> 。这两个值可以在 <code>mode</code> 中设置。</p><p>设置 <code>development</code> 将会带给你最好*的开发体验，它专注于以下几点：</p><ul><li>浏览器 debug 工具</li><li>开发周期内的快速增量编译</li><li>运行时有用的错误信息</li></ul><p>（*实际上这里指最好的体验取决于你使用的方式，我们尽力在这里囊括了大多数通用部分）</p><p>设置 <code>production</code> 将会带给你在发布应用时的一系列有用的默认设置，它专注于以下几点：</p><ul><li>更小的输出包尺寸</li><li>运行时高效的代码</li><li>忽略掉只在开发时启用（<code>development-only</code>）的代码</li><li>不会暴露源码或者文件路径</li><li>简化使用打包后资源过程</li></ul><p>最后一点非常重要。它基本意味着 <code>production</code> 会提供给你优化后的资源包，但这不是完美的优化有的资源包。这里还存在着很多可优化点，但是它们会让结果更难使用。这些优化点是有意被忽略的，因为在这里，我们更看重入门的体验高于完美的优化。大部分优化点也只在大型应用上起作用。</p><hr><p>随着这个 <code>mode</code> 配置的引入，我们尝试去减少 build 时必要配置。我们尝试着去用一些默认项去覆盖通用的配置。</p><p>然而从我们的经验来看我们也知道默认配置并不适用于所有人。不同的团队有不同的需求，有时候会因为遗留代码、有时候会因为个人喜好、有时候会因为特殊的应用或者有时候使用者会认为这并不是最好通用解决方案。许多人确实想要修改默认配置以适应他们自己的项目。We got you covered. 增加 <code>mode</code> 并不意味这我们移除掉了这些配置。这里面仍然是一切皆可配置。实际上我们使内部大多数优化都是可配置的（你可以禁用掉他们）。</p><p><code>mode</code> 选项是通过在配置中设置默认项实现的。这个不会被其他配置执行的 <code>mode</code> 也不会做任何行为。</p><p>下一部分就会更深入地讨论因为<code>mode</code>或其他选项而影响的配置。</p><hr><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h3><p>在 <code>development</code> 模式下默认是 <code>eval</code>。否则不使用 devtool。</p><p><code>eval</code> devtool 没有提供最佳的质量，但是拥有很好的性能。这就是我们选择的折中方案。看一看这些配置的文档，这可以获取更高质量的 sourcemap。</p><ul><li>📉📉📉缺点：慢，bundle 体积大</li><li>📈📈📈优点：优化 debug 的体验</li></ul><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>只在 <code>development</code> 模式下启用，否则禁用缓存。</p><p>缓存模块可以避免在没有改变时重建。</p><p>在内存缓存只在 <code>watch</code> 模式下有用，并且我们假设你在开发时正在使用 <code>watch</code> 模式。不用缓存时，内存占用率更低。</p><ul><li>📉缺点：内存占用</li><li>📈📈📈优点：更快的增量编译</li></ul><h3 id="module-unsafeCache"><a href="#module-unsafeCache" class="headerlink" title="module.unsafeCache"></a>module.unsafeCache</h3><p>只在 <code>cache</code> 启用时启用，否则禁用。</p><p>缓存机械依赖项可以避免重新解析它们。</p><ul><li>📉缺点：内存占用，缓存入口可能错误</li><li>📈📈📈优点：更快的增量编译</li></ul><h3 id="output-pathinfo"><a href="#output-pathinfo" class="headerlink" title="output.pathinfo"></a>output.pathinfo</h3><p>只在 <code>development</code> 模式下启用，否则禁用。</p><p>这些额外的注释对于 debug 很有作用，尤其是使用 <code>eval</code> devtool。</p><ul><li>📉缺点：bundle 体积大，暴露路径信息</li><li>📈优点：提升生成代码的可阅读性</li></ul><h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><p>只在 <code>production</code> 模式下启用，否则禁用。</p><p>体积限制只对最小化资源起作用，同时伴随着性能开销。因此它只在生产模式下启用。</p><ul><li>📉缺点：算法消耗</li><li>📈优点：对打包 bundle 体积大小产出警告</li></ul><h3 id="optimization-removeAvailableModules"><a href="#optimization-removeAvailableModules" class="headerlink" title="optimization.removeAvailableModules"></a>optimization.removeAvailableModules</h3><p>总是开启。</p><p>当他们在父级 chunk groups 中都可用时，这些模块会被移除掉。它可以减少资源包的体积。因为有更少的代码生成，更小的资源包就意味着更快的 build 过程。</p><ul><li>📉📉缺点：算法消耗</li><li>📈📈📈优点：bundle 体积优化</li></ul><h3 id="optimization-removeEmptyChunks"><a href="#optimization-removeEmptyChunks" class="headerlink" title="optimization.removeEmptyChunks"></a>optimization.removeEmptyChunks</h3><p>总是开启。</p><p>空 chunks 会被移除掉。这些在文件系统中减少 load 会导致更快的 build。</p><ul><li>📉缺点：算法消耗</li><li>📈📈📈优点：更少的请求</li></ul><h3 id="optimization-mergeDuplicateChunks"><a href="#optimization-mergeDuplicateChunks" class="headerlink" title="optimization.mergeDuplicateChunks"></a>optimization.mergeDuplicateChunks</h3><p>总是开启。</p><p>相等的 chunks 会被合并。结果就是更少的生成代码，更快的 build。</p><ul><li>📉缺点：算法消耗</li><li>📈📈📈优点：更少的请求和下载</li></ul><h3 id="optimization-flagIncludedChunks"><a href="#optimization-flagIncludedChunks" class="headerlink" title="optimization.flagIncludedChunks"></a>optimization.flagIncludedChunks</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>确定作为其他 chunks 子集的 chunks，并且这样方式对齐标记，即当加载较大 chunks 时，不必加载子集。</p><ul><li>📉缺点：算法消耗</li><li>📈📈📈优点：更少的请求和下载</li></ul><h3 id="optimization-occurrenceOrder"><a href="#optimization-occurrenceOrder" class="headerlink" title="optimization.occurrenceOrder"></a>optimization.occurrenceOrder</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>提供更常用的 ids 更小（更短）的值。</p><ul><li>📉缺点：算法消耗</li><li>📈优点：bundle 体积优化</li></ul><h3 id="optimization-providedExports"><a href="#optimization-providedExports" class="headerlink" title="optimization.providedExports"></a>optimization.providedExports</h3><p>总是开启。</p><p>尽可能地确定每一个 module 的 exports。这个信息被用于其他优化或者生成代码。为了消除歧义：为 <code>export * from</code> 生成更有效率的代码。</p><ul><li>📉缺点：算法消耗</li><li>📈优点：bundle 体积优化，其他优化需求</li></ul><h3 id="optimization-usedExports"><a href="#optimization-usedExports" class="headerlink" title="optimization.usedExports"></a>optimization.usedExports</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>尽可能地确定每一个 module 的 exports。它依赖于 <code>optimization.providedExports</code>。这个信息被用于其他优化或者生成代码。消除歧义：导出不会生成无用的 exports， 当所有的用途都被兼容的时候导出 names 就是零碎的单独字符定义。在最小化中 DCE 会有一处，同时移除掉无用的 exports。</p><ul><li>📉📉缺点：算法消耗</li><li>📈📈优点：bundle 体积优化</li></ul><h3 id="optimization-sideEffects"><a href="#optimization-sideEffects" class="headerlink" title="optimization.sideEffects"></a>optimization.sideEffects</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>认可在 <code>package.json</code> 或 <code>rules</code> 中的 <code>sideEffects</code> 标志去消除 modules。 它依赖 <code>optimization.providedExports</code>  和 <code>optimization.usedExports</code>。这些依赖都有所开销，但是消除依赖通过减少生成代码在性能上有积极的影响。它也依赖于你自己的代码。为了更好的性能，去尝试吧。</p><ul><li>📉缺点：算法消耗</li><li>📈📈📈优点：bundle 体积优化，更少生成代码</li></ul><h3 id="optimization-concatenateModules"><a href="#optimization-concatenateModules" class="headerlink" title="optimization.concatenateModules"></a>optimization.concatenateModules</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>尝试查找模块图中可以安全连接到单个模块中的段。它依赖于<code>optimization.providedExports</code> 和 <code>optimization.usedExports</code>。</p><ul><li>📉📉📉缺点：额外的语法分析，作用域分析和定义重命名</li><li>📈📈📈优点：运行时性能、bundle 体积优化</li></ul><h3 id="optimization-splitChunks"><a href="#optimization-splitChunks" class="headerlink" title="optimization.splitChunks"></a>optimization.splitChunks</h3><p>总是开启。</p><p>查找在 chunks 之间哪些 module 被共享，同时将他们拆分到独立的 chunks 中，目的是减少重复或者从 application modules 中分离 vendor modules。</p><ul><li>📉缺点：算法消耗，额外的请求</li><li>📈📈📈优点：更少生成代码，更好的缓存，更少的下载请求</li></ul><h3 id="optimization-runtimeChunk"><a href="#optimization-runtimeChunk" class="headerlink" title="optimization.runtimeChunk"></a>optimization.runtimeChunk</h3><p>总是开启。</p><p>为 webpack 运行时和 chunk manifest 创建一个独立的 chunk。这个 chunk 应该内联到 HTML 中。</p><ul><li>📉缺点：更大的 HTML 文件</li><li>📈优点：更好的缓存</li></ul><h3 id="optimization-noEmitOnErrors"><a href="#optimization-noEmitOnErrors" class="headerlink" title="optimization.noEmitOnErrors"></a>optimization.noEmitOnErrors</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>当发生编译错误的时候不输出资源包。</p><ul><li>📉缺点：无法使用应用程序的起作用的部分</li><li>📈优点：没有损坏的 bundles</li></ul><h3 id="optimization-namedModules"><a href="#optimization-namedModules" class="headerlink" title="optimization.namedModules"></a>optimization.namedModules</h3><p>只在 <code>development</code> 模式下开启，否则禁用。</p><p>取代数值型 ID，提供给 module 更有用的命名。</p><ul><li>📉缺点：bundle 体积增加</li><li>📈优点：更好的错误报告和 debug</li></ul><h3 id="optimization-nodeEnv"><a href="#optimization-nodeEnv" class="headerlink" title="optimization.nodeEnv"></a>optimization.nodeEnv</h3><p><code>mode</code> 值得默认项：<code>development</code> 或者 <code>production</code>。</p><p>定义 <code>process.env.NODE_ENV</code> 成为编译时常量值。这就允许移除掉 development only 的代码。</p><ul><li>📉缺点：开发环境的代码与生产环境的代码不同</li><li>📈📈优点：减小 bundle 体积，提高运行效率</li></ul><h3 id="optimization-minimize"><a href="#optimization-minimize" class="headerlink" title="optimization.minimize"></a>optimization.minimize</h3><p>只在 <code>production</code> 模式下开启，否则禁用。</p><p>使用最小化工具来压缩输出的资源包，比如（<code>optimization.minimizer</code>默认使用的<code>uglify-js</code>）。</p><ul><li>📉📉📉缺点：编译速度降低</li><li>📈📈📈优点：减小 bundle 体积</li></ul><h3 id="optimization-portableRecords"><a href="#optimization-portableRecords" class="headerlink" title="optimization.portableRecords"></a>optimization.portableRecords</h3><p>在文件内记录时启用，否则禁用。</p><p>记录中使用的标识与上下文目录有关。</p><ul><li>📉缺点：影响速度降低</li><li>📈优点：记录与目录无关</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文 &lt;a href=&quot;https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 &lt;a href=&quot;https://medium.com/@sokra&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tobias Koppers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;webpack 增加了一个模式配置（mode option）。下面来解释一下具体内容。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Webpack" scheme="https://beanlee.github.io/tags/Webpack/"/>
    
      <category term="构建工具" scheme="https://beanlee.github.io/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>移动端 HTTPS 抓包工具配置说明</title>
    <link href="https://beanlee.github.io/2018/03/29/mobile-https-config/"/>
    <id>https://beanlee.github.io/2018/03/29/mobile-https-config/</id>
    <published>2018-03-29T10:53:55.000Z</published>
    <updated>2018-04-18T07:52:00.402Z</updated>
    
    <content type="html"><![CDATA[<p>投稿部门公众号，做了一些微调，增加了 Android 机型的一些说明。</p><p>2018-03-01 Beanlee</p><p>相信各位在移动端开发过程中一定遇到抓取数据包、拦截请求的场景，本文主要介绍移动端在针对 HTTPS 抓包时的几款软件的配置（包括<a href="#Charles">Charles</a>、<a href="#Fiddler">Fiddler</a>、<a href="#Whistle">Whistle</a>），下面举例将已 iOS 11 为例，附带 Android 机型配置截图。</p><a id="more"></a><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles<b id="Charles"></b></h2><ul><li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">官网</a></li><li>按照 license 收费，收费后终身享受升级，仅限 OS X 平台</li></ul><h3 id="HTTP-抓包配置"><a href="#HTTP-抓包配置" class="headerlink" title="HTTP 抓包配置"></a>HTTP 抓包配置</h3><h4 id="1-确保手机与主机处于同一局域网内。"><a href="#1-确保手机与主机处于同一局域网内。" class="headerlink" title="1.确保手机与主机处于同一局域网内。"></a>1.确保手机与主机处于同一局域网内。</h4><p>查看本机 IP，使用 <code>ifconfig</code> 命令查看本机 IP；或者打开系统设置查看 IP 如截图；</p><p>例如：当前本机 IP <code>192.168.191.4</code></p><p><img src="https://img20.360buyimg.com/uba/jfs/t16375/210/2520307643/222582/31ac0971/5ab0a175N3cbadb49.png.webp" alt="ifconfig"></p><p><img src="https://img10.360buyimg.com/uba/jfs/t17530/312/915989884/252348/b1b61faa/5ab0a1e7N47455815.png.webp" alt="wifi-config"></p><h4 id="2-设置手机-iOS-网络代理"><a href="#2-设置手机-iOS-网络代理" class="headerlink" title="2.设置手机 iOS 网络代理"></a>2.设置手机 iOS 网络代理</h4><p><code>设置</code> -&gt; <code>无线局域网</code> -&gt; <code>HTTP 代理</code> -&gt; <code>手动</code></p><p>服务器：<code>192.168.191.4</code> 端口：<code>8888</code></p><p><img src="https://img30.360buyimg.com/uba/jfs/t19171/267/1165626521/82168/a242486c/5abdf072Nd89a456f.png.webp" alt="ios&amp;andoird-proxy-conf"></p><h4 id="3-配置完成后，在手机端访问任何一个-App-或网页，电脑端-Charles-会弹出提示，点击-Allow"><a href="#3-配置完成后，在手机端访问任何一个-App-或网页，电脑端-Charles-会弹出提示，点击-Allow" class="headerlink" title="3.配置完成后，在手机端访问任何一个 App 或网页，电脑端 Charles 会弹出提示，点击 Allow"></a>3.配置完成后，在手机端访问任何一个 App 或网页，电脑端 Charles 会弹出提示，点击 Allow</h4><p>此时可以在应用的界面中看到 HTTP 的请求数据了。</p><p>接下来继续 HTTPS 的配置。</p><h3 id="HTTPS-抓包配置"><a href="#HTTPS-抓包配置" class="headerlink" title="HTTPS 抓包配置"></a>HTTPS 抓包配置</h3><h4 id="1-信任证书-本机"><a href="#1-信任证书-本机" class="headerlink" title="1.信任证书 本机"></a>1.信任证书 本机</h4><p>打开 Charles 后如下图操作，电脑端信任证书，<strong>注意</strong> 此处选择<code>system</code></p><p><img src="https://img13.360buyimg.com/uba/jfs/t16189/305/2463904253/229838/13248112/5ab0a246N431365b3.png.webp" alt="charles-install-root-cer"></p><p><img src="https://img30.360buyimg.com/uba/jfs/t15991/176/2548641977/433484/2e35454f/5ab0a26cN86d8f8c1.png.webp" alt="charles-install-root-cer-system"></p><h4 id="2-信任证书-手机"><a href="#2-信任证书-手机" class="headerlink" title="2.信任证书 手机"></a>2.信任证书 手机</h4><p>打开 <code>Safari</code> 地址输入 <code>192.168.191.4:8888</code> 或 <code>chls.pro/ssl</code> 点击安装，此时会弹出要求需要输入手机密码，完成后证书安装成功。</p><p>此时查看 <code>通用</code> -&gt; <code>描述文件</code> 中 charles proxy ca 已变成<code>已验证</code>。</p><p><strong>注意</strong> 自 iOS 10.3 以上，还需要多一步操作，手动信任自定义根证书，才能确保证书安装并已启用；</p><p><code>关于本机</code> -&gt; <code>证书信任设置</code> 启用 charles proxy ca 截图详见文章底部<a href="#tips">锦囊</a></p><p><strong>注意</strong> Android 手机不需要安装 Charles 证书 <a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/" target="_blank" rel="noopener">ssl-certificates</a></p><p>下面截图中是 Android 仅安装了 Fiddler 和 Whistle 的证书截图。</p><p><img src="https://img30.360buyimg.com/uba/jfs/t18598/270/1201930732/57036/69b112d/5abdf133N1ef09cfe.png.webp" alt="android-cert"></p><h4 id="3-Charles-设置启用-SSL-Proxy"><a href="#3-Charles-设置启用-SSL-Proxy" class="headerlink" title="3. Charles 设置启用 SSL Proxy"></a>3. Charles 设置启用 SSL Proxy</h4><p><code>Proxy</code>-&gt;<code>SSL Proxy setting</code> Enabled SSL Proxying</p><p>同时添加希望拦截到的域名，例如：<code>*.jd.com</code> 端口 <code>443</code></p><p><img src="https://img14.360buyimg.com/uba/jfs/t17281/140/906435195/142935/49f55aa9/5ab0a4d4Nacbc29d6.png.webp" alt="charles-ssl-config01"></p><p><img src="https://img10.360buyimg.com/uba/jfs/t19591/182/853494454/73346/71990549/5ab0a4acN9ee93450.png.webp" alt="charles-ssl-config02"></p><p><strong>配置完成</strong> : )</p><h2 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler<b id="Fiddler"></b></h2><ul><li><a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">官网</a></li><li>微软出品，免费，由于需要 .Net 库仅 Windows 平台（也有一些 Fiddler For mac / linux 但仅限 beta 版且功能不完善，这里只推荐在 Win 平台使用）</li></ul><h3 id="HTTP-抓包"><a href="#HTTP-抓包" class="headerlink" title="HTTP 抓包"></a>HTTP 抓包</h3><p>配置与 <code>Charles</code> 配置相同端口略有不同，此处不再重复。</p><p>总结几大步骤：</p><ol><li>移动端和电脑同处同一局域网内</li><li>手机或移动设备设置网络代理对应电脑端 IP 和 端口</li></ol><p><img src="https://img14.360buyimg.com/uba/jfs/t14656/65/2745558691/37041/b26d6171/5ab0add4N3bd559a6.png.webp" alt="fiddler01"></p><h3 id="HTTPS-抓包配置-1"><a href="#HTTPS-抓包配置-1" class="headerlink" title="HTTPS 抓包配置"></a>HTTPS 抓包配置</h3><ul><li>勾选拦截 HTTPS 请求</li><li>安装证书（电脑端 &amp; 手机端）</li></ul><p><img src="https://img14.360buyimg.com/uba/jfs/t17401/70/901071906/48039/62c96f01/5ab0add7N4816f088.png.webp" alt="fiddler02"></p><h2 id="Whistle"><a href="#Whistle" class="headerlink" title="Whistle"></a>Whistle<b id="Whistle"></b></h2><ul><li><a href="https://avwo.github.io/whistle/" target="_blank" rel="noopener">官网</a></li><li>国人开发，开源 MIT 协议，基于 NodeJS 跨平台</li><li><strong>推荐</strong> 功能强大，部门内也有小伙伴分享过一次使用经验</li></ul><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ul><li><code>nodejs v0.10.0+</code></li><li><code>npm i -g whistle</code></li><li><code>w2 start</code></li></ul><p>完成上面几步操作后，此时 <code>8899</code> 端口已经常驻后台。</p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="https://img14.360buyimg.com/uba/jfs/t17362/179/900501459/1903822/f445defb/5ab0bcecNf4b0f762.png.webp" alt="whistle"></p><h3 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h3><p>whistle 提供了一个基于 Chrome 的插件，可以方便切换代理，查看网络，编辑规则等，不过很遗憾作者已经将插件在 Web Store 下架，现在搜索不到，我把本地 0.10.0 版本打包成 crx 上传在 Google Driver 可以访问 <a href="https://drive.google.com/open?id=18RCuXBb_ml6OqLw-3PTSevcpJ81h-F27" target="_blank" rel="noopener">下载</a></p><p>或者改用另外一个强大的插件 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a> 该插件也拥有强大的代理功能，同时支持自定义规则，可以自动根据域名或端口等自动选择是否启用代理，以后有机会可以分享使用 Proxy SwitchOmega 的使用经验。</p><h3 id="HTTPS-拦截配置"><a href="#HTTPS-拦截配置" class="headerlink" title="HTTPS 拦截配置"></a>HTTPS 拦截配置</h3><p><a href="https://avwo.github.io/whistle/webui/https.html" target="_blank" rel="noopener">whistle 文档 https 设置部分</a></p><h2 id="HTTPS-抓包锦囊"><a href="#HTTPS-抓包锦囊" class="headerlink" title="HTTPS 抓包锦囊"></a>HTTPS 抓包锦囊<b id="tips"></b></h2><p><strong>注意</strong> 自 iOS 10.3 以后，无论使用上面哪一种工具抓包，安装完 ca 证书以后，还需要<strong>多一步操作</strong>，才能确保证书安装并已启用；</p><p><code>通用</code> -&gt; <code>关于本机</code> -&gt; <code>证书信任设置</code> -&gt; 启用相对应的证书，就可以看到工具中抓取到相应的 HTTPS 请求。</p><p><img src="https://img30.360buyimg.com/uba/jfs/t18550/32/1136654112/137090/91a83930/5abdf196N9bc228ff.png.webp" alt="ios-cer"></p><p>这一点跟苹果的 <strong>one more thing</strong> 貌似有那么一点不谋而合。</p><p><strong>注意</strong> Android 部分手机（如小米、华为）无法安装证书时候，不妨试试在电脑端将证书导出，打开手机 FTP 或者利用数据线传输到手机某个文件夹，点开 WLAN 配置 -&gt; 高级设置 -&gt; 安装证书 选择对应的证书安装即可。亦或是因为权限问题无法安装，打开安全隐私，选择信任 <code>未知来源</code>。</p><p>此办法对于安装测试版 APP 也管用 :)</p><p>have fun :D</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;投稿部门公众号，做了一些微调，增加了 Android 机型的一些说明。&lt;/p&gt;
&lt;p&gt;2018-03-01 Beanlee&lt;/p&gt;
&lt;p&gt;相信各位在移动端开发过程中一定遇到抓取数据包、拦截请求的场景，本文主要介绍移动端在针对 HTTPS 抓包时的几款软件的配置（包括&lt;a href=&quot;#Charles&quot;&gt;Charles&lt;/a&gt;、&lt;a href=&quot;#Fiddler&quot;&gt;Fiddler&lt;/a&gt;、&lt;a href=&quot;#Whistle&quot;&gt;Whistle&lt;/a&gt;），下面举例将已 iOS 11 为例，附带 Android 机型配置截图。&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动开发" scheme="https://beanlee.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS HTTPS 抓包工具配置说明</title>
    <link href="https://beanlee.github.io/2018/03/01/iOS-https/"/>
    <id>https://beanlee.github.io/2018/03/01/iOS-https/</id>
    <published>2018-03-01T10:53:55.000Z</published>
    <updated>2018-03-20T08:17:39.192Z</updated>
    
    <content type="html"><![CDATA[<p>相信各位在移动端开发过程中一定遇到抓取请求的场景，本文主要显示 iOS 11 在 <a href="#Charles">Charles</a>、<a href="#Fiddler">Fiddler</a>、<a href="#Whistle">Whistle</a> 下HTTPS抓包配置，欢迎留言区补充其他工具。PS.留言使用 Disqus 插件需要<code>科学上网</code>。</p><p>已经熟悉以上三个工具基础配置，仅仅需要解决抓包 iOS 下 HTTPS 问题的同学可以直接打开<a href="/2018/03/01/2018-03-01-iOS-https/#tips">锦囊</a></p><a id="more"></a><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles<b id="Charles"></b></h2><ul><li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">官网</a></li><li>按照 license 收费，收费后终身享受升级，仅限 OS X 平台</li></ul><h3 id="HTTP-抓包"><a href="#HTTP-抓包" class="headerlink" title="HTTP 抓包"></a>HTTP 抓包</h3><h4 id="1-确保手机与主机处于同一局域网内。"><a href="#1-确保手机与主机处于同一局域网内。" class="headerlink" title="1.确保手机与主机处于同一局域网内。"></a>1.确保手机与主机处于同一局域网内。</h4><p>查看本机 IP，使用 <code>ifconfig</code> 命令查看本机 IP；或者打开系统设置查看 IP 如截图；</p><p>当前本机 IP 192.168.191.4</p><p><img src="https://img20.360buyimg.com/uba/jfs/t16375/210/2520307643/222582/31ac0971/5ab0a175N3cbadb49.png.webp" alt="ifconfig"></p><p><img src="https://img10.360buyimg.com/uba/jfs/t17530/312/915989884/252348/b1b61faa/5ab0a1e7N47455815.png.webp" alt="wifi-config"></p><h4 id="2-设置手机-iOS-网络代理"><a href="#2-设置手机-iOS-网络代理" class="headerlink" title="2.设置手机 iOS 网络代理"></a>2.设置手机 iOS 网络代理</h4><p><code>设置</code> -&gt; <code>无线局域网</code> -&gt; <code>HTTP 代理</code> -&gt; <code>手动</code></p><p>服务器：<code>192.168.191.4</code> 端口：<code>8888</code></p><h4 id="3-配置完成后，在手机端访问任何一个-App-或网页，本机-charles-会弹出提示，点击-Allow"><a href="#3-配置完成后，在手机端访问任何一个-App-或网页，本机-charles-会弹出提示，点击-Allow" class="headerlink" title="3.配置完成后，在手机端访问任何一个 App 或网页，本机 charles 会弹出提示，点击 Allow"></a>3.配置完成后，在手机端访问任何一个 App 或网页，本机 charles 会弹出提示，点击 Allow</h4><p>此时已经可以抓取 HTTP 数据了</p><h3 id="HTTPS-抓包"><a href="#HTTPS-抓包" class="headerlink" title="HTTPS 抓包"></a>HTTPS 抓包</h3><h4 id="1-信任证书-本机"><a href="#1-信任证书-本机" class="headerlink" title="1.信任证书 本机"></a>1.信任证书 本机</h4><p>打开 charles 后如下图操作，本机信任 charles 证书，<strong>注意</strong> 此处选择<code>system</code></p><p><img src="https://img13.360buyimg.com/uba/jfs/t16189/305/2463904253/229838/13248112/5ab0a246N431365b3.png.webp" alt="charles-install-root-cer"></p><p><img src="https://img30.360buyimg.com/uba/jfs/t15991/176/2548641977/433484/2e35454f/5ab0a26cN86d8f8c1.png.webp" alt="charles-install-root-cer-system"></p><h4 id="2-信任证书-手机"><a href="#2-信任证书-手机" class="headerlink" title="2.信任证书 手机"></a>2.信任证书 手机</h4><p>打开 <code>safari</code> 地址输入<code>192.168.191.4:8888</code>或<code>chls.pro/ssl</code>点击安装，此时会弹出要求需要输入手机密码，完成后证书安装成功。</p><p>此时查看<code>通用</code>-&gt;<code>描述文件</code>中 charles proxy ca 已变成<code>已验证</code>。</p><p><strong>注意</strong> 自 iOS 10.3 以上，还需要多一步操作，手动信任自定义根证书，才能确保证书安装并已启用；如图所示；</p><p><code>关于本机</code>-&gt;<code>证书信任设置</code>启用 charles proxy ca 截图详见<a href="/2018/03/01/2018-03-01-iOS-https/#tips">锦囊</a></p><h4 id="3-Charles-设置启用-SSL-Proxy"><a href="#3-Charles-设置启用-SSL-Proxy" class="headerlink" title="3. Charles 设置启用 SSL Proxy"></a>3. Charles 设置启用 SSL Proxy</h4><p><code>Proxy</code>-&gt;<code>SSL Proxy setting</code> Enabled SSL Proxying</p><p>同时增加希望抓取的域名，例如：<code>*.jd.com</code>端口 <code>443</code></p><p><img src="https://img14.360buyimg.com/uba/jfs/t17281/140/906435195/142935/49f55aa9/5ab0a4d4Nacbc29d6.png.webp" alt="charles-ssl-config01"></p><p><img src="https://img10.360buyimg.com/uba/jfs/t19591/182/853494454/73346/71990549/5ab0a4acN9ee93450.png.webp" alt="charles-ssl-config02"></p><p><strong>配置完成</strong> : )</p><h2 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler<b id="Fiddler"></b></h2><ul><li><a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">官网</a></li><li>微软出品，免费，由于需要 .Net 库仅 Windows 平台</li></ul><h3 id="HTTP-抓包-1"><a href="#HTTP-抓包-1" class="headerlink" title="HTTP 抓包"></a>HTTP 抓包</h3><p>配置与 <code>Charles</code> 配置相同端口略有不同，此处不再重复</p><p><img src="https://img14.360buyimg.com/uba/jfs/t14656/65/2745558691/37041/b26d6171/5ab0add4N3bd559a6.png.webp" alt="fiddler01"></p><h3 id="HTTPS-抓包配置"><a href="#HTTPS-抓包配置" class="headerlink" title="HTTPS 抓包配置"></a>HTTPS 抓包配置</h3><ul><li>勾选拦截 HTTPS 请求</li><li>安装证书（电脑端 &amp; 手机端）</li></ul><p><img src="https://img14.360buyimg.com/uba/jfs/t17401/70/901071906/48039/62c96f01/5ab0add7N4816f088.png.webp" alt="fiddler02"></p><h2 id="Whistle"><a href="#Whistle" class="headerlink" title="Whistle"></a>Whistle<b id="Whistle"></b></h2><ul><li><a href="https://avwo.github.io/whistle/" target="_blank" rel="noopener">官网</a></li><li>国人开发，开源 MIT 协议，基于 NodeJS 跨平台</li><li><strong>推荐</strong></li></ul><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ul><li><code>nodejs v0.10.0+</code></li><li><code>npm i -g whistle</code></li><li><code>w2 start</code></li></ul><p>完成上面几步操作后，此时<code>8899</code>端口已经常驻后台。</p><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="https://img14.360buyimg.com/uba/jfs/t17362/179/900501459/1903822/f445defb/5ab0bcecNf4b0f762.png.webp" alt="whistle"></p><h3 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h3><p>whistle 提供了一个基于 Chrome 的插件，可以方便切换代理，查看网络，编辑规则等，不过很遗憾作者已经将插件在 Web Store 下架，现在搜索不到，我把本地 0.10.0 版本打包成 crx 上传在 Google Driver 可以访问 <a href="https://drive.google.com/open?id=18RCuXBb_ml6OqLw-3PTSevcpJ81h-F27" target="_blank" rel="noopener">下载</a></p><p>或者改用另外一个强大的插件 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a></p><h3 id="HTTPS-拦截配置"><a href="#HTTPS-拦截配置" class="headerlink" title="HTTPS 拦截配置"></a>HTTPS 拦截配置</h3><p><a href="https://avwo.github.io/whistle/webui/https.html" target="_blank" rel="noopener">whistle 文档 https 设置部分</a></p><h2 id="iOS-11-HTTPS-抓包锦囊"><a href="#iOS-11-HTTPS-抓包锦囊" class="headerlink" title="iOS 11 HTTPS 抓包锦囊"></a>iOS 11 HTTPS 抓包锦囊<b id="tips"></b></h2><p><strong>注意</strong> 自 iOS 10.3 以后，无论使用上面哪一种工具抓包，安装完 ca 证书以后，还需要<strong>多一步操作</strong>，才能确保证书安装并已启用；</p><p><code>通用</code> -&gt; <code>关于本机</code> -&gt; <code>证书信任设置</code> -&gt; 启用相对应的证书，就可以看到工具中抓取到相应的 HTTPS 请求。</p><p><img src="https://img30.360buyimg.com/uba/jfs/t15088/54/2660693956/316519/d9619a8c/5ab0a393Nc6ecb629.png.webp" alt="ios-cer"></p><p>这点跟苹果的 <strong>one more thing</strong> 貌似有那么一点不谋而合。</p><p>have fun :D</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信各位在移动端开发过程中一定遇到抓取请求的场景，本文主要显示 iOS 11 在 &lt;a href=&quot;#Charles&quot;&gt;Charles&lt;/a&gt;、&lt;a href=&quot;#Fiddler&quot;&gt;Fiddler&lt;/a&gt;、&lt;a href=&quot;#Whistle&quot;&gt;Whistle&lt;/a&gt; 下HTTPS抓包配置，欢迎留言区补充其他工具。PS.留言使用 Disqus 插件需要&lt;code&gt;科学上网&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;已经熟悉以上三个工具基础配置，仅仅需要解决抓包 iOS 下 HTTPS 问题的同学可以直接打开&lt;a href=&quot;/2018/03/01/2018-03-01-iOS-https/#tips&quot;&gt;锦囊&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动开发" scheme="https://beanlee.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【译】利用 webpack 做 web 性能优化</title>
    <link href="https://beanlee.github.io/2018/02/11/blog-translate-web-performance-optimization-with-webpack-from-google/"/>
    <id>https://beanlee.github.io/2018/02/11/blog-translate-web-performance-optimization-with-webpack-from-google/</id>
    <published>2018-02-11T06:35:33.000Z</published>
    <updated>2018-04-18T06:42:53.665Z</updated>
    
    <content type="html"><![CDATA[<p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a>，<a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>原文 <a href="https://developers.google.com/web/fundamentals/performance/webpack/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/webpack/</a></p><a id="more"></a><h2 id="Instroduction-介绍"><a href="#Instroduction-介绍" class="headerlink" title="Instroduction 介绍"></a>Instroduction 介绍</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/addyosmani" target="_blank" rel="noopener">Addy Osmani</a></p><p>现代 Web 应用经常用到<code>bunding tool</code>来创建生产环境的打包文件（例如脚本、样式等），打包文件是需要优化并压缩最小化，同时能够被让用户更快地下载到。在这篇文章中，我们将会利用<code>webpack</code>来贯穿说明如何优化网站资源。这样可以帮助用户更快地加载你的应用同时获得更好的体验。</p><p><img src="https://img20.360buyimg.com/uba/jfs/t15217/149/2229580840/12989/54324b99/5a815957N5bb3e0c6.png" alt="webpack-logo"></p><p>webpack 目前是最流行的打包工具之一，深入地利用它的特点去优化代码，将脚本拆分成重要和非重要部分，还有剔除无用的代码能够保证你的应用维持最小的带宽和进程消耗。</p><p><img src="https://img14.360buyimg.com/uba/jfs/t17569/325/476871633/18187/a1e34f41/5a81597fNd77bb5b8.png" alt="code-splitting"></p><blockquote><p>Note: 我们创建了一个练习的应用来演示下面这些优化的描述。尽力抽更多的时间来练习这些 tips <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener"><code>webpack-training-project</code></a></p></blockquote><p>让我们从现代 web 应用中最耗费资源之一的 <code>Javascript</code> 开始。</p><ul><li>减小前端体积</li><li>利用长时缓存</li><li>监控并分析应用</li><li>总结</li></ul><hr><h2 id="Decrease-Front-end-Size-减少前端体积"><a href="#Decrease-Front-end-Size-减少前端体积" class="headerlink" title="Decrease Front-end Size 减少前端体积"></a>Decrease Front-end Size 减少前端体积</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>当你正在优化一个应用时，首要事情就是尽可能地将它体积的减小。下面就是利用 <code>webpack</code> 如何做。</p><h3 id="Enable-minification-启用最小化"><a href="#Enable-minification-启用最小化" class="headerlink" title="Enable minification 启用最小化"></a>Enable minification 启用最小化</h3><p>最小化是通过去除多余空格、缩短变量名等方式压缩代码。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Original code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">const</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.length;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    result[index] = iteratee(array[index], index, array);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Minified code</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">n,r</span>)</span>&#123;<span class="keyword">let</span> t=<span class="number">-1</span>;<span class="keyword">for</span>(<span class="keyword">const</span> a=<span class="literal">null</span>==n?<span class="number">0</span>:n.length,l=<span class="built_in">Array</span>(a);++t&lt;a;)l[t]=r(n[t],t,n);<span class="keyword">return</span> l&#125;</span><br></pre></td></tr></table></figure><p>Webpack 支持两种方式最小化代码：UglifyJS 插件和<em>loader-specific options</em>。他们可以同时使用。</p><p><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">The UglifyJS plugin</a>在 bundle 层级中起作用，在编译之后压缩 bundle。下面来展示如何工作：</p><p>1.代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./comments.css'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.Webpack 打包后大概是下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"render"</span>] = render;</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* harmony import */</span> <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_css_js___default =</span><br><span class="line">__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__comments_css__);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.使用 UglifyJS 插件压缩最小化后大概是下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">e,n</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"Rendered!"</span>)&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(n,<span class="string">"__esModule"</span>,&#123;<span class="attr">value</span>:!<span class="number">0</span>&#125;),n.render=t;<span class="keyword">var</span> o=r(<span class="number">1</span>);r.n(o)</span><br></pre></td></tr></table></figure></p><p>插件集成在 webpack 中，把它的配置在<code>plugins</code>中就可以启用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>第二种方式<em>loader-specific options</em> 利用 loader options，可以压缩 Uglify 插件无法最小化的部分。举例，当你利用<code>css-loader</code>引入一个 CSS 文件时，文件会编译成一个字符串：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* comments.css */</span></span><br><span class="line"><span class="selector-class">.comment</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>↓<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minified bundle.js (part of)</span></span><br><span class="line">exports=<span class="built_in">module</span>.exports=__webpack_require__(<span class="number">1</span>)(),</span><br><span class="line">exports.push([<span class="built_in">module</span>.i,<span class="string">".comment &#123;\r\n  color: black;\r\n&#125;"</span>,<span class="string">""</span>]);</span><br></pre></td></tr></table></figure></p><p>UglifyJS 不能压缩字符串。要压缩这段 css 内容，需要配置 <em>loader</em> ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, <span class="attr">options</span>: &#123; <span class="attr">minimize</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>Note: UglifyJS 插件不能编译 ES2015+(ES2016)，这意味着如果你的 diamante 中使用类、箭头函数和一些新特性语法，不能编译成 ES5，插件会抛异常。<br>如果需要编译新语法，要使用 <a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a> 包。也是集成在 webpack 中相同的插件，但是更新一些，能够有能力编译 ES2015+。</p></blockquote><h4 id="Further-reading"><a href="#Further-reading" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li><a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">The UglifyJsPlugin docs</a></li><li>Other popular minifiers: <a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify</a>, <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler</a></li></ul><h3 id="Specify-NODE-ENV-production-明确生产环境信息"><a href="#Specify-NODE-ENV-production-明确生产环境信息" class="headerlink" title="Specify NODE_ENV=production 明确生产环境信息"></a>Specify <code>NODE_ENV=production</code> 明确生产环境信息</h3><p>减小前端体积的另外一个方法就是在代码中将<code>NODE_ENV</code><a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">环境变量</a>设置成<code>production</code>。</p><p>Libraries 会读取<code>NODE_ENV</code>变量判断他们应该在那种模式下工作 - 开发模式 or 生成模式。很多库会基于这个变量有不同的表现。举个例子，当<code>NODE_ENV</code>没有设置成<code>production</code>，Vue.js 会做额外的检查并且输出一些警告：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure><p>React 也是类似 - 开发模式下 build 带有一些警告：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react/index.js</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.production.min.js'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./cjs/react.development.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react/cjs/react.development.js</span></span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">warning$<span class="number">3</span>(</span><br><span class="line">  componentClass.getDefaultProps.isReactClassApproved,</span><br><span class="line">  <span class="string">'getDefaultProps is only used on classic React.createClass '</span> +</span><br><span class="line">  <span class="string">'definitions. Use a static property named `defaultProps` instead.'</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// …</span></span><br></pre></td></tr></table></figure><p>这些检查和警告通常在生产环境下是不必要的，但是他们仍然保留在代码中并且会增加库的体积。通过配置 webpack 的 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a> 来剔除掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="string">'"production"'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>DefinePlugin</code>用确定的变量替换所有存在的说明变量。利用下面配置：</p><p>1.<code>DefinePlugin</code>将用<code>&quot;production&quot;</code>替换到<code>process.env.NODE_ENV</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 如果你偏向有通过 CLI 配置变量，可以查看一下 <a href="https://webpack.js.org/plugins/environment-plugin/" target="_blank" rel="noopener">EnvironmentPlugin</a>。它和<code>DefinePlugin</code>类似，但读环境并且自动替换<code>process.env</code>表达式。</p></blockquote><p>2.<code>UglifyJS</code>会移除掉所有<code>if</code>分支 - 因为<code>&quot;production&quot; !== &#39;production&#39;</code>永远返回 false ，插件理解代码内的判断分支将永远不会执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"production"</span> !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  warn(<span class="string">'props must be strings when using array syntax.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue/dist/vue.runtime.esm.js (without minification)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) &#123;</span><br><span class="line">  name = camelize(val);</span><br><span class="line">  res[name] = &#123; <span class="attr">type</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note: 不一定强制要求使用 <code>UglifyJSPlugin</code>。你可以使用其他不同的最小化工具，这些页支持移除无用代码（例如，the <a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify plugin</a> or the <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler plugin</a>）</p></blockquote><h4 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h4><ul><li><a href="https://superuser.com/questions/284342/what-are-path-and-other-environment-variables-and-how-can-i-set-or-use-them" target="_blank" rel="noopener">What “environment variables” are</a></li><li>Webpack docs about: <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener"><code>DefinePlugin</code></a>, <a href="https://webpack.js.org/plugins/environment-plugin/" target="_blank" rel="noopener"><code>EnvironmentPlugin</code></a></li></ul><h3 id="Use-ES-Modules-使用-ES-模块"><a href="#Use-ES-Modules-使用-ES-模块" class="headerlink" title="Use ES Modules 使用 ES 模块"></a>Use ES Modules 使用 ES 模块</h3><p>下面这个方式利用 <a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">ES modules</a> 减小前端体积。</p><p>当你使用 ES module，webpack 有能力去做 tree-shaking。Tree-shaking 贯穿整个依赖树，检查那些依赖被使用，移除无用依赖。因此，如果你使用 ES module 语法，webpack 可以排除掉无用代码：</p><p>1.一个有多个 export 的文件，但是 app 只需要其中一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>2.webpack 理解 <code>commentRestEndPoint</code>没有使用，同时不能在一个 bundle 中生成单独的 export：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">'Rendered!'</span>; &#125;;</span><br><span class="line">  <span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> commentRestEndpoint = <span class="string">'/rest/comments'</span>;</span><br><span class="line">  <span class="comment">/* unused harmony export commentRestEndpoint */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.<code>UglifyJSPlugin</code>移除无用变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part that corresponds to comments.js)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">n,e</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="keyword">var</span> r=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"Rendered!"</span>&#125;;e.b=r&#125;)</span><br></pre></td></tr></table></figure><p>如果他们都是有 ES module 编写，就是与一些库并存时也是生效的。</p><blockquote><p>Note: 在 webpack 中，tree-shaking 没有 minifier 是无法生效的。 webpack 仅仅移除了没有被用到的 export 变量；<code>UglifyJSPlugin</code>才会移除无用代码。所以如果你编译打包时没有使用 minifier，打包后体积并不会更小。你也可以不一定使用这个插件。其他最小化的插件也支持移除 dead code（例如：<a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin" target="_blank" rel="noopener">Babel Minify plugin</a> or <a href="https://github.com/roman01la/webpack-closure-compiler" target="_blank" rel="noopener">Google Closure Compiler plugin</a>）</p></blockquote><blockquote><p>Warning: 不要将 ES module 编译到 CommonJS 中。 如果你使用 Babel <code>babel-preset-env</code> or <code>babel-preset-es2015</code>，检查一下当前的配置。默认情况下， ES <code>import</code> and <code>export</code> to CommonJS <code>require</code> and <code>module.exports</code>。通过设置 option 来禁止掉<a href="https://github.com/babel/babel/tree/master/experimental/babel-preset-env" target="_blank" rel="noopener">Pass the <code>{ modules: false }</code> option</a>。</p></blockquote><h4 id="Futher-reading"><a href="#Futher-reading" class="headerlink" title="Futher reading"></a>Futher reading</h4><ul><li><a href="https://ponyfoo.com/articles/es6-modules-in-depth" target="_blank" rel="noopener">“ES6 Modules in depth”</a></li><li>Webpack docs <a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">about tree shaking</a></li></ul><h3 id="Optimize-images-优化图片"><a href="#Optimize-images-优化图片" class="headerlink" title="Optimize images 优化图片"></a>Optimize images 优化图片</h3><p>图片基本会占局页面一半以上体积。虽然它们不像 JavaScript 那么重要（比如它们不会阻止页面渲染），但图片仍然会占用掉一大部分带宽。利用<code>url-loader</code>，<code>svg-url-loader</code>和<code>image-webpack-loader</code>来在 webpack 中进行优化。</p><p><code>url-loader</code> 允许将小静态文件打包进 app。没有配置，他需要通过 file，将它放在编译后的打包 bundle 内并返回一个这个文件的 url。然而，如果我们注明<code>limit</code>选项，它将会 encode 成更小的文件 base64 文件 url。这是可以将图片放在Javascript 代码中，同时节省 HTTP 请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> imageUrl <span class="keyword">from</span> <span class="string">'./image.png'</span>;</span><br><span class="line"><span class="comment">// → If image.png is smaller than 10 kB, `imageUrl` will include</span></span><br><span class="line"><span class="comment">// the encoded image: 'data:image/png;base64,iVBORw0KGg…'</span></span><br><span class="line"><span class="comment">// → If image.png is larger than 10 kB, the loader will create a new file,</span></span><br><span class="line"><span class="comment">// and `imageUrl` will include its url: `/2fcd56a1920be.png`</span></span><br></pre></td></tr></table></figure><blockquote><p>Note: 内联图片减少了独立请求的数量，这是很好的方式（<a href="https://blog.octo.com/en/http2-arrives-but-sprite-sets-aint-no-dead/" target="_blank" rel="noopener">even with HTTP/2</a>），但是会增加 bundle下载和转换的时间和内存的消耗。一定要确保不要嵌入超大图片或者较多的图片 - 否则增加的 bundle 的时间将会掩盖做成内联图片的收益。</p></blockquote><p><code>svg-url-loader</code>与<code>url-loader</code>类似 - 都是将使用 <a href="https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding" target="_blank" rel="noopener">URL encoding</a>  encode 文件。这对对于 SVG 图片很奏效 - 因为 SVG 文件是文本，encoding 在体积上更有效率：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.svg$/</span>,</span><br><span class="line">        loader: <span class="string">'svg-url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Inline files smaller than 10 kB (10240 bytes)</span></span><br><span class="line">          limit: <span class="number">10</span> * <span class="number">1024</span>,</span><br><span class="line">          <span class="comment">// Remove the quotes from the url</span></span><br><span class="line">          <span class="comment">// (they’re unnecessary in most cases)</span></span><br><span class="line">          noquotes: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: svg-url-loader 拥有改善 IE 浏览器支持的 options，但是在其他浏览器中更糟糕。如果你需要兼容 IE 浏览器，<a href="https://github.com/bhovhannes/svg-url-loader#iesafe" target="_blank" rel="noopener">设置 iesafe: true 选项</a></p></blockquote><p><code>image-webpack-loader</code>压缩图片使之变小。它支持 JPG，PNG，GIF 和 SVG，因为我们将会使用它所有类型。</p><p>这个 loader 不会将图片嵌入在应用内，因此它必须与<code>url-loader</code>和<code>svg-url-loader</code>配合使用。避免复制粘贴到相同的 rules 中（一个用于 JPG/PNG/GIF 图片，另一个用于 SVG 图片），我们来使用<code>enforce: pre</code>作为单独的一个 rule 涵盖这个 loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">        <span class="comment">// This will apply the loader before the other ones</span></span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认 loader 设置就已经可以满足需求了 - 但如果你想要深入配置，请查看 <a href="https://github.com/tcoopman/image-webpack-loader#options" target="_blank" rel="noopener">the plugin options</a>。为了选择哪些 options 需要明确，可以查看 Addy Osmani 的 <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a></p><h4 id="Further-reading-1"><a href="#Further-reading-1" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li><a href="https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for" target="_blank" rel="noopener">“What is base64 encoding used for?”</a></li><li>Addy Osmani’s <a href="https://images.guide/" target="_blank" rel="noopener">guide on image optimization</a></li></ul><h3 id="Optimize-dependencies-优化依赖"><a href="#Optimize-dependencies-优化依赖" class="headerlink" title="Optimize dependencies 优化依赖"></a>Optimize dependencies 优化依赖</h3><p>平均一半以上的 Javascript 体积大小来源于依赖包，并且这些可能都不是必要的。</p><p>举一个例子来说，Lodash（v4.17.4）增加了最小化代码的 72KB 大小到 bundle 中。但是如果你仅仅用到它的20个方法，大约 65 KB 代码没有用处。</p><p>另外一个例子就是 Moment.js。 V2.19.1版本最小化后有 223KB，体积巨大 - 截至2017年10月一个页面内的 Javascript 平均体积是 452KB。但是，本地文件的体积占 170KB。如果你没有用到 多语言版 Moment.js，这些文件都会没有目的地使 bundle 更臃肿。</p><p>所有这些依赖都可以被轻易优化。我们在 Github repo 收集了优化的建议，<a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations" target="_blank" rel="noopener">check it out</a>！</p><h3 id="Enable-module-concatenation-for-ES-modules-aka-scope-hoisting"><a href="#Enable-module-concatenation-for-ES-modules-aka-scope-hoisting" class="headerlink" title="Enable module concatenation for ES modules (aka scope hoisting)"></a>Enable module concatenation for ES modules (aka scope hoisting)</h3><p>当你构建 bundle 时，webpack 将每一个 module 封装进 function 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part  of)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">var</span> __WEBPACK_IMPORTED_MODULE_0__comments_js__ = __webpack_require__(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_0__comments_js__[<span class="string">"a"</span> <span class="comment">/* render */</span>])();</span><br><span class="line"></span><br><span class="line">&#125;),</span><br><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  __webpack_exports__[<span class="string">"a"</span>] = render;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在以前，这么做是使 CommonJS/AMD modules 互相分离所必须的。但是，这会增加体积并且性能表现堪忧。</p><p>Webpack 2 介绍了 ES modules 的支持，不像 CommonJS 和 AMD modules 一样，而是能够不用将每一个 module 用 function 封装起来。同时 Webpack 3 利用<a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener"><code>ModuleConcatenationPlugin</code></a>完成这样一个 bundle，下面是例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'./comments.js'</span>;</span><br><span class="line">render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlike the previous snippet, this bundle has only one module</span></span><br><span class="line"><span class="comment">// which includes the code from both files</span></span><br><span class="line"><span class="comment">// 与前面的代码不同，这个 bundle 只有一个 module，同时包含两个文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bundle.js (part of; compiled with ModuleConcatenationPlugin)</span></span><br><span class="line"><span class="comment">/* 0 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(__webpack_exports__, <span class="string">"__esModule"</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./comments.js</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">data, target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rendered!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CONCATENATED MODULE: ./index.js</span></span><br><span class="line">  render();</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看到区别了吗？在这个 bundle 中， module 0 需要 module 1 的 render 方法。使用 <code>ModuleConcatenationPlugin</code>，<code>require</code>被直接简单的替换成 require 函数，同时 module 1 被删除删除掉了。这个 bundle 拥有更少的 modules，就有更少的 modules 损耗！</p><p>启用这个功能，可以在插件列表中增加<code>ModuleConcatenationPlugin</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><blockquote><p>Note：想要知道为什么这个功能不是默认启用？Concatenating modules 很棒， <a href="https://twitter.com/TheLarkInn/status/925800563144454144" target="_blank" rel="noopener">但是他会增加编译的时间同时破坏 module 的热更新</a>。这就是为什么只在生产环境中启用的原因了。</p></blockquote><h4 id="Further-reading-2"><a href="#Further-reading-2" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack docs <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">for the ModuleConcatenationPlugin</a></li><li><a href="https://medium.com/webpack/brief-introduction-to-scope-hoisting-in-webpack-8435084c171f" target="_blank" rel="noopener">“Brief introduction to scope hoisting”</a></li><li>Detailed description of <a href="https://medium.com/webpack/webpack-freelancing-log-book-week-5-7-4764be3266f5" target="_blank" rel="noopener">what this plugin does</a></li></ul><h3 id="Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals"><a href="#Use-externals-if-you-have-both-webpack-and-non-webpack-code-如果代码中包含-webpack-和非-webpack-的代码要使用-externals" class="headerlink" title="Use externals if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals"></a>Use <code>externals</code> if you have both webpack and non-webpack code 如果代码中包含 webpack 和非 webpack 的代码要使用 externals</h3><p>你可能拥有一个体积庞大的工程，其中一部分代码可以使用 webpack 编译，而有一些代码又不能。比如一个视频网站，播放器的 widget 可能通过 webpack 编译，但是其周围页面区域可能不是：</p><p><img src="https://img30.360buyimg.com/uba/jfs/t15334/148/2273118093/210074/8260a296/5a81599dN148751d5.png" alt="video-hosting"></p><p>如果两部分代码有相同的依赖，你可以共享这些依赖以便减少重复下载耗时。<a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">the webpack’s <code>externals</code> option</a>就干了这件事 - 它用变量或者外部引用来替代 modules。</p><h4 id="如果依赖是挂载到-window-上的情况"><a href="#如果依赖是挂载到-window-上的情况" class="headerlink" title="如果依赖是挂载到 window 上的情况"></a>如果依赖是挂载到 window 上的情况</h4><p>如果你的非 webpack 代码依靠这些依赖，它们是挂载 window 上的变量，可以将依赖名称 alias 成变量名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: <span class="string">'React'</span>,</span><br><span class="line">    <span class="string">'react-dom'</span>: <span class="string">'ReactDOM'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用这个配置，webpack 将不会打包 <code>react</code> 和 <code>react-dom</code>包。取而代之，他们会被替换成下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (part of)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.React`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole React bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = React;</span><br><span class="line">&#125;),</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A module that exports `window.ReactDOM`. Without `externals`,</span></span><br><span class="line">  <span class="comment">// this module would include the whole ReactDOM bundle</span></span><br><span class="line">  <span class="built_in">module</span>.exports = ReactDOM;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="如果依赖是当做-AMD-包被加载的情况"><a href="#如果依赖是当做-AMD-包被加载的情况" class="headerlink" title="如果依赖是当做 AMD 包被加载的情况"></a>如果依赖是当做 AMD 包被加载的情况</h4><p>如果你的非 webpack 代码没有将依赖暴露挂载到 window 上，这就更复杂了。但是如果非 webpack 代码使用 AMD 包的形式消费了这些依赖，你仍然可以避免重复的代码加载两次。</p><p>具体如何做呢？将 webpack 代码编译成一个 AMD module 同时别名成一个库的 URLs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123; <span class="attr">libraryTarget</span>: <span class="string">'amd'</span> &#125;,</span><br><span class="line"></span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'react'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react.min.js'</span> &#125;,</span><br><span class="line">    <span class="string">'react-dom'</span>: &#123; <span class="attr">amd</span>: <span class="string">'/libraries/react-dom.min.js'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 将会把 bundle 包装进 <code>define()</code>同时让它依赖于这些URLs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bundle.js (beginning)</span></span><br><span class="line">define([<span class="string">"/libraries/react.min.js"</span>, <span class="string">"/libraries/react-dom.min.js"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; … &#125;);</span><br></pre></td></tr></table></figure><p>如果非 webpack 代码使用相同的 URLs 加载依赖，这些文件将会加载一次 - 多余的请求会使用缓存。</p><blockquote><p>Note：webpack 只是替换那些<code>externals</code>对象中的准确匹配的 keys 的引用。这意味着如果你的代码这样写<code>import React from &#39;react/umd/react.production.min.js&#39;</code>，这个库是不会被 bundle 排除掉的。这是因为 - webpack 并不知道 <code>import &#39;react&#39;</code> 和 <code>import &#39;react/umd/react.production.min.js&#39;</code> 是同一个库，这样比较谨慎。</p></blockquote><h4 id="Further-reading-3"><a href="#Further-reading-3" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack docs <a href="https://webpack.js.org/configuration/externals/" target="_blank" rel="noopener">on <code>externals</code></a></li></ul><h3 id="Summing-up-总结"><a href="#Summing-up-总结" class="headerlink" title="Summing up 总结"></a>Summing up 总结</h3><ul><li>Minimize your code with the <code>UglifyJsPlugin</code> and loader options</li><li>Remove the development-only code with the <code>DefinePlugin</code></li><li>Use ES modules to enable tree shaking</li><li>Compress images</li><li>Apply dependency-specific optimizations</li><li>Enable module concatenation</li><li>Use <code>externals</code> if this makes sense for you</li></ul><hr><h2 id="Make-use-of-long-term-caching-利用好长时缓存"><a href="#Make-use-of-long-term-caching-利用好长时缓存" class="headerlink" title="Make use of long-term caching 利用好长时缓存"></a>Make use of long-term caching 利用好长时缓存</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>在做完优化应用体积之后的下一步提升应用加载时间的就是缓存。在客户端中使用缓存作为应用的一部分，这样会在每一次请求中减少重新下载的次数。</p><h3 id="Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息"><a href="#Use-bundle-versioning-and-cache-headers-使用-bundle-版本和缓存头信息" class="headerlink" title="Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息"></a>Use bundle versioning and cache headers 使用 bundle 版本和缓存头信息</h3><p>做缓存通用的解决办法：</p><p>1.告诉浏览器缓存一个文件很长时间（比如一年）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Server header</span><br><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure><p>Note：如果你不熟悉 <code>Cache-Control</code> 做了什么，你可以看一下 Jake Archibald 的精彩博文 <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">on caching best practices</a></p><p>2.当文件改变需要强制重新下载时去重命名这些文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Before the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v15.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- After the change --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index-v16.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些方法可以告诉浏览器下载这些 JS 文件，将其缓存起来。浏览器将只会在文件名发生改变时才会请求网络（或者缓存失效的情况也会请求）。</p><p>使用 webpack，也可以做同样的事，但可以使用版本号来解决，需要明确这个文件的 hash 值。使用 <a href="https://webpack.js.org/configuration/output/#output-filename" target="_blank" rel="noopener"><code>[chunkhash]</code></a> 可以将 <code>hash</code> 值包含进文件名中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">        <span class="comment">// → bundle.8e0d62a03.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Note: webpack 可能会生成不同的 hash 即使 bundle 相同 - 比如你重名了了一个文件或者重新在不同的操作系统下编译了一个 bundle。 <a href="https://github.com/webpack/webpack/issues/1479" target="_blank" rel="noopener">This is a bug.</a><br>如果你需要将文件名发送给客户端，也可以使用 <code>HtmlWebpackPlugin</code> 或者 <code>WebpackManifestPlugin</code>。</p></blockquote><p><code>HtmlWebpackPlugin</code> 很简单，但灵活性欠缺一些。编译时，插件会生成一个 HTML 文件，这其中包括所有的编译后的资源文件。如果你的业务逻辑不复杂，这就非常适合你：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.8e0d62a03.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>WebpackManifestPlugin</code>更灵活一些，它可以帮助你解决业务负责的部分。编译时它会生成一个 JSON 文件，这文件保存这没有 hash 值文件与有 hash 文件之间的映射。服务端利用这个 JSON 可以识别出那个文件有效：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// manifest.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundle.js"</span>: <span class="string">"bundle.8e0d62a03.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Further-reading-4"><a href="#Further-reading-4" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Jake Archibald <a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener">about caching best practices</a></li></ul><h3 id="Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件"><a href="#Extract-dependencies-and-runtime-into-a-separate-file-将依赖和运行环境代码提取到一个单独的文件" class="headerlink" title="Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件"></a>Extract dependencies and runtime into a separate file 将依赖和运行环境代码提取到一个单独的文件</h3><h4 id="Dependencies-依赖包"><a href="#Dependencies-依赖包" class="headerlink" title="Dependencies 依赖包"></a>Dependencies 依赖包</h4><p>App 依赖通常情况下趋向于比实际 app 内代码中更少的变化。如果你将他们移到独立的文件中，浏览器将可以把他们独立缓存起来 - 同时不会每次 app 代码改变时重新下载。</p><blockquote><p>Key Term: 在 webpack 的技术中，利用 app 代码拆分文件被称为 <code>chunks</code>。我们后面会用到这个名词。</p></blockquote><p>为了将依赖包提取到单独的 chunk 中，下面分为三步：</p><p>1.使用<code>[name].[chunkname].js</code>替换<code>output</code>的文件名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// Before</span></span><br><span class="line">    filename: <span class="string">'bundle.[chunkhash].js'</span>,</span><br><span class="line">    <span class="comment">// After</span></span><br><span class="line">    filename: <span class="string">'[name].[chunkhash].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 webpack 构建应用时，它会用一个带有 chunk 的名称来替换<code>[name]</code>。如果没有添加<code>[name]</code>部分，我们不得不通过 chunks 之间的 hash 区别来比较他们的区别 - 那就太难了！</p><p>2.将<code>entry</code>转成一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// Before</span></span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  <span class="comment">// After</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./index.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，”main” 对象是一个 chunk 的名字。这个名字将会被步骤 1 里面的 <code>[name]</code>代替。目前为止，如果你构建一个 app，chunk 就会包括整个 app 的代码 - 就像我们没有做这些步骤一样。但是很快就会产生变化。</p><p>3.添加 <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the dependencies.</span></span><br><span class="line">      <span class="comment">// This name is substituted in place of [name] from step 1</span></span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A function that determines which modules to include into this chunk</span></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>插件将包括全部<code>node_modules</code>路径下的 modules 同时将他们移到一个单独的文件中，这个文件被称为 <code>vendor.[chunkhash].js</code>。</p><p>完成了上面的步骤，每一次 build 都会生成两个文件。浏览器会将他们单独缓存 - 以便代码发生改变时重新下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">  ./main.00bab6fd3100008a42b0.js  82 kB       0  [emitted]  main</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><h4 id="Webpack-runtime-code"><a href="#Webpack-runtime-code" class="headerlink" title="Webpack runtime code"></a>Webpack runtime code</h4><p>不幸的是，仅仅抽取<code>vendor</code>是不够的。如果你试图在应用代码中修改一些东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">…</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. add this:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Wat'</span>);</span><br></pre></td></tr></table></figure><p>你会注意到<code>vendor</code>的 hash 值也会改变：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                           Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.d9e134771799ecdf9483.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                            Asset   Size  Chunks             Chunk Names</span><br><span class="line">./vendor.e6ea4504d61a1cc1c60b.js  47 kB       1  [emitted]  vendor</span><br></pre></td></tr></table></figure><p>发生这样的事是因为 webpack 打包时，一部分 modules 的代码，拥有 <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener"><em>a runtime</em></a> - 管理模块执行一部分代码。当你将代码拆分成多个文件时，这小部分代码在 chunk ids 和 匹配的文件之间开始了一个映射：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vendor.e6ea4504d61a1cc1c60b.js</span></span><br><span class="line">script.src = __webpack_require__.p + chunkId + <span class="string">"."</span> + &#123;</span><br><span class="line">  <span class="string">"0"</span>: <span class="string">"2f2269c7f0a55a5c1871"</span></span><br><span class="line">&#125;[chunkId] + <span class="string">".js"</span>;</span><br></pre></td></tr></table></figure><p>Webpack 将最新生成的 chunk 包含在这个 runtime 内，这个 chunk 就是我们代码中的<code>vendor</code>。与此同时每一次任何 <code>chunk</code> 的改变，这一小部分代码也改变，导致整个 <code>vendor</code> <code>chunk</code> 也会改变。</p><p>为了解决这个问题，我们将 runtime 转义到一个独立的文件中，通过<code>CommonsChunkPlugin</code>创建一个额外的空的 chunk：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span>,</span><br><span class="line"></span><br><span class="line">      minChunks: <span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.context &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.context.includes(<span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This plugin must come after the vendor one (because webpack</span></span><br><span class="line">    <span class="comment">// includes runtime into the last chunk)</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// minChunks: Infinity means that no app modules</span></span><br><span class="line">      <span class="comment">// will be included into this chunk</span></span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成这一部分改变，每一次 build 都将生成三个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: ac01483e8fec1fa70676</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 3816ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">   ./main.00bab6fd3100008a42b0.js    82 kB       0  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       1  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>将他们反过来顺序添加到 index.html 中，你就搞定了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vendor.26886caf15818fa82dfa.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./main.00bab6fd3100008a42b0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Further-reading-5"><a href="#Further-reading-5" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack guide <a href="https://webpack.js.org/guides/caching/" target="_blank" rel="noopener">on long term caching</a></li><li>Webpack docs <a href="https://webpack.js.org/concepts/manifest/" target="_blank" rel="noopener">about webpack runtime and manifest</a></li><li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a></li></ul><h3 id="Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求"><a href="#Inline-webpack-runtime-to-save-an-extra-HTTP-request-内联-webpack-runtime-节省额外的-HTTP-请求" class="headerlink" title="Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求"></a>Inline webpack runtime to save an extra HTTP request 内联 webpack runtime 节省额外的 HTTP  请求</h3><p>为了做的更好，尽力把 webpack runtime 内联在 HTML 请求里。下面举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./runtime.79f17c27b335abc7aaf4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params">r</span>)</span>&#123;<span class="keyword">if</span>(t[r])<span class="keyword">return</span> t[r].exports;…&#125;&#125; ([]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 runtime 很小，内联它可以帮助你节省 HTTP 请求（尤其对 HTTP/1 重要；但是在 HTTP/2 就没有那么重要了，但是仍能够提高效率）。</p><p>下面就来看看如何做。</p><h4 id="如果使用-HtmlWebpackPlugin-来生成-HTML"><a href="#如果使用-HtmlWebpackPlugin-来生成-HTML" class="headerlink" title="如果使用 HtmlWebpackPlugin 来生成 HTML"></a>如果使用 HtmlWebpackPlugin 来生成 HTML</h4><p>如果使用 <a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener"><code>HtmlWebpackPlugin</code></a> 来生成 HTML 文件，<a href="https://github.com/rohitlodha/html-webpack-inline-chunk-plugin" target="_blank" rel="noopener"><code>InlineChunkWebpackPlugin</code></a> 就足够了。</p><h4 id="如果使用自己的定制服务逻辑来生成-HTML"><a href="#如果使用自己的定制服务逻辑来生成-HTML" class="headerlink" title="如果使用自己的定制服务逻辑来生成 HTML"></a>如果使用自己的定制服务逻辑来生成 HTML</h4><p>1.将 <code>runtime</code> 名称改成静态的明确的文件名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span>,</span><br><span class="line">      minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">      filename: <span class="string">'runtime.js'</span>,</span><br><span class="line">        <span class="comment">// → Now the runtime file will be called</span></span><br><span class="line">        <span class="comment">// “runtime.js”, not “runtime.79f17c27b335abc7aaf4.js”</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.以方便的方式将 runtime.js 嵌入进去。比如：Node.js 和 Express</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> runtimeContent = fs.readFileSync(<span class="string">'./runtime.js'</span>, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;runtimeContent&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    …</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>有时候，页面拥有或多或少的部分：</p><ul><li>如果你在 YouTube 上加载一个视频页面，相比评论区域你更在乎视频区域。这就是视频要比评论区域重要。</li><li>如果你在一个新闻网站打开一个报道，相比广告区域你更关心文章的内容。这就是文字比广告更重要。</li></ul><p>在这些案例中，通过仅下载最重要的部分，懒加载剩余区域能够提升最初的加载性能。使用 <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">the <code>import()</code> function</a> 和 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">code-splitting</a> 解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// videoPlayer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderVideoPlayer</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// comments.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderComments</span>(<span class="params"></span>) </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;renderVideoPlayer&#125; <span class="keyword">from</span> <span class="string">'./videoPlayer'</span>;</span><br><span class="line">renderVideoPlayer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// …Custom event listener</span></span><br><span class="line">onShowCommentsClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./comments'</span>).then(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">    comments.renderComments();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>import()</code>明确表示你期望动态地加载独立的 module。当 webpack 看到 <code>import(&#39;./module.js&#39;)</code>时，他就会将这个 module 移到独立的 chunk 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 39b2a53cb4e73f0dc5b2</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.f7e53d8e13e9a2745d6d.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>并且只在代码执行到 <code>import()</code> 才会下载。</p><p>这将会让 main bundle 更小，提升初始加载的时间。更重要的是改进缓存 - 如果你修改 main chunk 的代码，其他部分的 chunk 也不会受影响。</p><blockquote><p>Note: 如果使用 Babel 编译代码，你会因为 Babel 还不认识 <em>import()</em> 而遇到语法错误抛出来。可以使用 <a href="https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener"><code>syntax-dynamic-import</code></a> 解决这个错误。</p></blockquote><h4 id="Further-reading-6"><a href="#Further-reading-6" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack docs <a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">for the <code>import()</code> function</a></li><li>The JavaScript proposal <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">for implementing the <code>import()</code> syntax</a></li></ul><h3 id="Split-the-code-into-routes-and-pages-拆分代码到路由和页面中"><a href="#Split-the-code-into-routes-and-pages-拆分代码到路由和页面中" class="headerlink" title="Split the code into routes and pages 拆分代码到路由和页面中"></a>Split the code into routes and pages 拆分代码到路由和页面中</h3><p>如果你的应用拥有多个路由或者页面，但是代码中只有单独一个 JS 文件（一个单独的 main chunk），这看起来你正在每一个请求中节省额外的 bytes 带宽。举个例子，当用户正在访问你网站的首页：</p><p><img src="https://img10.360buyimg.com/uba/jfs/t17272/291/466883786/44644/f5b82d7c/5a8159b0N4fe9f50d.png" alt="site-home-page"></p><p>他们并不需要加载另外不同的页面上渲染文章标题的的代码 - 但是他们还是会加载到这段代码。更严重的是如果用户经常只访问首页，同时你还经常改变渲染文章标题的代码，webpack 将会对整个 bundle 失效 - 用户每次都会重复下载全部 app 的代码。</p><p>如果我们将代码拆分到页面里（或者单页面应用的路由里），用户就会只下载对他有意义的代码。更好的是，浏览器也会更好地缓存代码：当你改变首页的代码时，webpack 只会让相匹配的 chunk 失效。</p><h4 id="For-single-page-apps-对于单页面应用"><a href="#For-single-page-apps-对于单页面应用" class="headerlink" title="For single-page apps 对于单页面应用"></a>For single-page apps 对于单页面应用</h4><p>通过路由拆分带页面引用，使用 <code>import()</code>（看看 <a href="https://developers.google.com/web/fundamentals/performance/webpack/use-long-term-caching#lazy-loading" target="_blank" rel="noopener">“Lazy-load code that you don’t need right now”</a>这部分）。如果你在使用一个框架，现在已经有成熟的方案：</p><ul><li><a href="https://reacttraining.com/react-router/web/guides/code-splitting" target="_blank" rel="noopener">“Code Splitting”</a> in <code>react-router</code>‘s docs (for React)</li><li><a href="https://router.vuejs.org/en/advanced/lazy-loading.html" target="_blank" rel="noopener">“Lazy Loading Routes”</a> in <code>vue-router</code>‘s docs (for Vue.js)</li></ul><h4 id="For-traditional-multi-page-apps-对于传统的多页面应用"><a href="#For-traditional-multi-page-apps-对于传统的多页面应用" class="headerlink" title="For traditional multi-page apps 对于传统的多页面应用"></a>For traditional multi-page apps 对于传统的多页面应用</h4><p>通过页面拆分传统多页面应用，可以使用 webpack 的 <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener"><em>entry points</em></a> 。如果你的应用有三种页面：主页、文章页、用户账户页，那就分厂三个 entries：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/Home/index.js'</span>,</span><br><span class="line">    article: <span class="string">'./src/Article/index.js'</span>,</span><br><span class="line">    profile: <span class="string">'./src/Profile/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每一个 entry 文件，webpack 将构建出独立的依赖树，并且声称一个 bundle，它将通过 entry 来只包括用到的 modules：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: 318d7b8490a7382bf23b</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 4273ms</span><br><span class="line">                            Asset     Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./home.91b9ed27366fe7e33d6a.js    18 kB       1  [emitted]  home</span><br><span class="line">./article.87a128755b16ac3294fd.js    32 kB       2  [emitted]  article</span><br><span class="line">./profile.de945dc02685f6166781.js    24 kB       3  [emitted]  profile</span><br><span class="line"> ./vendor.4f14b6326a80f4752a98.js    46 kB       4  [emitted]  vendor</span><br><span class="line">./runtime.318d7b8490a7382bf23b.js  1.45 kB       5  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>因此，如果仅仅是文章页使用 <em>Lodash</em> ，<em>home</em> 和 <em>profile</em> 的 bundle 将不会包含 lodash - 同时用户也不会在访问首页的时候下载到这个库。</p><p>拆分依赖树也有缺点。如果两个 entry points 都用到了 <em>loadash</em> ，同时你没有在 <em>vendor</em> 移除掉依赖，两个 entry points 将包括两个重复的 <em>lodash</em> 。我们可以使用<a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener"><code>CommonsChunkPlugin</code></a>来解决这个问题 - 它会将通用的依赖转移到一个独立的文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      <span class="comment">// A name of the chunk that will include the common dependencies</span></span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The plugin will move a module into a common file</span></span><br><span class="line">      <span class="comment">// only if it’s included into `minChunks` chunks</span></span><br><span class="line">      <span class="comment">// (Note that the plugin analyzes all chunks, not only entries)</span></span><br><span class="line">      minChunks: <span class="number">2</span>,    <span class="comment">// 2 is the default value</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随意使用<code>minChunks</code>的值来找到最优的选项。通常情况下，你想要它尽可能体积小，但它会增加 chunks 的数量。举个例子，3 个 chunk，<code>minChunks</code> 可能是 2 个，但是 30 个 chunk，它可能是 8 个 - 因为如果你把它设置成 2 ，过多的 modules 将会打包进一个通用文件中，文件更臃肿。</p><h4 id="Further-reading-7"><a href="#Further-reading-7" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack docs <a href="https://webpack.js.org/concepts/entry-points/" target="_blank" rel="noopener">about the concept of entry points</a></li><li>Webpack docs <a href="https://webpack.js.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">about the CommonsChunkPlugin</a></li><li><a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">“Getting the most out of the CommonsChunkPlugin”</a></li></ul><h3 id="Make-module-ids-more-stable-让-module-ide-更稳定"><a href="#Make-module-ids-more-stable-让-module-ide-更稳定" class="headerlink" title="Make module ids more stable 让 module ide 更稳定"></a>Make module ids more stable 让 module ide 更稳定</h3><p>当编译代码时，webpack 会分配给每一个 module 一个 ID。之后，这些 ID 就会被<code>require()</code>引用到 bundle 内部。你可以在编译输出的右侧在 moudle 路径之前看到这些 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.8ecaf182f5c85b7a8199.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.4e50a16675574df6a9e9.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[4] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[5] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line"> + 1 hidden module</span><br></pre></td></tr></table></figure><p>默认情况下，这些 ID 是使用计数器计算出来的（比如第一个 module 是 ID 0，第二个 moudle 就是 ID 1，以此类推）。这样的问题就在于当你新增一个 module 事，它会出现在原来 module 列表中的中间，改变后面所有 module 的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.5c82c0f337fcb22672b5.js    22 kB       0  [emitted]</span><br><span class="line">   ./main.0c8b617dfc40c2827ae3.js    82 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.26886caf15818fa82dfa.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.79f17c27b335abc7aaf4.js  1.45 kB       3  [emitted]  runtime</span><br><span class="line">   [0] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">   [2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">   [3] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ 我们增加一个新 module</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[4] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ 现在看这里做了什么！<code>comments.js</code>现在的 ID 由 4 变成了 5</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5] ./comments.js 58 kB &#123;0&#125; [built]</span><br></pre></td></tr></table></figure><p>↓ <code>ads.js</code> 的 ID 由 5 变成 6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[6] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">       + 1 hidden module</span><br></pre></td></tr></table></figure><p>这将使包含或依赖于具有更改ID的模块的所有块无效 - 即使它们的实际代码没有更改。在我们的代码中，_0_这个 chunk 和 <em>main</em> chunk 都会失效 - 只有<em>main</em>才应该失效。</p><p>使用<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener"><code>HashedModuleIdsPlugin</code></a>插件改变module ID 如何计算来解决这个问题。它利用 module 路径的 hash 来替换掉计数器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ webpack</span><br><span class="line">Hash: df3474e4f76528e3bbc9</span><br><span class="line">Version: webpack 3.8.1</span><br><span class="line">Time: 2150ms</span><br><span class="line">                           Asset      Size  Chunks             Chunk Names</span><br><span class="line">      ./0.6168aaac8461862eab7a.js  22.5 kB       0  [emitted]</span><br><span class="line">   ./main.a2e49a279552980e3b91.js    60 kB       1  [emitted]  main</span><br><span class="line"> ./vendor.ff9f7ea865884e6a84c8.js    46 kB       2  [emitted]  vendor</span><br><span class="line">./runtime.25f5d0204e4f77fa57a1.js  1.45 kB       3  [emitted]  runtime</span><br></pre></td></tr></table></figure><p>↓ Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[3IRH] ./index.js 29 kB &#123;1&#125; [built]</span><br><span class="line">[DuR2] (webpack)/buildin/global.js 488 bytes &#123;2&#125; [built]</span><br><span class="line">[JkW7] (webpack)/buildin/module.js 495 bytes &#123;2&#125; [built]</span><br><span class="line">[LbCc] ./webPlayer.js 24 kB &#123;1&#125; [built]</span><br><span class="line">[lebJ] ./comments.js 58 kB &#123;0&#125; [built]</span><br><span class="line">[02Tr] ./ads.js 74 kB &#123;1&#125; [built]</span><br><span class="line">    + 1 hidden module</span><br></pre></td></tr></table></figure><p>有了这个方法，只有你重命名护着删除这个 moudle 它的 ID 才会变化。新的 modules 不会因为 module ID 互相影响。</p><p>启用这个插件，在配置中增加 <em>plugins</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HashedModuleIdsPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Further-reading-8"><a href="#Further-reading-8" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Webpack docs <a href="https://webpack.js.org/plugins/hashed-module-ids-plugin/" target="_blank" rel="noopener">about the HashedModuleIdsPlugin</a></li></ul><h3 id="Summing-up"><a href="#Summing-up" class="headerlink" title="Summing up"></a>Summing up</h3><ul><li>Cache the bundle and differentiate between them by changing their names</li><li>Split the bundle into app code, vendor code and runtime</li><li>Inline the runtime to save an HTTP request</li><li>Lazy-load non-critical code with <code>import</code></li><li>Split code by routes/pages to avoid loading unnecessary stuff</li></ul><hr><h2 id="Monitor-and-analyze-the-app-监控并分析"><a href="#Monitor-and-analyze-the-app-监控并分析" class="headerlink" title="Monitor and analyze the app 监控并分析"></a>Monitor and analyze the app 监控并分析</h2><p>作者 <a href="https://developers.google.com/web/resources/contributors/iamakulov" target="_blank" rel="noopener">Ivan Akulov</a></p><p>即使当你配置好你的 webpack 让你的应用尽可能体积较小的时候，跟踪这个应用就非常重要，同时了解里面包含了什么。除此之外，你安装一个依赖，它将让你的 app 增加两倍大小 - 但并没有注意到这个问题！</p><p>这一部分就来讲解一些能够帮助你理解你的 bundle 的工具。</p><h3 id="Keep-track-of-the-bundle-size-跟踪打包的体积"><a href="#Keep-track-of-the-bundle-size-跟踪打包的体积" class="headerlink" title="Keep track of the bundle size 跟踪打包的体积"></a>Keep track of the bundle size 跟踪打包的体积</h3><p>在开发时可以使用<a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>和命令行<a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 来监控 app 的体积。</p><h4 id="webpack-dashboard"><a href="#webpack-dashboard" class="headerlink" title="webpack-dashboard"></a>webpack-dashboard</h4><p><a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a>可以通过依赖体积大小、进程和其他细节来改进 webpack 的输出。</p><p><img src="http://img30.360buyimg.com/uba/jfs/t16294/169/2125639991/38263/ad862ba/5a8159c0N0da38a60.png" alt="webpack-dashboard"></p><p>这个 dashborad 帮助我们跟踪大型依赖 - 如果你增加一个依赖，你就立刻能在 Modules section 始终看到它！</p><p>启用这个功能，需要安装 <em>webpack-dashboard</em> 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dashboard --save-dev</span><br></pre></td></tr></table></figure><p> 同时在配置的 plugins 增加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> DashboardPlugin = <span class="built_in">require</span>(<span class="string">'webpack-dashboard/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> DashboardPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者如果正在使用基于 Express dev server 可以使用 <code>compiler.apply()</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.apply(new DashboardPlugin());</span><br></pre></td></tr></table></figure><p>多尝试 dashboard 找出改进的地方！比如，在 modules section 滚动找到那个库体积过大，把它替换成小的可替代的库。</p><h4 id="bundlesize"><a href="#bundlesize" class="headerlink" title="bundlesize"></a>bundlesize</h4><p><a href="https://github.com/siddharthkp/bundlesize" target="_blank" rel="noopener">bundlesize</a> 可以验证 webpack assets 不超过指定的大小。通过自动化 CI 就可以知晓 app 是否变的过于臃肿：</p><p><img src="https://img30.360buyimg.com/uba/jfs/t15808/165/2111159728/110001/633e93ab/5a8159cdN1c575a1f.jpg" alt="bundlesize"></p><p>配置如下：</p><h5 id="Find-out-the-maximum-sizes-找出最大体积"><a href="#Find-out-the-maximum-sizes-找出最大体积" class="headerlink" title="Find out the maximum sizes 找出最大体积"></a><strong>Find out the maximum sizes</strong> 找出最大体积</h5><p>1.分析 app 尽可能减小体积，执行生产环境的 build。<br>2.在<code>package.json</code>中增加<code>bundlesize</code>部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.使用<code>npx</code>执行<code>bundlesize</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx bundlesize</span><br></pre></td></tr></table></figure><p>它就会将每一个文件的 gzip 压缩后的体积打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PASS  ./dist/icon256.6168aaac8461862eab7a.png:  10.89KB PASS./dist/icon512.c3e073a4100bd0c28a86.png:  13.1KB PASS./dist/main.0c8b617dfc40c2827ae3.js:  16.28KB PASS./dist/vendor.ff9f7ea865884e6a84c8.js:  31.49KB</span><br></pre></td></tr></table></figure><p>4.每一个体积增加10-20%，你将得到最大体积。这个10-20％的幅度可以让你像往常一样开发应用程序，同时警告你，当它的大小增长太多。</p><h5 id="Enable-bundlesize-启用-bundlesize"><a href="#Enable-bundlesize-启用-bundlesize" class="headerlink" title="Enable bundlesize 启用 bundlesize"></a><strong>Enable <code>bundlesize</code></strong> 启用 bundlesize</h5><p>5.安装<em>bundlesize</em>开发依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install bundlesize --save-dev</span><br></pre></td></tr></table></figure><p>6.在<code>package.json</code>中的<code>bundlesize</code>部分，声明具体的最大值。对于某一些文件（比如图片），你可以单独根据文件类型来设置最大体积大小，而不需要根据每一个文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundlesize"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/*.png"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"16 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/main.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"20 kB"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"./dist/vendor.*.js"</span>,</span><br><span class="line">      <span class="attr">"maxSize"</span>: <span class="string">"35 kB"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.增加一个 npm 脚本来执行检查：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"check-size"</span>: <span class="string">"bundlesize"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.配置自动化 CI 来在每一次 push 时执行<code>npm run check-size</code>做检查。（如果你在 Github 上开发项目，直接可以使用<a href="https://github.com/siddharthkp/bundlesize#2-build-status" target="_blank" rel="noopener">integrate <code>bundlesize</code> with GitHub</a>。）</p><p>这就全部了！现在如果你运行<code>npm run check-size</code>或者 push 代码，你就会看到输出的文件是否足够小：</p><p><img src="https://img14.360buyimg.com/uba/jfs/t14890/146/2205111432/17457/fa7f748a/5a8159dcN17378d16.png" alt="bundlesize-output-success"></p><p>或者下面失败的情况</p><p><img src="https://img11.360buyimg.com/uba/jfs/t16969/198/453213154/26368/834a1c7f/5a8159e8Nc1f5ffe8.png" alt="bundlesize-output-failure"></p><h4 id="Further-reading-9"><a href="#Further-reading-9" class="headerlink" title="Further reading"></a>Further reading</h4><ul><li>Alex Russell <a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/" target="_blank" rel="noopener">about the real-world loading time we should target</a></li></ul><h3 id="Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大"><a href="#Analyze-why-the-bundle-is-so-large-分析-bundle-为什么这么大" class="headerlink" title="Analyze why the bundle is so large 分析 bundle 为什么这么大"></a>Analyze why the bundle is so large 分析 bundle 为什么这么大</h3><p>你想要深挖 bundle 内，看看里面具体哪些 module 占用多大空间。<a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a></p><p>(Screen recording from <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">github.com/webpack-contrib/webpack -bundle-analyzer</a>)</p><p>webpack-bundle-analyzer 可以扫描 bundle 同时构建一个查看内部的可视化窗口。使用这个可视化工具找到过大或者不必要的依赖。</p><p>使用这个分析器，需要安装<code>webpack-bundle-analyzer</code>包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure><p>在 config 中增加插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行生产环境的 build 这个插件就会在浏览器中打开一个显示状态的页面。</p><p>默认情况下，这个页面会显示语法分析后的文件体积（在 bundle 出现的文件）。您可能想比较 gzip 的大小，因为这更接近实际用户的体验；使用左边的边栏来切换尺寸。</p><blockquote><p>Note: 如果你使用 <a href="https://webpack.js.org/plugins/module-concatenation-plugin/" target="_blank" rel="noopener">ModuleConcatenationPlugin</a>，它可能在webpack-bundle-analyzer输出时合并一部分 module，使得报告小一些细节。如果你使用这个插件，在执行分析的时候需要禁用掉。</p></blockquote><p>下面是报告中需要看什么：</p><ul><li><strong>大型依赖</strong> 为什么体积这么大？是否有更小的替代包（比如 Preact 替代 React）？用了全部代码（比如 Moment.js 包含大量的本地变量 <a href="https://github.com/GoogleChromeLabs/webpack-libs-optimizations#moment" target="_blank" rel="noopener">that are often not used and could be dropped</a>）？</li><li><strong>重复依赖</strong> 是否在不同文件中看到相同的库？（使用<em>CommonsChunkPlugin</em>将他们移到一个通用文件内）亦或是在同一个库中 bundle 拥有多个版本？</li><li><strong>相似依赖</strong> 是否存在有相似功能的相似库存在？（比如<em>moment</em>和<em>date-fns</em> 或者 <em>lodash</em> 和 <em>lodash-es</em>）尽力汇总成一个。</li></ul><p>同样的，也可以看看 Sean Larkin 的文章 <a href="https://medium.com/webpack/webpack-bits-getting-the-most-out-of-the-commonschunkplugin-ab389e5f318" target="_blank" rel="noopener">great analysis of webpack bundles</a>。</p><h3 id="Summing-up-1"><a href="#Summing-up-1" class="headerlink" title="Summing up"></a>Summing up</h3><ul><li>Use <code>webpack-dashboard</code> and <code>bundlesize</code> to stay tuned of how large your app is</li><li>Dig into what builds up the size with <code>webpack-bundle-analyzer</code></li></ul><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总结一下：</p><ul><li><strong>剔除不必要的体积</strong> 把所有的都压缩，剔除无用代码，增加依赖是保持谨慎小心。</li><li><strong>通过路由拆分代码</strong> 只在真正需要的时候才加载，其他的部分做来加载。</li><li><strong>缓存代码</strong> 应用程序的某些部分更新频率低于其他部分，将这些部分拆分成文件，以便在必要时仅重新下载。</li><li><strong>跟踪体积大小</strong> 使用  <a href="https://github.com/FormidableLabs/webpack-dashboard/" target="_blank" rel="noopener">webpack-dashboard</a> 和 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> 监控你的 app。每隔几个月重新检查一下你的应用的性能。</li></ul><p>Webpack 不仅仅是一个帮助你更快创建 app 的工具。它还帮助使你的 app 成为 <a href="https://developers.google.com/web/progressive-web-apps/" target="_blank" rel="noopener">a Progressive Web App</a> ，你的应用拥有更好的体验以及自动化的填充工具就像<a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="noopener">Lighthouse</a>根据环境给出建议。</p><p>不要忘记阅读 <a href="https://webpack.js.org/guides/" target="_blank" rel="noopener">webpack docs</a> - 里面提供了大量的优化的信息。</p><p>多多练习 <a href="https://github.com/GoogleChromeLabs/webpack-training-project" target="_blank" rel="noopener">with the training app</a>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者 &lt;a href=&quot;https://developers.google.com/web/resources/contributors/addyosmani&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Addy Osmani&lt;/a&gt;，&lt;a href=&quot;https://developers.google.com/web/resources/contributors/iamakulov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ivan Akulov&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/webpack/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developers.google.com/web/fundamentals/performance/webpack/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="https://beanlee.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Webpack" scheme="https://beanlee.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>【译】NPM vs Bower vs Browserify vs Gulp vs Grunt vs Webpack</title>
    <link href="https://beanlee.github.io/2016/06/17/NPM-vs-Bower-vs-Browserify-vs-Gulp-vs-Grunt-vs-Webpack/"/>
    <id>https://beanlee.github.io/2016/06/17/NPM-vs-Bower-vs-Browserify-vs-Gulp-vs-Grunt-vs-Webpack/</id>
    <published>2016-06-17T06:35:33.000Z</published>
    <updated>2018-02-27T04:24:49.991Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑</p><a id="more"></a><p><a href="http://stackoverflow.com/questions/35062852/npm-vs-bower-vs-browserify-vs-gulp-vs-grunt-vs-webpack" target="_blank" rel="noopener">Source Link</a></p><h2 id="作者问题"><a href="#作者问题" class="headerlink" title="作者问题"></a>作者问题</h2><blockquote><p>描述：我正在试着总结关于最流行的 Javascript 包管理器，打包器和任务执行器的知识。如果有错误请纠正我。</p></blockquote><ul><li><code>npm</code> &amp; <code>bower</code> 是包管理工具。他们只是将依赖文件下载，并不知道在下载这些文件的基础上如何编译项目。他们知道的是在获取所有依赖之后去调用 <code>webpack</code>/<code>gulp</code>/<code>grunt</code> 。</li><li><code>bower</code> 很像 <code>npm</code> ，但是编译依赖树不在行（不像 <code>npm</code> 那样递归着进行）。意味着 <code>npm</code> 获取每一依赖（可能获取几次相同的文件），然而 <code>bower</code> 期望你手动去包含子依赖。有时候 <code>bower</code> 和 <code>npm</code> 可以一起被使用，分别作用前端和后端（在前端每一mb都很重要）。</li><li><code>glup</code> 和 <code>gulp</code> 是任务运行器，目的是将能够被自动化的所有事任务自动化执行。（比如编译css/sass，处理图片，打包还有最小化混淆代码）。</li><li><code>grunt</code> vs <code>gulp</code> （就像<code>maven</code> vs <code>gradle</code> 或是 配置 vs 编码）。Grunt 是基于分离独立的任务配置的，每一个任务开始／处理／关闭文件。Gulp 需要少量代码，并且基于 node streams，那允许它编译链（w/o重复打开相同文件）而且执行很快。</li><li><code>webpack</code> (<code>webpack-dev-server</code>) 对于我来说，它是任务执行器随着变化热加载，那些允许你忘记关于所有js/css的监视器。</li><li><code>npm</code>/<code>bower</code>+plugin 可以替代任务运行器。他们的能力经常交叉因此如果你需要使用 <code>gulp</code>/<code>grunt</code> 在 npm+plugin 之上时存在着不同的潜在影响。但是任务运行器处理复杂任务定义的更好（比如 “在每一个编译打包，从ES6转义成ES5，在所有浏览器仿真器上运行，制作镜像还有通过ftp部署到dropbox”）。</li><li><code>browserify</code> 允许为浏览器打包node模块。<code>browserify</code> vs <code>node&#39;s require</code> 就像 <a href="https://addyosmani.com/writing-modular-js/" target="_blank" rel="noopener">AMD vs CommonJS</a></li></ul><h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><ul><li>什么是 webpack 和 webpack-dev-server ？官方文档说它是模块打包器，但对于我而言，它知识任务运行工具。有什么不同？</li><li>你在哪里用到 browserify ？我们能不能和 node／ES6 一样做？</li><li>你什么时候在 npm + plugins 基础上使用 <code>gulp</code>/<code>grunt</code> ？</li></ul><h2 id="Beat-Answer"><a href="#Beat-Answer" class="headerlink" title="Beat Answer"></a>Beat Answer</h2><p><code>Webpack</code> 和 <code>Browerify</code> 做了很多相同的工作，比如用于在一个浏览器环境钟打包你的模块。这个模块就是一个 Node 特征，它不在浏览器中存在，并且 ES6 中的 <code>import</code> 还没有在任何浏览器中实现，这就是为什么需要被打包。但是，他们在很多方式上是有区别的，<code>Webpack</code> 默认提供很多工具（比如代码拆分），<code>Browerify</code> 只能在下载插件之后才能做这些，但是使用这两种都能实现相似的效果。它取决于个人习惯（我常使用 <code>Webpack</code> ）。<code>Webpack</code> 不是一个任务运行器，它只是你通过CLI或任务运行器直接运行文件的一个中间过程器。</p><p><code>Webpack-dev-server</code> 提供类似于 <code>Browser-sync</code> - 它是一个你可以将你的 app 部署的服务，并且验证你的前端开发进程直接通过 dev-server 自动刷新浏览器或者在没有热部署的情况下传播变化（比如 React components）。</p><p>我为了项目的完整和简单的任务编写已经使用<code>Gulp</code>，但是我后来发现我既不需要<code>Gulp</code>也不需要<code>Grunt</code>。所有我需要的都可以使用<code>npm</code>组合脚本去运行第三方工具利用它们的 API 完成。在<code>Gulp</code>，<code>Grunt</code>和<code>npm script</code>之间选择取决于你的需要、JS 经验和你工作时的开发经验。</p><p>当然<code>Gulp</code>中的任务是易读的，甚至与JS不是很相似，它还是引用和学习另一个工具，并且我个人倾向于缩小我的依赖并且保持简单。另外一面，使用npm组合脚本和运行文件（配置和执行<code>Webpack</code>文件中函数）替代这些任务是更具有挑战性的。但是重要的是他们三个的结果是相同的。</p><p>举例说我建议你看一看 <a href="https://github.com/kriasoft/react-starter-kit" target="_blank" rel="noopener">react starter project</a> ，它可以向你很好的展示<code>npm</code>组合脚本，<code>Webpack</code>和<code>browser-sync</code>。即使你可以处理你的源文件，如果你愿意，你可以使用<code>Gulp</code>或者<code>Grunt</code>运行你的开发服务，我更喜欢第一个选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇在 Stack overflow 看到的一篇问题和回答，对于自己有一些解惑&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="翻译" scheme="https://beanlee.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Webpack" scheme="https://beanlee.github.io/tags/Webpack/"/>
    
      <category term="NPM" scheme="https://beanlee.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>Simple HTTP Server on OSX</title>
    <link href="https://beanlee.github.io/2016/05/31/Simple-HTTP-Server-on-OSX/"/>
    <id>https://beanlee.github.io/2016/05/31/Simple-HTTP-Server-on-OSX/</id>
    <published>2016-05-31T06:18:32.000Z</published>
    <updated>2018-02-27T04:23:12.972Z</updated>
    
    <content type="html"><![CDATA[<p>很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>cd path/project/folder</span><br><span class="line"><span class="meta">$</span>python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><p>Tada, thus you have got a HTTP server which port is 8080.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">control + c // stop it</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多项目在开发前期或者仅有 HTML/CSS/JS 文件，本地想要预览效果而不希望本地启动 Apache 或者 Nginx 难免有些麻烦，Mac OSX 其实内置Python，通过下面两条命令就可以快速启动一个简单 HTTP 服务。&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="Mac" scheme="https://beanlee.github.io/categories/Mac/"/>
    
    
  </entry>
  
  <entry>
    <title>【译】I know how to program, but I don&#39;t know what to program</title>
    <link href="https://beanlee.github.io/2016/05/19/WANQU-Program-Beginning/"/>
    <id>https://beanlee.github.io/2016/05/19/WANQU-Program-Beginning/</id>
    <published>2016-05-19T14:10:01.000Z</published>
    <updated>2018-02-27T04:22:10.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>湾区简评：这是很多初学编程的人，尤其是通过大学里的编程课学习写程序的人面临的问题。除了刷编程竞赛题、做课后编程题外，写程序能做什么？文章给的建议我赞同：先尝试去写自己也会用到的自动化的小工具。如果顺序反过来，已经知道要做什么了（比如做网站、做某个具体功能的app、做某个有实际用途的工具），再去学编程，会不会效果更好？</p></blockquote><a id="more"></a><h2 id="【译】我知道如何编程，但是我不知道拿来干什么"><a href="#【译】我知道如何编程，但是我不知道拿来干什么" class="headerlink" title="【译】我知道如何编程，但是我不知道拿来干什么"></a>【译】我知道如何编程，但是我不知道拿来干什么</h2><p><a href="http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios" target="_blank" rel="noopener">原文链接</a></p><p>当我面对刚入门的开发者时总有一个重复的主题。他们已经把他们的时间投入到学习一门或者两门编程语言的基础上，并且他们轻松地完成一些编程练习，但是他们不知道怎么接受他们已经学习的东西。通常来说，就像“我知道如何编程，但是我不知道编写什么程序”。标志性的回答是“完成一些编程挑战”，“给开源项目贡献代码”或者是“做一款游戏”。</p><p>完成编程挑战有益于脑力练习，但是它们却在人们学习如何创建一个新程序上的帮助很少。给开源项目贡献代码是一个提高的方式。你可能会学习到一个真实项目是如何架构的，并且在编程语言方面提升你的技巧，但是不会学习到很多的关于一个项目整个生命环的内容。某些项目非常复杂，这可能会对新手来说是非常恐怖的事。编写一款游戏是另一个提高的方式。游戏是有趣的！我以前曾开始用 QBASIC 编写游戏。然而发生了同样的困境。“我想要做一个游戏，但是我不知道做什么游戏”。</p><p>教导音乐系学生跟编程一样，我已经意识到在音乐系学生中存在同样的模式。“我知道全部的和弦，并且我弹奏很熟练，但是我不知道怎么样写一首歌曲。”在音乐中，我们确实有一个很好的解答。在学习创作中有一个途径。音乐家通常不仅仅从一开始就写自己的音乐。有些音乐家永远不会向拼凑音乐和花掉一生时间演奏他人音乐的方向发展。在编程的世界，态度有一点不同。</p><p>在软件社区有一个规则是“不要重复发明轮子”。当一个成熟稳定的选择存在时，如果你重写一个库通常是不被赞成的。虽然这对于一般人来说是一个好的规则，但新手不应该害怕重复发明轮子。当为了学习或者练习完成时，发明轮子是可以的！它是学习中一个重要的部分。比如，编写你自己版本的 ls，mv，wget 或者 cowsay 命令。如果你想要走游戏路线那可以克隆 Pong，Tetris 或者 Space Invaders 游戏。它们不需要全部相同的特点或者精确复制，但是你可以带着你的目标和空白的计划开始编程，你要把游戏实现出来。</p><ul><li><a href="https://github.com/greatcodeclub/pong" target="_blank" rel="noopener">pong</a></li><li><a href="https://github.com/Aerolab/blockrain.js" target="_blank" rel="noopener">blockrain.js</a> &amp; <a href="https://github.com/Hextris/hextris" target="_blank" rel="noopener">Hextris</a></li><li><a href="https://github.com/dwmkerr/spaceinvaders" target="_blank" rel="noopener">spaceinvaders</a> &amp; <a href="https://github.com/fat/space-tweet" target="_blank" rel="noopener">space-tweet</a></li></ul><p><img src="http://78renz.com1.z0.glb.clouddn.com/blog-20160519.png?imageslim" alt="games"></p><p>在你写程序之前不要有’必须有个最佳的 idea 才开始动手’这种念头。我见到过在音乐家中有相同的心态。在他们第一次尝试时就努力创造一个高水平，这花费他们全部的精力投入到一首乐曲中。长远的是你将会写出很多很多乐曲，不仅仅是这一首。你完成的第一支乐曲可能不好，你很可能抛弃它。这没什么。在你第一次尝试时，不要试着想要写出最好的章节。你需要学习谱曲的过程。在你写好程序之前你将会编写出糟糕的程序。迈过它，征服它，获取经验你就能开始在需求上自由创作发挥。</p><p>我们告诉人们用“Hello , world”做开端。因为这是他们行程的一个点，完成这个以为这征服了一个基础原理。你就理解了如何编译，如何运行，如何调用一个函数并且给它传递参数。编写一份已经存在软件的克隆版本是另外一个大的进步，跟 hello world 同等重要。当你完成它时，你已经克服了很多挑战。你已经发现哪里开始，如何计划，怎么组织，如何处理 bug ，给它一个人为的处理，并且打包最后它就成为一个可用的版本。即使你编写一个简单程序的克隆版本，你也能学习到全部过程。</p><p>你可能会好奇如何克隆已经存在的项目，它将帮助你产生一些新想法。比如像音乐，它需要创新。演奏他人的乐曲怎么做才能帮助你谱写自己的乐谱呢？你必须首先理解其他人。你必须去了解他们如何创作的，还有他们使用了什么模式。当你做完这些足够时间你就开始着眼以后，并且你已经有丰富的知识用来总结。你将从不同地方学习到的小部分音节组合在一起，并且重复一些你了解的模式。你可能改进，组合，或者完全打破你学习到的这些模式。就像他们所说的，你需要了解规则目的是用来突破他们。在编程过程中我们也有通用的模式比如 MVC 。这是一个稳定的被接受的编写软件的模式。在音乐中，我们也有通用的模式。比如 <a href="https://en.wikipedia.org/wiki/I%E2%80%93V%E2%80%93vi%E2%80%93IV_progression" target="_blank" rel="noopener">I-V-vi-IV</a>。当然它不是唯一的一个，但它是已知很好的一个模式。</p><p>总而言之，这是经验和创新的一个组合。创新是一部分人们经常在编程过程中被忽略的但他非常重要。你曾留意过有多少程序员也同样是作曲家吗？乐曲包含很多技术上分析，架构，模式尽管很多人认为他是一个纯粹的创作行为。编程是经常被看成技术性的动作尽管它多数是创作性的行为。你可以在复制其他项目过程中培养创新性。伴随着你逐渐完成他们，你将会发现你有了自己新的想法去改进程序，抑或是一个新的带有些许个性的特点被添加进去。它将会为新项目启发思路。创新随时会出现，但是你需要先学习如何把它首先谱写成歌曲。</p><p>总有一天，你将会发现你将能够为所有事编程。你可以让任务自动化并且处理问题熟练。当你面对将会使你没有时间应对的诸多事情时，你处理起来也会没有问题的。你也将有能力随时解决问题。“哦，这有一个100个Sheet的表格需要被格式化，拆分成文件，转成一个 CSV 文件？马上就解决！”不要耽误时间去尝试做未来最好的事。编写一些你将会使用到的东西。其他项目的点子也会随之而来。</p><p>你们中有多少人已经处于你想象的“我不知道写什么程序？”这种的状态？你是怎么解决它的？如果处于这种状态你有什么建议？</p><p><a href="http://www.devdungeon.com/content/i-know-how-program-i-dont-know-what-program?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=ios" target="_blank" rel="noopener">原文链接</a></p><p>湾区日报推荐</p><blockquote><p>豆子简评：对自己有一些启发，现在转职专门做前端相关的工作时间不长，从 J2EE SQL  … 到 HTML CSS Javascript NodeJS … 。虽然可以达到基本熟悉一门新的编程语言可以花费不长的时间这样一个状态，但是一直没有找到很好的办法在接触到一个新技术或框架时，短时间地拿着这些“新工具”去做事，其中原因很类似于“I Know how to program, but I don’t know what to program.”，先造一些自己能用得上的轮子吧，在自己的 Lab 页多更新。</p></blockquote>]]></content>
    
    <summary type="html">
    
      译文计划
    
    </summary>
    
      <category term="翻译" scheme="https://beanlee.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://beanlee.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Notes Of 360 Front-End Lesson</title>
    <link href="https://beanlee.github.io/2015/11/22/Notes-Of-360FE-Lesson/"/>
    <id>https://beanlee.github.io/2015/11/22/Notes-Of-360FE-Lesson/</id>
    <published>2015-11-22T15:32:19.000Z</published>
    <updated>2018-04-19T16:12:02.042Z</updated>
    
    <content type="html"><![CDATA[<p>360前端训练营笔记<br><a id="more"></a></p><h1 id="360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端"><a href="#360前端训练营课堂笔记-－-奇舞团与Facebook畅聊大前端" class="headerlink" title="360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端"></a>360前端训练营课堂笔记 － 奇舞团与Facebook畅聊大前端</h1><h2 id="HTTP-2-深入浅出"><a href="#HTTP-2-深入浅出" class="headerlink" title="HTTP/2 深入浅出"></a>HTTP/2 深入浅出</h2><ul><li>屈光宇 Ququ老师 <a href="https://imququ.com" target="_blank" rel="noopener">JerryQu 的小站</a></li></ul><h3 id="Before-HTTP-2"><a href="#Before-HTTP-2" class="headerlink" title="Before HTTP/2"></a>Before HTTP/2</h3><p>应用层协议，基于TCP<br>HTTP 0.9 没有请求头，GET<br>HTTP 1.0 增加请求／响应头，可以响应media，content-type，refere来源<br>HTTP 1.1 支持持久连接，keep-alive，支持传输编码，content-length，请求范围range（断点续传），cache-control,expires<br>SPDY协议截止2015</p><p>统计：页面大小和连接数，同一个页面多域名<br>TCP一个连接对应一个请求<br>keep-alive、管道pipelining（合并请求）、域名散列（多域名增加并发连接数）、协议开销、合并请求（改写Ajax，雪碧图、cssjs合并、cssjs内联、图片和音频内联base64、阻塞渲染，样式内联（多用于移动端，感知缓存）</p><p>input标签type＝text是默认值<br>H2O，can I use、cleartext协商，HTTPS，mozilla免费证书，全球已经开通HTTPS网站占63%</p><p>chrome在非HTTPS禁用关于设备使用的API，ALPN<br>HTTP／2-enabled，net-internals/#http2、Wireshark<br>优化，TLS，非对称加密，证书减少层级，ECC证书（很小，但是兼容性问题，vista才开始支持，移动端可以考虑）<br>HSTS，强制HTTPS、TLS安全清单SSL</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><ul><li>优化</li></ul><p>优化：减少DNS查询，减少域名、启用预读，减少重定向，使用CDN，压缩（PNGout，pngcrush）、HTTP缓存<br>不需要：域名散列，资源合并，资源内联</p><ul><li>最佳实践</li></ul><p>对HTTP/2优化的域名散列，多域名指向同一IP<br>感知缓存资源内联或者通过 server－push，cookie 标记内联过资源 server-push<br>基于node的node-http2</p><p>Google QUIC协议，基于UDP协议</p><h2 id="Why-React-Matters"><a href="#Why-React-Matters" class="headerlink" title="Why React Matters?"></a>Why React Matters?</h2><ul><li>為什麼 React 牛？</li><li>Facebook 黄士旗</li></ul><ul><li>Predictable/Immutable</li><li>React Native For iOS &amp; Android</li><li>ImmutableJS</li></ul><h2 id="ES6-ES7-Node-Project-ThinkJS"><a href="#ES6-ES7-Node-Project-ThinkJS" class="headerlink" title="ES6/ES7 Node Project, ThinkJS"></a>ES6/ES7 Node Project, ThinkJS</h2><ul><li>如何使用ES6/ES7开发NodeJS项目</li><li>李成银 ThinkJS 作者 @360齐舞团</li></ul><ul><li>callback、promise，async functions</li><li>babel javascript compile</li><li>更多特性，class，Arrows，enhanced object literals，template</li><li>性能问题，class，generators</li><li>自动更新，fs.watch（重启node服务），chokidar，nodemonitor；问题，无法保存临时数据</li><li>解决方案，热更新，依赖文件更新</li><li>require.cache，解决依赖和缓存，重写require方法</li><li>ThinkJS解决方案<a href="https://www.thinkjs.org" target="_blank" rel="noopener">ThinkJS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;360前端训练营笔记&lt;br&gt;
    
    </summary>
    
      <category term="Note" scheme="https://beanlee.github.io/categories/Note/"/>
    
    
      <category term="Front-End" scheme="https://beanlee.github.io/tags/Front-End/"/>
    
      <category term="Javascript" scheme="https://beanlee.github.io/tags/Javascript/"/>
    
      <category term="ReactJS" scheme="https://beanlee.github.io/tags/ReactJS/"/>
    
      <category term="NodeJS" scheme="https://beanlee.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>July And August</title>
    <link href="https://beanlee.github.io/2015/07/26/Jul-And-Aug/"/>
    <id>https://beanlee.github.io/2015/07/26/Jul-And-Aug/</id>
    <published>2015-07-26T07:02:20.000Z</published>
    <updated>2018-04-19T16:12:09.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>糟糕的七月，幸运的八月</p></blockquote><p>七下八上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;糟糕的七月，幸运的八月&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;七下八上&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="生活" scheme="https://beanlee.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Try My Best</title>
    <link href="https://beanlee.github.io/2015/07/19/Try-My-Best/"/>
    <id>https://beanlee.github.io/2015/07/19/Try-My-Best/</id>
    <published>2015-07-19T08:47:21.000Z</published>
    <updated>2018-04-19T16:12:16.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Be who you are and say what you feel, because those who mind don’t matter and those who matter don’t mind.</p><p>– Bernard Baruch</p></blockquote><a id="more"></a><h2 id="机遇-Opportunity"><a href="#机遇-Opportunity" class="headerlink" title="机遇 Opportunity"></a>机遇 Opportunity</h2><p>这里先要对我拒绝过公司道一声抱歉，也对原公司对我有知遇之恩的前 BOSS 说一声“感谢对我的认可，感谢能够再次给我机会，只可惜‘回归’现在不是我想做的事”。</p><p>很幸运的是，高中同学的前同事所在公司有一个岗位空缺，通过多方面的了解和考虑，这是一次非常好的机会。</p><p>周四我会参加复试，这家公司之前只在关注移动互联新闻中无意中扫过，由于一直没有在工作中投入到移动互联中，所以也从来没有认真关注过，有一些因缘的是，一起在北京奋斗的同学无意中提醒，如果想转职前端相关。</p><h2 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h2><p>整个7月，我都在为寻找新机会而准备（中间抽空和女朋友一起去了一趟厦门短期旅行），早在一年前来到 JD 之前就有朋友跟我说过，要想好为什么跳槽，对于自己而言，为什么要寻找新机会？</p><ul><li>是否是自己感兴趣想做的？或者说能不能在这份新工作找到乐趣？想清楚要做什么？</li><li>在这份新工作有多大的上升空间？</li><li>能否满足薪资收入预期？</li></ul><p>为了在这次面试，我特别针对这家工作做了很多准备工作，因为电话面之后，有一个 on-site 面试，需要提前在线限时完成三个算法题，于是翻出以前的书恶补了一些算法和数据结构相关的知识，虽然如此还是没有在答题当天表现出让自己满意的水平，还好把题目记下来自己私下里再做一次。</p><p>因为是外企，工作语言是英语，因此专门准备口语！<code>Practice! Practice! Practice!</code> </p><p>在 Glassdoor, Quora 等等网站查询关于这个公司的信息以及面试经验，在linkedin、V2EX、知乎、微博SNS上搜索他们员工和相关信息。</p><h2 id="尽力-Try"><a href="#尽力-Try" class="headerlink" title="尽力 Try"></a>尽力 Try</h2><p>最近一周我已经在充分调整自己，包括公司目前工作进度控制，近期的作息调整，希望能够有一个非常好的状态来参加复试，临阵磨枪一直不是我中意做事的方式，虽然做了很多准备，但更多的还是需要平时的积累、经验以及临场发挥，希望能够有个好结果！如果面试通过，一定要仔细整理一份面经。</p><blockquote><p>最好的休息，就是重新燃起生活的激情！</p></blockquote><hr><h2 id="其他-Others"><a href="#其他-Others" class="headerlink" title="其他 Others"></a>其他 Others</h2><p>目前公司在做一件事，有一个经验分享：<br>网站在支持 http 和 https 双协议，页面开发过程中有一处 tips</p><p><code>如果静态文件没有单独放在其他服务器上，这种问题可以直接使用相对路径解决。</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"//url/abc/bcd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//url/mnb/xxx.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">async</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在链接中不必写 <code>https://</code> 或 <code>http://</code> Javascript 中也可以通过 document 来获取当前页面的协议<code>document.location.protocol</code></p><p>如果一定要在页面写绝对路径包括协议头可以这样写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hp = (<span class="string">"https:"</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">"https://"</span> : <span class="string">"http:"</span>);</span><br></pre></td></tr></table></figure></p><p>访问速度优化策略几个关键步骤：<br>请求优化、压缩合并、无状态域名（减少cookie传输）、上传静态服务器如 CDN（推模式响应慢，主动拉模型更新响应快）</p><hr><p>2015下半年读书单（暂定）</p><p>技术方向</p><ul><li>Javascript 高级程序设计</li><li>你不知道的 Javascript（上卷）</li><li>CSS 权威指南</li><li>Javascript 设计模式</li></ul><p>非技术方向</p><ul><li>从0到1</li><li>羊毛战记</li><li>天才在左，疯子在右</li><li>断舍离</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Be who you are and say what you feel, because those who mind don’t matter and those who matter don’t mind.&lt;/p&gt;
&lt;p&gt;– Bernard Baruch&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="blog" scheme="https://beanlee.github.io/categories/blog/"/>
    
    
      <category term="生活" scheme="https://beanlee.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Questions Of Front-End</title>
    <link href="https://beanlee.github.io/2015/06/27/Question-Of-Front-End/"/>
    <id>https://beanlee.github.io/2015/06/27/Question-Of-Front-End/</id>
    <published>2015-06-27T00:32:19.000Z</published>
    <updated>2018-04-19T16:12:23.819Z</updated>
    
    <content type="html"><![CDATA[<p>前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！</p><a id="more"></a><blockquote><p>千万不要为了当前不好而跳槽，一定是要因为将来会更好而跳槽！</p></blockquote><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ul><li><p>盒子模型<br>margin - border - padding - content - padding - border - margin<br>上下两个元素之间会有margin合并问题</p></li><li><p>块级元素和行内元素区别<br><a href="http://blog.csdn.net/chen_zw/article/details/8713205" target="_blank" rel="noopener">http://blog.csdn.net/chen_zw/article/details/8713205</a><br><a href="http://segmentfault.com/a/1190000000654770" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000654770</a></p></li></ul><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul><li><p>实现一个叉号有几种实现方式<br>1.切图 2.先用一个span画一个长方形，圆角，然后使用transform倾斜 3.CSS3中使用Webfont 4.伪类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TODO</span> 代码实现</span><br></pre></td></tr></table></figure></li><li><p>CSS常用选择器<br>ID、类、伪类、父子选择器等等</p></li></ul><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><ul><li>原型链 prototype<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">MDN</a></li></ul><p>实现的本质是重新原型对象。</p><ul><li><p>原生ajax写法<br>XMLHttpRequest, XMLHttpResponse</p></li><li><p>事件模型和事件传播机制问题<br>浏览器中事件可以分为三种：鼠标事件；键盘事件；HTML事件；<br>捕获和冒泡的顺序在不同浏览器中不同，IE下事件流采用的是冒泡，基于DOM标准兼容浏览器通常采用先捕获后冒泡方式。</p></li></ul><p><code>addEventListener() &amp; removeEventListener()</code><br>所有 DOM 节点都包含这两个方法，都接受三个参数：要处理的事件名，作为事件处理程序的函数，一个布尔值。最后这个参数布尔值，<code>true</code>表示在捕获时调用事件处理函数，<code>false</code>表示在冒泡时调用时间处理函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"click"</span>);</span><br><span class="line">&#125;, flase);</span><br></pre></td></tr></table></figure><ul><li>跨域 JSONP 实现原理<br>原理：回调函数<br>JSONP 由两部分组成：回调函数和数据。</li></ul><p>For Example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"You're at IP "</span> + response.ip + <span class="string">", which is in "</span> + response.city);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"http://freegeoip.net/json/?callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.fisrtChild);</span><br></pre></td></tr></table></figure></p><ul><li><p><code>&lt;script&gt;</code>中defer和asyc区别和加载顺序</p><ul><li>asyc: <code>异步脚本</code>虽然立即下载脚本，不应该方案页面中其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本有效。不能保证按照指定的先后顺序执行，建议异步脚本不要在加载期间修改 DOM。</li><li>defer: <code>延迟脚本</code>可以延迟到文档完全被解析和显示之后再执行。只针对外部脚本有效。在现实当中，延迟脚本不一定按照顺序执行，不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本</li></ul></li><li><p>闭包：指有权访问另一个函数作用域中的变量和函数。</p></li><li><p>作用域：当代码在一个环境执行时，会创建变量对象的一个作用域。<br>理解：类似 Java 的成员变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">    <span class="comment">// 这里可以访问 color, anotherColor 和 tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问 color, anotherColor</span></span><br><span class="line">  swapColor();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问 color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端问题总结整理，持续更新和学习，找到想做的就加油做个行动派吧！&lt;/p&gt;
    
    </summary>
    
      <category term="前端技术" scheme="https://beanlee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Front-End" scheme="https://beanlee.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>OSC源创回年终盛典</title>
    <link href="https://beanlee.github.io/2014/11/26/OSC-Party/"/>
    <id>https://beanlee.github.io/2014/11/26/OSC-Party/</id>
    <published>2014-11-25T21:25:50.000Z</published>
    <updated>2018-04-19T16:12:29.787Z</updated>
    
    <content type="html"><![CDATA[<p>开源中国2014年终盛典大会参会笔记</p><a id="more"></a><h1 id="OSC源创会年终盛典"><a href="#OSC源创会年终盛典" class="headerlink" title="OSC源创会年终盛典"></a>OSC源创会年终盛典</h1><h2 id="开源中国的志向-马越"><a href="#开源中国的志向-马越" class="headerlink" title="开源中国的志向 - 马越"></a>开源中国的志向 - 马越</h2><p>Git，Sonar，Team……JFinal<br>互联网之子-施瓦茨，一切皆开源，要参与其中；年轻人，OSCer“我们就是梦想！”；感谢阿里巴巴、华为贡献开源的力量</p><h2 id="RDS-阿里云-数据通道挑战与实现-褚霸"><a href="#RDS-阿里云-数据通道挑战与实现-褚霸" class="headerlink" title="RDS 阿里云 数据通道挑战与实现 褚霸"></a>RDS 阿里云 数据通道挑战与实现 褚霸</h2><p>功能</p><ul><li>高可用/屏蔽后端变化/安全、数据路由，冷热数据区分、数据操作，分库分表、支持多种数据后端，MySQL MSSQL</li></ul><p>约束</p><ul><li>普通PC服务器、高可用、规模/可横向拓展、可运维可控</li></ul><p>可用性</p><ul><li>LVS商业版 SLBv3流量层 —- Proxy负载均衡 —- Master</li><li>流量层：VIP漂移保证用户不要切换DNS，session同步解决单机down机影响</li><li>Proxy层：Erlang VM作为中间件、支持热升级，不用切分流量</li><li>DB层：主备结构、跨机房/跨机架、主备同步/异步复制减少延迟、数据安全</li></ul><p>性能：RT、吞吐量、QPS、短链接性能</p><h2 id="剖析开源技术趋势-amp-华为开源现状"><a href="#剖析开源技术趋势-amp-华为开源现状" class="headerlink" title="剖析开源技术趋势&amp;华为开源现状"></a>剖析开源技术趋势&amp;华为开源现状</h2><ul><li>趋势：互联网化、平台级、推动硬件电信系统等发展、社区运营公司化、标准化</li><li>华为开源者能力中心，鼓励、支持</li><li>使用策略和原则：参考自行实现，架构解耦、社区同源减少维护成本</li></ul><h1 id="云计算专场"><a href="#云计算专场" class="headerlink" title="云计算专场"></a>云计算专场</h1><h2 id="开源分布式对象存储-OpenStack-Swift-李明宇microwise"><a href="#开源分布式对象存储-OpenStack-Swift-李明宇microwise" class="headerlink" title="开源分布式对象存储 OpenStack Swift - 李明宇microwise"></a>开源分布式对象存储 OpenStack Swift - 李明宇microwise</h2><p>OpenStack : A cloud operation system<br>It’s  a group system. 11 projects so huge, but the biggest user use 3.5 projects  . Install in CentOS 7.<br>OpenStack Swift: RESTfull Web API 直接从存储提供REST服务，解决访问无业务的文件的需求<br>Architecture of Swift: 图见CSDN Proxy Server接收请求 – Controller 通过hash等算法保证请求均匀分布 – 存储层<br>Story Policy: 可配置存储，比如保存位置，可靠性<br>OpenStack &amp; Docker<br>Reading: OpenStack 云计算实战手册，OpenStack 企业云<br>Proxy Server 不存在单节点问题，proxy无状态</p><h2 id="CoreOS-与容器管理"><a href="#CoreOS-与容器管理" class="headerlink" title="CoreOS 与容器管理"></a>CoreOS 与容器管理</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开源中国2014年终盛典大会参会笔记&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="https://beanlee.github.io/categories/Note/"/>
    
    
      <category term="note" scheme="https://beanlee.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之VPN推荐系列</title>
    <link href="https://beanlee.github.io/2014/06/28/How-To-Connect-Internet-With-VPN/"/>
    <id>https://beanlee.github.io/2014/06/28/How-To-Connect-Internet-With-VPN/</id>
    <published>2014-06-27T16:00:01.000Z</published>
    <updated>2018-02-27T04:14:51.744Z</updated>
    
    <content type="html"><![CDATA[<p>“工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。</p><a id="more"></a><p>刚刚加班到家，整理一下这篇最近在查阅资料关于VPN的一些内容，以及一些付费VPN的简单介绍。</p><h3 id="什么是VPN"><a href="#什么是VPN" class="headerlink" title="什么是VPN"></a>什么是VPN</h3><p>VPN 可以通过特殊的加密通讯协议，在连接 Internet 上位于不同地方的两个或多个企业内部网之间建立一条专有的通讯线路；就好比是架设了一条专线，但它并不需要真正的去铺设光缆之类的物理线路；就像去电信局申请专线，但是不用给铺设线路的费用，也不用购买路由器等硬件设备。</p><p>VPN 技术原是路由器的重要技术之一，在交换机、防火墙设备或各大操作系统里也都支持 VPN 功能，VPN 的核心就是利用公共网络建立虚拟私有网。</p><p>通俗的说，如果你想不被别人探查到你的 IP 地址，如果你想访问大量原本无法登录的国外网站，如果你想更安全进行数据传输，请使用 VPN。</p><h3 id="PPTP和L2TP区别"><a href="#PPTP和L2TP区别" class="headerlink" title="PPTP和L2TP区别"></a>PPTP和L2TP区别</h3><p>最常见最流行的 VPN 协议包含 PPTP 协议和 L2TP/IPSec 协议。如果你希望设置简单，对通信安全没有太大的要求，那么你配置 PPTP 连接即可；如果你的网络里 PPTP 协议未被允许，或者希望数据通信更安全的话，就推荐设置 L2TP/IPSec 连接。在设置上，步骤基本一致，只是 L2TP/IPSec 协议需要输入共享密钥。</p><ul><li>PPTP（Point to Point Tunneling Protocol）点对点隧道协议：是一种主要用于 VPN 的数据链路层网络协议，PPTP 的协议规范本身并未描述加密或身份验证的特性。</li><li>L2TP（Layer Two Tunneling Protocol) 第二层隧道协议：是一种数据链路层隧道协议，通常用于虚拟专用网。L2TP 协议自身不对传输的数据进行加密，但是可以和加密协议搭配使用，从而实现数据的加密传输。经常与 L2TP 协议搭配的加密协议是 IPsec，当这两个协议搭配使用时，通常合称 L2TP/IPsec。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>科学上网</li><li>配置方便，配置好以后，直接连接，就可以使用</li><li>安全，一把双刃剑，因为VPN连接，我们的数据包都是通过中间服务器转发，VPN提供了很多种加密的方式，这样就可以很好地保护我们的隐私，隐藏IP等。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>受GFW干扰较大，由于使用UDP技术，连接可能受干扰</li><li>比较依赖本地的网络环境</li><li>ISP网络的可能会阻止VPN的连接，导致连不上或者速度慢</li><li>VPN是保持连接，不是特别灵活，要断要连在使用过程中难免有麻烦</li><li>安全，不能排除我们的数据包被中间服务器抓包或者截取的可能。</li></ul><h2 id="选择VPN"><a href="#选择VPN" class="headerlink" title="选择VPN"></a>选择VPN</h2><p>前面一些“科普”的文字给大家码好字之后，下面笔者在选购VPN的时候主要关注一下几点，在这里和各位分享一下，可能与各位不同，欢迎读者朋友讨论吐槽！</p><ul><li><strong>稳定性</strong>：这是我比较重视一点，所以放在第一个，VPN的连接速度以及连接的稳定性，直接影响到使用者的感受，之所以找付费版VPN，最重要的就是想享受稳定的连接，不希望遇到经常掉线重连，或者经常不得不被动地切换多个连接。</li><li><strong>终端支持</strong>：我的需求是希望支持Mac、iPhone、iPad至少三台终端同时连接，这样在多端就可以无缝享受网络。</li><li><strong>连接速度</strong>（上行/下行）：不知道读者朋友有没有跟笔者一样的感受，网络慢得时候电脑也会有慢得错觉。当然了，“慢”一定有很多原因，也可能是错觉，但是连接VPN后同样拥有普通连接相同或者不会降低很多的网络速度，是非常重要的一点，也同样是申请VPN退款的原因之一。</li><li><strong>价格</strong>（按量付费/按时付费）以及<strong>支付方式</strong>：按时 or 按量，这个取决于使用者的需求，如果像笔者一样是新手或者换种说法是首次希望通过付费VPN的方式“科学上网”，偶尔登录Google查阅资料，而且不用刷Twitter，暂时没有部署在国外服务器上的网站需要维护的话，可以选择价位不高且流量不大的服务；支付方式也被我放在这里，国内的很多朋友可能没有双币信用卡，Paypal付款难免有些麻烦，查了好几个VPN的服务商都已经支持支付宝付款了，还是很方便的。</li><li><strong>配置难易度、客服响应速度</strong>：</li><li><strong>隐私安全</strong>：毕竟我们在通过VPN连接时，本地的数据包是发送到远方服务器再跳转的，这期间是否会被抓包，窃取资料就是一个值得考虑的问题，笔者建议不用在VPN连接时使用网银等，即使VPN已经声明了数据信息已经加密，要保持警惕，保护隐私。</li><li><strong>服务器地点</strong>：这点可能目前阶段不是笔者比较在意的一点，无论VPN服务商提供的是美国、日本、加拿大、台湾等何地的服务器，对于笔者来说不是特别重要，只要可以达到稳定的连接就可以。但是对于一些对服务地有强烈需求的朋友来说，比如一些游戏玩家，PS4和XBOX必须要连接当地的服务才能玩，这时服务器所在的地点就成了比较重要的考虑因素之一了。</li></ul><h2 id="付费VPN收集"><a href="#付费VPN收集" class="headerlink" title="付费VPN收集"></a>付费VPN收集</h2><p>很幸运在微博上认识一位朋友<a href="http://weibo.com/liwei198870" target="_blank" rel="noopener">聆听潇湘雨</a>，请教了一些知识，也很感谢他推荐了几个付费VPN给我，包括我自己查阅的资料在下面罗列一下，具体服务需要等各位用户先自己试用，稍后再提供我的使用报告：</p><ul><li><a href="https://www.pandafan.org/?r=2885" target="_blank" rel="noopener">熊猫翻滚</a> 顾名思义，熊猫天朝特产，朋友推荐说智能分流做的很好，就是国内和国外的网站可以自动区分，这样连接VPN的同时国内网站的访问速度影响有效降低。</li><li><a href="https://www.ytvpn.com/" target="_blank" rel="noopener">云梯</a>  在V2EX社区看到有人推荐过，也注册了一下，同学有需求想下载Google Android文档和源码，于是就买了这家的服务，速度还是很快的，支持3天内退款。</li><li><a href="https://getqujing.com/zh-CN" target="_blank" rel="noopener">曲径</a>  官网介绍是为了国外音乐类流量服务，有一些大V也在各自的推文中有介绍，想必也积累了一些人气，服务应该做的还是不错的，要不然也不会这么多人推荐。可月付或者季付、限流量，其【冬月】套餐比较适合多终端的用户。</li><li><a href="https://theqingyun.co/r/ncmbi3" target="_blank" rel="noopener">轻云</a>  资费比较合理，支持的设备较多，同时允许7台设备在线。</li><li><a href="http://98.126.129.242/index.php" target="_blank" rel="noopener">YesVPN</a>  包月10RMB，包年100RMB</li><li><a href="https://www.shayujsq.net/index.php" target="_blank" rel="noopener">鲨鱼VPN</a> </li><li>Google搜索 付费VPN 关键字 : )</li></ul><h2 id="VPN-FOR-FREE"><a href="#VPN-FOR-FREE" class="headerlink" title="VPN FOR FREE"></a>VPN FOR FREE</h2><ul><li>Chrome插件 - <a href="http://honx.in/i/U7DdTYKo11MoCLEP" target="_blank" rel="noopener">红杏</a> 浏览器上的插件，使用者仅仅通过安装Chrome浏览器插件，使用邮箱注册用户，就可以直接访问Google、Facebook和Twitter了。简单使用，缺点非VIP版服务器不是特别稳定，笔者在最近3天的使用过程中有一天下午基本无法使用，服务断断续续。当然也可以购买VIP版，笔者还没有购买体验就不便在这里细说，如果仅限浏览器翻墙，查看网页或者单线程下载一些小文件的话，这颗“红杏”是个不错的选择。</li></ul><p>文章还没写完，今天红杏免费版就挂了，但是红杏VIP版还是很受欢迎的。</p><ul><li>Google搜索 免费VPN 关键字即可 : )</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在完成这篇Blog的过程中，查阅的信息逐渐像水滴波纹一样散开，信息量过大，越来越害怕，觉得这里需要做功课的东西还是太多，有些不敢写了，因此标题也是改了又改，缩小范围。后面补补课再给各位带来其他科学上网的方式。</p><p>因为目前对科学上网需求不是那么强烈，因此在写完这篇Blog后，我觉得先买一个熊猫翻滚之学术熊猫试用一个月（这其中也有微博朋友极力推荐的因素）。</p><p>其他科学上网收集如下，以后有机会在研究跟大家分享：</p><ul><li><a href="https://eurekavpt.com" target="_blank" rel="noopener">eurekavpt</a></li><li><a href="http://ippotsuko.com/blog/shadowsocks/" target="_blank" rel="noopener">ShadowSocks</a></li><li><a href="https://pcnt.in/" target="_blank" rel="noopener">PowerConnect</a> &amp;&amp; <a href="https://twitter.com/PowerPACNetwork" target="_blank" rel="noopener">官方 Twitter</a> 会不定时放出邀请码</li><li>….</li></ul>]]></content>
    
    <summary type="html">
    
      “工欲善其事，必先利其器” 今天笔者来和大家一起分享，最近查阅资料整理后的一些关于VPN的那点事儿。
    
    </summary>
    
      <category term="技术" scheme="https://beanlee.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="VPN" scheme="https://beanlee.github.io/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Mac Tool</title>
    <link href="https://beanlee.github.io/2014/06/19/Mac-Tool-Series-1/"/>
    <id>https://beanlee.github.io/2014/06/19/Mac-Tool-Series-1/</id>
    <published>2014-06-18T16:00:01.000Z</published>
    <updated>2018-02-27T04:14:20.329Z</updated>
    
    <content type="html"><![CDATA[<p>推荐的两款软件，它们有助于我提高效率，因此来完成这篇推介文。<br>Dash 一款用来集成快速查阅文档；CheatSheet 一款用来提示快捷键。</p><a id="more"></a><p><img src="http://ww3.sinaimg.cn/mw690/454c4867jw9ehyt3n7t8tj20g407lq42.jpg" alt="&#39;tools_1&#39;"></p><h1 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h1><p>相信日常工作或者做个人开发的朋友，浏览器的收藏夹中一定有一个文件夹，里面收藏了n个技术类的在线文档以及各种代码片段，Dash就是这样一款专注于提供各类API文档和收藏代码片段的工具。</p><h3 id="值得推荐"><a href="#值得推荐" class="headerlink" title="值得推荐"></a>值得推荐</h3><ul><li>推荐点1-内容丰富<br>具备丰富的Docsets，并且都是提供官方原版材料。</li></ul><p><img src="http://ww2.sinaimg.cn/mw690/454c4867jw1emgqaa8qw6j21ki0zw489.jpg" alt="&#39;tools_dash_1&#39;"></p><ul><li>推荐点2-快速查询<br>Dash提供快速的查询，这其中包括多文档的联合查询，以及在某一个Docset中查询，查询流畅度很好。</li></ul><p>图片TODO</p><ul><li>缺点<br>售价昂贵，目前Dash Full Version要RMB128，在淘宝上购买是个不错的选择；如果可以忍受偶尔查询等待8s时间出结果，可以使用免费版；一些SDK和API受限于系统，只提供链接，如Objective-C等，值得高兴的是Swift可以直接查询很下载查阅。</li></ul><h1 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h1><p>这是一款可以显示当前应用所有快捷键列表的软件，使用者只需要按住Command就能见识到他的强大之处。在笔者还没有Mac的时候，关注<a href="http://www.appinn.com" target="_blank" rel="noopener">小众软件</a>的时候看到他的推荐，于是就在<a href="http://www.cheatsheetapp.com/CheatSheet/" target="_blank" rel="noopener">CheatSheet官网</a>下载收藏了这款可以提高效率的软件。<br>PS.顾名思义快捷键是可以帮助使用者提高效率，善用、习惯快捷键，以及调整自己数字的快捷键可以更有效的提高自己的效率，这无疑也是帮助我们自己提高的方式之一。</p>]]></content>
    
    <summary type="html">
    
      Mac OSX 下佳软推荐 Dash 和 CheatSheet
    
    </summary>
    
      <category term="技术" scheme="https://beanlee.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Tool" scheme="https://beanlee.github.io/tags/Tool/"/>
    
      <category term="Mac" scheme="https://beanlee.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Swift Study 1</title>
    <link href="https://beanlee.github.io/2014/06/08/Study-Swift-1/"/>
    <id>https://beanlee.github.io/2014/06/08/Study-Swift-1/</id>
    <published>2014-06-07T16:00:01.000Z</published>
    <updated>2018-02-27T04:14:08.976Z</updated>
    
    <content type="html"><![CDATA[<p>Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!</p><a id="more"></a><h2 id="Swift-学习笔记-一"><a href="#Swift-学习笔记-一" class="headerlink" title="Swift 学习笔记 一"></a>Swift 学习笔记 一</h2><p>从2014-06-09开始每日更新，督促自己学习坚持，一周为一篇周期，加油！</p><h3 id="材料收集"><a href="#材料收集" class="headerlink" title="材料收集"></a>材料收集</h3><p><a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11" target="_blank" rel="noopener">官方iBook版</a></p><p>IDE Xcode 6 Beta</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure><h3 id="2014-06-09记录"><a href="#2014-06-09记录" class="headerlink" title="2014-06-09记录"></a>2014-06-09记录</h3><p>学习常量(let)、变量(var)定义的方法，字符串参数传递()，Swift类型推导 var numValue = 123, strValue = “abc”，数组和字典定义方式等等。</p><p>函数的定义func，如:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(name)</span>, Today is <span class="subst">\(day)</span> !"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可变参数的函数定义，如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf()</span><br><span class="line">sumOf(<span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)”</span><br></pre></td></tr></table></figure></p><p>正在看极客学院的 Weather App 的教学视频，看来需要恶补的一些交互还有很多，加油！</p><h3 id="2014-06-10记录"><a href="#2014-06-10记录" class="headerlink" title="2014-06-10记录"></a>2014-06-10记录</h3><p>看完做Weather App的Demo视频，熟悉一个可以解析JSON的工具API</p><pre><code>NSJSONSerialization</code></pre><p>重新回头继续看文档，最近加班和参加Interview，阅读的时间少了，要坚持看！</p><p><a href="http://numbbbbb.github.io/the-swift-programming-language-in-chinese/" target="_blank" rel="noopener">GitBook 中文版Swift文档</a></p><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。</p><p>在类型后面加一个问号来标记这个变量的值是可选的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? = <span class="string">"Hello"</span></span><br><span class="line">optionalString == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>? = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">"Hello, <span class="subst">\(name)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if的条件如果是 nil 就是false。</p><p>switch case中一定要有default否则编译会报错，因为进入这个条件操作可能会没有出口。</p><p>循环中使用 .. 创建的范围不包含上界，如果想包含的话需要使用 … ，如（0…10 表达从0开始到10，且包括10；0..10 则表单从0开始到10但不包括10）</p><h4 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h4><p>前面在视频里面看到了函数的定义方法，这里通过文档再整理一下。</p><p>使用func来声明一个函数，使用名字和参数来调用函数。使用-&gt;来指定函数返回值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(name)</span>, today is <span class="subst">\(day)</span>."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"Bob"</span>, <span class="string">"Tuesday"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="2014-06-11"><a href="#2014-06-11" class="headerlink" title="2014-06-11"></a>2014-06-11</h3><p>枚举、闭包实践。</p><p>今天公司足球赛，太累就暂时依照视频教程做了个读取天气的demo，明天继续！</p><h3 id="2014-06-15"><a href="#2014-06-15" class="headerlink" title="2014-06-15"></a>2014-06-15</h3><p>遇上公司加班延误了三天，世界杯开幕熬夜看比赛又导致晚上需要稍微早一点睡，最近学习计划有些延后，今天反省一下！Swift学习今天暂缓停一下，整理了一下个人Resume，同时在这期间了解Mac一个很有用的软件<a href="https://itunes.apple.com/us/app/dash-docs-snippets/id458034879?mt=12" target="_blank" rel="noopener">Dash</a>（汇集SDK文档和Sheets快速查询查看工具），推荐给在Mac环境下做开发的各位朋友！</p><p>to be continue…</p>]]></content>
    
    <summary type="html">
    
      Swift is an important chance to find coding passion back to me. So Do Not Lose It! Come on!
    
    </summary>
    
      <category term="技术" scheme="https://beanlee.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Apple" scheme="https://beanlee.github.io/tags/Apple/"/>
    
      <category term="Swift" scheme="https://beanlee.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Java基础集合类复习</title>
    <link href="https://beanlee.github.io/2014/06/06/Java-Collection-Review/"/>
    <id>https://beanlee.github.io/2014/06/06/Java-Collection-Review/</id>
    <published>2014-06-05T16:00:01.000Z</published>
    <updated>2018-02-27T04:14:02.660Z</updated>
    
    <content type="html"><![CDATA[<p>Java基础集合类的问题简单整理</p><a id="more"></a><h1 id="JAVA基础集合类Review"><a href="#JAVA基础集合类Review" class="headerlink" title="JAVA基础集合类Review"></a>JAVA基础集合类Review</h1><p>##JAVA集合类分类</p><ul><li>Collection：通常是一组有一定规律的独立元素。List必须按照特定的顺序持有这些元素，而Set则不能保存重复的元素。</li><li>Map：一组以“键－－值”（key-value）形式出现的pairs。</li></ul><h3 id="Collection-Interface"><a href="#Collection-Interface" class="headerlink" title="Collection Interface"></a>Collection Interface</h3><p>Collection是最基本的集合接口，它下面的实现类包括List(LinkedList, ArrayList,Vector)、Set等。</p><ul><li><p>List接口是有序的Collection，每一个元素都能够被用户使用索引来访问，类似Java中的数组。与Set不同，List允许存在相同的元素。</p><p>LinkedList:它是有序的允许元素为null，并且提供额外的get，remove，insert方法来操作LinkedList的首或尾部，类似链表的结构，可以用来实现堆栈（Stack）、队列（Queue）或者双向队列（Deque），它是不同步的。</p><p>ArrayList:它的内部实现机制实际上使用的是Object数组，且一个大小可变，但是每一个ArrayList在初始化时都有一个容量，外部看这个容量是可以根据元素的添加自动增加。当容量不够时，系统就会创建一个更大的数组（1.5倍左右）并且把老的数组完全拷贝到新的数组中，同时老数组就自动进入GC待处理状态，等待垃圾回收。</p><p>相比LinkedList，ArrayList中的get(index)的方法速度较快，效率高。</p><p>Vector:线程同步的ArrayList，当一个线程开始迭代Vector时，另一个线程来添加、删除等改变Vector时，就会抛出ConcurrentModificationException。</p><p>Stack:继承自Vector，从名字可以看出堆栈，它实现了一个后进先出的堆栈。</p></li></ul><ul><li>Set接口是一种不允许重复的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。这其中equals方法就是依靠元素的hashCode来判断是否相等，有时可以通过重写一些对象的HashCode方法来改变判断相等的判断逻辑。</li></ul><h3 id="Map-Interface"><a href="#Map-Interface" class="headerlink" title="Map Interface"></a>Map Interface</h3><ul><li><p>HashTable</p><p>HashTable集成Map接口，实现了一个key-value映射的哈希表。任何非空（non-null）的对象都可以作为key或value。HashTable是线程同步的。</p><p>不了解的知识点：Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。</p><p>hashCode和equals方法是否重写相关：</p></li><li><p>HashMap</p><p>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p></li><li><p>WeakHashMap</p><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。实际开发中还没有用过，可以尝试用一下。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li><li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。</li><li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li><li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li><li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li><li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://liuzhichao.com/p/652.html" target="_blank" rel="noopener">柳志超Blog中一篇文章《Java集合类》</a></p>]]></content>
    
    <summary type="html">
    
      Java基础集合类的问题简单整理
    
    </summary>
    
      <category term="技术" scheme="https://beanlee.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="https://beanlee.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Java" scheme="https://beanlee.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>有设计感的数码产品才能打动人心</title>
    <link href="https://beanlee.github.io/2014/04/12/Misfit-Shine/"/>
    <id>https://beanlee.github.io/2014/04/12/Misfit-Shine/</id>
    <published>2014-04-11T16:00:01.000Z</published>
    <updated>2018-02-27T04:20:54.673Z</updated>
    
    <content type="html"><![CDATA[<p>夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享</p><a id="more"></a><h3 id="运动快乐"><a href="#运动快乐" class="headerlink" title="运动快乐"></a>运动快乐</h3><p>笔者很喜爱有氧运动，偏爱足球和跑步，小时候就经常抱着足球跟着一帮小伙伴去虽然满是尘土的足球场。（PS.这里吐槽一下，很多人吐槽国足，国内的足球氛围不浓，连基础设备完善的足球场都很少，尤其是在二三线城市）</p><p>先来和各位分享一下当时购买这款运动手环的初衷，应该说早在2012年的Google Glass在全球兴起了穿戴式数码设备的热潮，诸多厂商都在各自的领域跟进，这其中运动检测类的运动手环，种类颇为丰富。笔者一直是个夜跑爱好者，期初对此并没有太大需求也就没有关注。直到时隔2年后，无意间在网络中看到百度旗下公司也有一款运动手环，即将发布的新闻才再次被勾起兴趣，通过网络搜索一些资料查阅了解，越发感觉穿戴式数码产品对生活的重要性越来越大，因此决定购入，以此激励自己加强运动，运动最快乐！</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>根据Shine的名字自行Google :)</p><h3 id="三款手环简单对比"><a href="#三款手环简单对比" class="headerlink" title="三款手环简单对比"></a>三款手环简单对比</h3><p>笔者的数码硬件消费级别，尚处于“屌丝”级别，包括每次买很多数码电子产品都要经过一段时间研究和对比，纠结过才会购买，这款也同样不例外。这里只简单说明一下三种智能手环的差异。</p><ul><li>Jawbone UP</li><li>Fitbit Flex</li><li>Misfit Shine</li></ul><p><img src="http://ww4.sinaimg.cn/mw690/454c4867gw1efc2f6n55ij20ug0ee41k.jpg" alt="&#39;compare&#39;"></p><h3 id="Some-Pics"><a href="#Some-Pics" class="headerlink" title="Some Pics"></a>Some Pics</h3><p><img src="http://ww3.sinaimg.cn/mw690/454c4867gw1efc2cbmd5lj20qo140wor.jpg" alt="&#39;misfit&#39;"></p><h3 id="Shine优缺点"><a href="#Shine优缺点" class="headerlink" title="Shine优缺点"></a>Shine优缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>科技感、设计感十足，硬币大小戴在手上非常酷，通过几天的使用测试，运动记忆比较精准，包括睡眠模式中记录深度睡眠的时长，相对比较准确。</li><li>在2013年获得红点设计奖，小小的运动检测器，戴的时间长了存在感非常小，不会影响正常生活，在收集资料的过程中，笔者看到很多网上的朋友甚至丢了好几天，想起来同步运动信息的时候才发现找不到的情况。（这也可能变相的算是一种缺点吧:P）</li><li>Shine没有具象的显示器或者曲面屏幕，而且采用防水设计材质非常好的金属，用激光蚀刻的小孔伴随着小小的LED，轻拍两下，显示目前完成了当天既定目标的百分比，和很酷的点数时间，初看有些摸不到头脑但笔者使用几天下来基本习惯快速时间时间；轻拍三下，就可以自动切换运动模式，比如跑步、游泳、足球等。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>缺少其他手环中比较方便实用的智能唤醒闹钟，通过在手腕上的轻微震动达到闹钟作用的功能，相信不少上班族的朋友每天清晨都偶尔会被刺耳的闹铃叫醒，非常不爽！PS.如果想永远不再想听一首歌，那就把它设置成闹钟吧！</li><li>与手机App同步没有实现真正的自动同步，由于新鲜感，笔者会每天多次拿起手机点开Shine的App点击同步，相信以后频率会下降，目前每天早上打开App看自己前一天晚上深度睡眠时间倒是一件非常有意思的事。</li><li>App的SNS特性，相比国内相似运动类App略差，但换个思路，也许Shine团队是为了人们更加关注运动，他们比较和互动不应该喧宾夺主也说不定。</li></ul><h3 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h3><p>Misfit Shine对于笔者来说是个很好的选择，我可以接受它的全部优缺点，并且在使用过程中会把自己的意见和体验结果通过邮件的方式反馈给Misfit的团队。（天晓得我的邮件中的英文他们能不能看懂或者根本被忽视掉也说不定）</p><p>原本想在这篇写完之前可以戴着Shine踢球，看看记录是什么样的，碰巧本周没有机会</p>]]></content>
    
    <summary type="html">
    
      夏日来袭，笔者对比了几款运动手环，最终入手Misfit Shine带来开箱图文和简单对比分享
    
    </summary>
    
      <category term="blog" scheme="https://beanlee.github.io/categories/blog/"/>
    
    
      <category term="数码产品" scheme="https://beanlee.github.io/tags/%E6%95%B0%E7%A0%81%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>书摘随笔</title>
    <link href="https://beanlee.github.io/2014/03/20/Read-The-Book-Of-Zhihu/"/>
    <id>https://beanlee.github.io/2014/03/20/Read-The-Book-Of-Zhihu/</id>
    <published>2014-03-19T16:00:01.000Z</published>
    <updated>2018-02-27T04:13:34.164Z</updated>
    
    <content type="html"><![CDATA[<p>读《创业时，我们在知乎聊什么》书摘随笔一</p><blockquote><p>最小化可行产品 汪华说，你一开始的所有计划其实只是对用户和市场的假定而已，小团队的钱和资源也都有限，必须先快速地找个办法验证方向。 所以产品的第一个版本的目的，是验证用户需求和反馈，而不是做一个完美无缺、功能丰富的版本。第一版应该集中于开发出产品的核心功能和核心需求，也就是那个用户。</p></blockquote><a id="more"></a><p>建议：</p><ul><li>1、尽量地使用现成的代码框架、末班、开源项目、API，使用现成的工具，哪怕不是100%符合需要，有了用户量之后再重构。</li><li>2、第一版可以简单解决，部分可用静态页面或者人工干预。</li><li>3、在完成功能的过程中考虑后续版本的可升级性，但不要过分专注，否则会影响进度。</li><li>4、找到所有相似、相关、上下游产品重新学习。</li><li>5、如果是互联网产品想清楚需要验证什么用户行为和数据，并在产品中跟踪收集，不要盲目收集。</li><li>6、界面简洁，保证核心功能在主要位置，且一键访问无歧义最好。</li><li>7、专注80%精力在核心功能上，核心要完美，其余部分可以后完善，否则顾此失彼。</li><li>8、快速、稳定，很多东西不是一定必须，能砍则砍。</li><li>9、重视用户反馈，建立社区或者有效沟通平台。</li><li>10、外围也不可忽视，类似门户网站等尽量有新意。</li><li>11、如果专职严格进度，日毕日清，不为严重问题拖延。</li></ul>]]></content>
    
    <summary type="html">
    
      读《创业时，我们在知乎聊什么》书摘随笔一
    
    </summary>
    
      <category term="blog" scheme="https://beanlee.github.io/categories/blog/"/>
    
    
      <category term="阅读" scheme="https://beanlee.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>微博等SNS@功能探索技术验证总结</title>
    <link href="https://beanlee.github.io/2014/01/10/The-Summary-of-At/"/>
    <id>https://beanlee.github.io/2014/01/10/The-Summary-of-At/</id>
    <published>2014-01-09T16:00:01.000Z</published>
    <updated>2018-02-27T04:13:29.919Z</updated>
    
    <content type="html"><![CDATA[<p>公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享</p><a id="more"></a><h3 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h3><p><img src="http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jb40u64j21kw16jwun.jpg" alt="&#39;at1&#39;"></p><p><img src="http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jbxfjq2j21kw16l7ji.jpg" alt="&#39;at2&#39;"></p><p><img src="http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jckue5ij21kw16i4di.jpg" alt="&#39;at3&#39;"></p><p><img src="http://ww3.sinaimg.cn/mw690/454c4867tw1eh7jd9hmrdj21kw16oard.jpg" alt="&#39;at4&#39;"></p><p><img src="http://ww4.sinaimg.cn/mw690/454c4867tw1eh7jdwwe68j21kw16m4dc.jpg" alt="&#39;at5&#39;"></p><p><img src="http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jekivd4j21kw16f4f4.jpg" alt="&#39;at6&#39;"></p><p><img src="http://ww2.sinaimg.cn/mw690/454c4867tw1eh7jf7bxdqj21kw16lwty.jpg" alt="&#39;at7&#39;"></p><p><img src="http://ww1.sinaimg.cn/mw690/454c4867tw1eh7jfykgw8j21kw16ined.jpg" alt="&#39;at8&#39;"></p>]]></content>
    
    <summary type="html">
    
      公司阶段技术预言项，推特微博等@人员功能，断断续续3-4天时间，做了一些总结在Blog中和大家分享
    
    </summary>
    
      <category term="技术" scheme="https://beanlee.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="总结" scheme="https://beanlee.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
